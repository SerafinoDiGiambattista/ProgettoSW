<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="0.9.5" language="C#" filename="C:\Users\Serafino\Desktop\C#\PRJs_Recall\zanval_MiniLD62\Library\PackageCache\com.unity.textmeshpro@1.3.0\Scripts\Runtime\TMP_Text.cs"><cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TMP_PRESENT</name></cpp:macro></cpp:define>

<using>using <name>UnityEngine</name>;</using>
<using>using <name><name>UnityEngine</name><operator>.</operator><name>UI</name></name>;</using>
<using>using <name><name>UnityEngine</name><operator>.</operator><name>Events</name></name>;</using>
<using>using <name><name>UnityEngine</name><operator>.</operator><name>EventSystems</name></name>;</using>
<using>using <name>System</name>;</using>
<using>using <name><name>System</name><operator>.</operator><name>Text</name></name>;</using>
<using>using <name><name>System</name><operator>.</operator><name>Collections</name></name>;</using>
<using>using <name><name>System</name><operator>.</operator><name>Collections</name><operator>.</operator><name>Generic</name></name>;</using>


<namespace>namespace <name>TMPro</name>
<block>{
    <interface><specifier>public</specifier> interface <name>ITextElement</name>
    <block>{
        <property><type><name>Material</name></type> <name>sharedMaterial</name> <block>{ <function_decl><name>get</name>;</function_decl> }</block></property>

        <function_decl><type><name>void</name></type> <name>Rebuild</name><parameter_list>(<parameter><decl><type><name>CanvasUpdate</name></type> <name>update</name></decl></parameter>)</parameter_list>;</function_decl>
        <function_decl><type><name>int</name></type> <name>GetInstanceID</name><parameter_list>()</parameter_list>;</function_decl>
    }</block></interface>

    <enum><specifier>public</specifier> enum <name>TextAlignmentOptions</name>
    <block>{
        <decl><name>TopLeft</name> <init>= <expr><name><name>_HorizontalAlignmentOptions</name><operator>.</operator><name>Left</name></name> <operator>|</operator> <name><name>_VerticalAlignmentOptions</name><operator>.</operator><name>Top</name></name></expr></init></decl>,
        <decl><name>Top</name> <init>= <expr><name><name>_HorizontalAlignmentOptions</name><operator>.</operator><name>Center</name></name> <operator>|</operator> <name><name>_VerticalAlignmentOptions</name><operator>.</operator><name>Top</name></name></expr></init></decl>,
        <decl><name>TopRight</name> <init>= <expr><name><name>_HorizontalAlignmentOptions</name><operator>.</operator><name>Right</name></name> <operator>|</operator> <name><name>_VerticalAlignmentOptions</name><operator>.</operator><name>Top</name></name></expr></init></decl>,
        <decl><name>TopJustified</name> <init>= <expr><name><name>_HorizontalAlignmentOptions</name><operator>.</operator><name>Justified</name></name> <operator>|</operator> <name><name>_VerticalAlignmentOptions</name><operator>.</operator><name>Top</name></name></expr></init></decl>,
        <decl><name>TopFlush</name> <init>= <expr><name><name>_HorizontalAlignmentOptions</name><operator>.</operator><name>Flush</name></name> <operator>|</operator> <name><name>_VerticalAlignmentOptions</name><operator>.</operator><name>Top</name></name></expr></init></decl>,
        <decl><name>TopGeoAligned</name> <init>= <expr><name><name>_HorizontalAlignmentOptions</name><operator>.</operator><name>Geometry</name></name> <operator>|</operator> <name><name>_VerticalAlignmentOptions</name><operator>.</operator><name>Top</name></name></expr></init></decl>,

        <decl><name>Left</name> <init>= <expr><name><name>_HorizontalAlignmentOptions</name><operator>.</operator><name>Left</name></name> <operator>|</operator> <name><name>_VerticalAlignmentOptions</name><operator>.</operator><name>Middle</name></name></expr></init></decl>,
        <decl><name>Center</name> <init>= <expr><name><name>_HorizontalAlignmentOptions</name><operator>.</operator><name>Center</name></name> <operator>|</operator> <name><name>_VerticalAlignmentOptions</name><operator>.</operator><name>Middle</name></name></expr></init></decl>,
        <decl><name>Right</name> <init>= <expr><name><name>_HorizontalAlignmentOptions</name><operator>.</operator><name>Right</name></name> <operator>|</operator> <name><name>_VerticalAlignmentOptions</name><operator>.</operator><name>Middle</name></name></expr></init></decl>,
        <decl><name>Justified</name> <init>= <expr><name><name>_HorizontalAlignmentOptions</name><operator>.</operator><name>Justified</name></name> <operator>|</operator> <name><name>_VerticalAlignmentOptions</name><operator>.</operator><name>Middle</name></name></expr></init></decl>,
        <decl><name>Flush</name> <init>= <expr><name><name>_HorizontalAlignmentOptions</name><operator>.</operator><name>Flush</name></name> <operator>|</operator> <name><name>_VerticalAlignmentOptions</name><operator>.</operator><name>Middle</name></name></expr></init></decl>,
        <decl><name>CenterGeoAligned</name> <init>= <expr><name><name>_HorizontalAlignmentOptions</name><operator>.</operator><name>Geometry</name></name> <operator>|</operator> <name><name>_VerticalAlignmentOptions</name><operator>.</operator><name>Middle</name></name></expr></init></decl>,

        <decl><name>BottomLeft</name> <init>= <expr><name><name>_HorizontalAlignmentOptions</name><operator>.</operator><name>Left</name></name> <operator>|</operator> <name><name>_VerticalAlignmentOptions</name><operator>.</operator><name>Bottom</name></name></expr></init></decl>,
        <decl><name>Bottom</name> <init>= <expr><name><name>_HorizontalAlignmentOptions</name><operator>.</operator><name>Center</name></name> <operator>|</operator> <name><name>_VerticalAlignmentOptions</name><operator>.</operator><name>Bottom</name></name></expr></init></decl>,
        <decl><name>BottomRight</name> <init>= <expr><name><name>_HorizontalAlignmentOptions</name><operator>.</operator><name>Right</name></name> <operator>|</operator> <name><name>_VerticalAlignmentOptions</name><operator>.</operator><name>Bottom</name></name></expr></init></decl>,
        <decl><name>BottomJustified</name> <init>= <expr><name><name>_HorizontalAlignmentOptions</name><operator>.</operator><name>Justified</name></name> <operator>|</operator> <name><name>_VerticalAlignmentOptions</name><operator>.</operator><name>Bottom</name></name></expr></init></decl>,
        <decl><name>BottomFlush</name> <init>= <expr><name><name>_HorizontalAlignmentOptions</name><operator>.</operator><name>Flush</name></name> <operator>|</operator> <name><name>_VerticalAlignmentOptions</name><operator>.</operator><name>Bottom</name></name></expr></init></decl>,
        <decl><name>BottomGeoAligned</name> <init>= <expr><name><name>_HorizontalAlignmentOptions</name><operator>.</operator><name>Geometry</name></name> <operator>|</operator> <name><name>_VerticalAlignmentOptions</name><operator>.</operator><name>Bottom</name></name></expr></init></decl>,

        <decl><name>BaselineLeft</name> <init>= <expr><name><name>_HorizontalAlignmentOptions</name><operator>.</operator><name>Left</name></name> <operator>|</operator> <name><name>_VerticalAlignmentOptions</name><operator>.</operator><name>Baseline</name></name></expr></init></decl>,
        <decl><name>Baseline</name> <init>= <expr><name><name>_HorizontalAlignmentOptions</name><operator>.</operator><name>Center</name></name> <operator>|</operator> <name><name>_VerticalAlignmentOptions</name><operator>.</operator><name>Baseline</name></name></expr></init></decl>,
        <decl><name>BaselineRight</name> <init>= <expr><name><name>_HorizontalAlignmentOptions</name><operator>.</operator><name>Right</name></name> <operator>|</operator> <name><name>_VerticalAlignmentOptions</name><operator>.</operator><name>Baseline</name></name></expr></init></decl>,
        <decl><name>BaselineJustified</name> <init>= <expr><name><name>_HorizontalAlignmentOptions</name><operator>.</operator><name>Justified</name></name> <operator>|</operator> <name><name>_VerticalAlignmentOptions</name><operator>.</operator><name>Baseline</name></name></expr></init></decl>,
        <decl><name>BaselineFlush</name> <init>= <expr><name><name>_HorizontalAlignmentOptions</name><operator>.</operator><name>Flush</name></name> <operator>|</operator> <name><name>_VerticalAlignmentOptions</name><operator>.</operator><name>Baseline</name></name></expr></init></decl>,
        <decl><name>BaselineGeoAligned</name> <init>= <expr><name><name>_HorizontalAlignmentOptions</name><operator>.</operator><name>Geometry</name></name> <operator>|</operator> <name><name>_VerticalAlignmentOptions</name><operator>.</operator><name>Baseline</name></name></expr></init></decl>,

        <decl><name>MidlineLeft</name> <init>= <expr><name><name>_HorizontalAlignmentOptions</name><operator>.</operator><name>Left</name></name> <operator>|</operator> <name><name>_VerticalAlignmentOptions</name><operator>.</operator><name>Geometry</name></name></expr></init></decl>,
        <decl><name>Midline</name> <init>= <expr><name><name>_HorizontalAlignmentOptions</name><operator>.</operator><name>Center</name></name> <operator>|</operator> <name><name>_VerticalAlignmentOptions</name><operator>.</operator><name>Geometry</name></name></expr></init></decl>,
        <decl><name>MidlineRight</name> <init>= <expr><name><name>_HorizontalAlignmentOptions</name><operator>.</operator><name>Right</name></name> <operator>|</operator> <name><name>_VerticalAlignmentOptions</name><operator>.</operator><name>Geometry</name></name></expr></init></decl>,
        <decl><name>MidlineJustified</name> <init>= <expr><name><name>_HorizontalAlignmentOptions</name><operator>.</operator><name>Justified</name></name> <operator>|</operator> <name><name>_VerticalAlignmentOptions</name><operator>.</operator><name>Geometry</name></name></expr></init></decl>,
        <decl><name>MidlineFlush</name> <init>= <expr><name><name>_HorizontalAlignmentOptions</name><operator>.</operator><name>Flush</name></name> <operator>|</operator> <name><name>_VerticalAlignmentOptions</name><operator>.</operator><name>Geometry</name></name></expr></init></decl>,
        <decl><name>MidlineGeoAligned</name> <init>= <expr><name><name>_HorizontalAlignmentOptions</name><operator>.</operator><name>Geometry</name></name> <operator>|</operator> <name><name>_VerticalAlignmentOptions</name><operator>.</operator><name>Geometry</name></name></expr></init></decl>,

        <decl><name>CaplineLeft</name> <init>= <expr><name><name>_HorizontalAlignmentOptions</name><operator>.</operator><name>Left</name></name> <operator>|</operator> <name><name>_VerticalAlignmentOptions</name><operator>.</operator><name>Capline</name></name></expr></init></decl>,
        <decl><name>Capline</name> <init>= <expr><name><name>_HorizontalAlignmentOptions</name><operator>.</operator><name>Center</name></name> <operator>|</operator> <name><name>_VerticalAlignmentOptions</name><operator>.</operator><name>Capline</name></name></expr></init></decl>,
        <decl><name>CaplineRight</name> <init>= <expr><name><name>_HorizontalAlignmentOptions</name><operator>.</operator><name>Right</name></name> <operator>|</operator> <name><name>_VerticalAlignmentOptions</name><operator>.</operator><name>Capline</name></name></expr></init></decl>,
        <decl><name>CaplineJustified</name> <init>= <expr><name><name>_HorizontalAlignmentOptions</name><operator>.</operator><name>Justified</name></name> <operator>|</operator> <name><name>_VerticalAlignmentOptions</name><operator>.</operator><name>Capline</name></name></expr></init></decl>,
        <decl><name>CaplineFlush</name> <init>= <expr><name><name>_HorizontalAlignmentOptions</name><operator>.</operator><name>Flush</name></name> <operator>|</operator> <name><name>_VerticalAlignmentOptions</name><operator>.</operator><name>Capline</name></name></expr></init></decl>,
        <decl><name>CaplineGeoAligned</name> <init>= <expr><name><name>_HorizontalAlignmentOptions</name><operator>.</operator><name>Geometry</name></name> <operator>|</operator> <name><name>_VerticalAlignmentOptions</name><operator>.</operator><name>Capline</name></name></expr></init></decl>
    }</block>;</enum>

    <comment type="line">/// &lt;summary&gt;</comment>
    <comment type="line">/// Internal horizontal text alignment options.</comment>
    <comment type="line">/// &lt;/summary&gt;</comment>
    <enum><specifier>public</specifier> enum <name>_HorizontalAlignmentOptions</name>
    <block>{
        <decl><name>Left</name> <init>= <expr><literal type="number">0x1</literal></expr></init></decl>, <decl><name>Center</name> <init>= <expr><literal type="number">0x2</literal></expr></init></decl>, <decl><name>Right</name> <init>= <expr><literal type="number">0x4</literal></expr></init></decl>, <decl><name>Justified</name> <init>= <expr><literal type="number">0x8</literal></expr></init></decl>, <decl><name>Flush</name> <init>= <expr><literal type="number">0x10</literal></expr></init></decl>, <decl><name>Geometry</name> <init>= <expr><literal type="number">0x20</literal></expr></init></decl>
    }</block>

    <comment type="line">/// &lt;summary&gt;</comment>
    <comment type="line">/// Internal vertical text alignment options.</comment>
    <comment type="line">/// &lt;/summary&gt;</comment>
    <decl>public enum <name>_VerticalAlignmentOptions</name>
    <block>{
        <expr_stmt><expr><name>Top</name> <operator>=</operator> <literal type="number">0x100</literal></expr><operator>,</operator> <expr><name>Middle</name> <operator>=</operator> <literal type="number">0x200</literal></expr><operator>,</operator> <expr><name>Bottom</name> <operator>=</operator> <literal type="number">0x400</literal></expr><operator>,</operator> <expr><name>Baseline</name> <operator>=</operator> <literal type="number">0x800</literal></expr><operator>,</operator> <expr><name>Geometry</name> <operator>=</operator> <literal type="number">0x1000</literal></expr><operator>,</operator> <expr><name>Capline</name> <operator>=</operator> <literal type="number">0x2000</literal></expr><operator>,</operator></expr_stmt>
    }</block></decl>


    <comment type="line">/// &lt;summary&gt;</comment>
    <comment type="line">/// Flags controlling what vertex data gets pushed to the mesh.</comment>
    <comment type="line">/// &lt;/summary&gt;</comment>
    <decl>public enum <name>TextRenderFlags</name>
    <block>{
        <expr_stmt><expr><name>DontRender</name> <operator>=</operator> <literal type="number">0x0</literal></expr><operator>,</operator>
        <expr><name>Render</name> <operator>=</operator> <literal type="number">0xFF</literal></expr></expr_stmt>
    }</block></decl>;</enum>

    <enum><specifier>public</specifier> enum <name>TMP_TextElementType</name> <block>{ <decl><name>Character</name></decl>, <decl><name>Sprite</name></decl> }</block>;</enum>
    <enum><specifier>public</specifier> enum <name>MaskingTypes</name> <block>{ <decl><name>MaskOff</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><name>MaskHard</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>, <decl><name>MaskSoft</name> <init>= <expr><literal type="number">2</literal></expr></init></decl> }</block>;</enum> <comment type="line">//, MaskTex = 4 };</comment>
    <enum><specifier>public</specifier> enum <name>TextOverflowModes</name> <block>{ <decl><name>Overflow</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><name>Ellipsis</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>, <decl><name>Masking</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>, <decl><name>Truncate</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>, <decl><name>ScrollRect</name> <init>= <expr><literal type="number">4</literal></expr></init></decl>, <decl><name>Page</name> <init>= <expr><literal type="number">5</literal></expr></init></decl>, <decl><name>Linked</name> <init>= <expr><literal type="number">6</literal></expr></init></decl> }</block>;</enum>
    <enum><specifier>public</specifier> enum <name>MaskingOffsetMode</name> <block>{ <decl><name>Percentage</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><name>Pixel</name> <init>= <expr><literal type="number">1</literal></expr></init></decl> }</block>;</enum>
    <enum><specifier>public</specifier> enum <name>TextureMappingOptions</name> <block>{ <decl><name>Character</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><name>Line</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>, <decl><name>Paragraph</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>, <decl><name>MatchAspect</name> <init>= <expr><literal type="number">3</literal></expr></init></decl> }</block>;</enum>

    <enum><specifier>public</specifier> enum <name>FontStyles</name> <block>{ <decl><name>Normal</name> <init>= <expr><literal type="number">0x0</literal></expr></init></decl>, <decl><name>Bold</name> <init>= <expr><literal type="number">0x1</literal></expr></init></decl>, <decl><name>Italic</name> <init>= <expr><literal type="number">0x2</literal></expr></init></decl>, <decl><name>Underline</name> <init>= <expr><literal type="number">0x4</literal></expr></init></decl>, <decl><name>LowerCase</name> <init>= <expr><literal type="number">0x8</literal></expr></init></decl>, <decl><name>UpperCase</name> <init>= <expr><literal type="number">0x10</literal></expr></init></decl>, <decl><name>SmallCaps</name> <init>= <expr><literal type="number">0x20</literal></expr></init></decl>, <decl><name>Strikethrough</name> <init>= <expr><literal type="number">0x40</literal></expr></init></decl>, <decl><name>Superscript</name> <init>= <expr><literal type="number">0x80</literal></expr></init></decl>, <decl><name>Subscript</name> <init>= <expr><literal type="number">0x100</literal></expr></init></decl>, <decl><name>Highlight</name> <init>= <expr><literal type="number">0x200</literal></expr></init></decl> }</block>;</enum>
    <enum><specifier>public</specifier> enum <name>FontWeights</name> <block>{ <decl><name>Thin</name> <init>= <expr><literal type="number">100</literal></expr></init></decl>, <decl><name>ExtraLight</name> <init>= <expr><literal type="number">200</literal></expr></init></decl>, <decl><name>Light</name> <init>= <expr><literal type="number">300</literal></expr></init></decl>, <decl><name>Normal</name> <init>= <expr><literal type="number">400</literal></expr></init></decl>, <decl><name>Medium</name> <init>= <expr><literal type="number">500</literal></expr></init></decl>, <decl><name>SemiBold</name> <init>= <expr><literal type="number">600</literal></expr></init></decl>, <decl><name>Bold</name> <init>= <expr><literal type="number">700</literal></expr></init></decl>, <decl><name>Heavy</name> <init>= <expr><literal type="number">800</literal></expr></init></decl>, <decl><name>Black</name> <init>= <expr><literal type="number">900</literal></expr></init></decl> }</block>;</enum>

    <enum><specifier>public</specifier> enum <name>TagUnits</name> <block>{ <decl><name>Pixels</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><name>FontUnits</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>, <decl><name>Percentage</name> <init>= <expr><literal type="number">2</literal></expr></init></decl> }</block>;</enum>
    <enum><specifier>public</specifier> enum <name>TagType</name> <block>{ <decl><name>None</name> <init>= <expr><literal type="number">0x0</literal></expr></init></decl>, <decl><name>NumericalValue</name> <init>= <expr><literal type="number">0x1</literal></expr></init></decl>, <decl><name>StringValue</name> <init>= <expr><literal type="number">0x2</literal></expr></init></decl>, <decl><name>ColorValue</name> <init>= <expr><literal type="number">0x4</literal></expr></init></decl> }</block>;</enum>


    <comment type="line">/// &lt;summary&gt;</comment>
    <comment type="line">/// Base class which contains common properties and functions shared between the TextMeshPro and TextMeshProUGUI component.</comment>
    <comment type="line">/// &lt;/summary&gt;</comment>
    <class><specifier>public</specifier> <specifier>abstract</specifier> class <name>TMP_Text</name> <super>: <name>MaskableGraphic</name></super>
    <block>{
        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// A string containing the text to be displayed.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <property><specifier>public</specifier> <type><name>string</name></type> <name>text</name>
        <block>{
            <function><name>get</name> <block>{ <return>return <expr><name>m_text</name></expr>;</return> }</block></function>
            <function><name>set</name> <block>{ <if>if <condition>(<expr><name>m_text</name> <operator>==</operator> <name>value</name></expr>)</condition><then> <block type="pseudo"><return>return;</return></block></then></if> <expr_stmt><expr><name>m_text</name> <operator>=</operator> <name>old_text</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt> <expr_stmt><expr><name>m_inputSource</name> <operator>=</operator> <name><name>TextInputSources</name><operator>.</operator><name>String</name></name></expr>;</expr_stmt> <expr_stmt><expr><name>m_havePropertiesChanged</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt> <expr_stmt><expr><name>m_isCalculateSizeRequired</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt> <expr_stmt><expr><name>m_isInputParsingRequired</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt> <expr_stmt><expr><call><name>SetVerticesDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>SetLayoutDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt> }</block></function>
        }</block></property>
        <decl_stmt><decl><attribute>[<expr><name>SerializeField</name></expr>]</attribute>
        <attribute>[<expr><call><name>TextArea</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>]</attribute>
        <specifier>protected</specifier> <type><name>string</name></type> <name>m_text</name></decl>;</decl_stmt>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// </comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <property><specifier>public</specifier> <type><name>bool</name></type> <name>isRightToLeftText</name>
        <block>{
            <function><name>get</name> <block>{ <return>return <expr><name>m_isRightToLeft</name></expr>;</return> }</block></function>
            <function><name>set</name> <block>{ <if>if <condition>(<expr><name>m_isRightToLeft</name> <operator>==</operator> <name>value</name></expr>)</condition><then> <block type="pseudo"><return>return;</return></block></then></if> <expr_stmt><expr><name>m_isRightToLeft</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt> <expr_stmt><expr><name>m_havePropertiesChanged</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt> <expr_stmt><expr><name>m_isCalculateSizeRequired</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt> <expr_stmt><expr><name>m_isInputParsingRequired</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt> <expr_stmt><expr><call><name>SetVerticesDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>SetLayoutDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt> }</block></function>
        }</block></property>
        <decl_stmt><decl><attribute>[<expr><name>SerializeField</name></expr>]</attribute>
        <specifier>protected</specifier> <type><name>bool</name></type> <name>m_isRightToLeft</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// The Font Asset to be assigned to this text object.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <property><specifier>public</specifier> <type><name>TMP_FontAsset</name></type> <name>font</name>
        <block>{
            <function><name>get</name> <block>{ <return>return <expr><name>m_fontAsset</name></expr>;</return> }</block></function>
            <function><name>set</name> <block>{ <if>if <condition>(<expr><name>m_fontAsset</name> <operator>==</operator> <name>value</name></expr>)</condition><then> <block type="pseudo"><return>return;</return></block></then></if> <expr_stmt><expr><name>m_fontAsset</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt> <expr_stmt><expr><call><name>LoadFontAsset</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>m_havePropertiesChanged</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt> <expr_stmt><expr><name>m_isCalculateSizeRequired</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt> <expr_stmt><expr><name>m_isInputParsingRequired</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt> <expr_stmt><expr><call><name>SetVerticesDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>SetLayoutDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt> }</block></function>
        }</block></property>
        <decl_stmt><decl><attribute>[<expr><name>SerializeField</name></expr>]</attribute>
        <specifier>protected</specifier> <type><name>TMP_FontAsset</name></type> <name>m_fontAsset</name></decl>;</decl_stmt>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>TMP_FontAsset</name></type> <name>m_currentFontAsset</name></decl>;</decl_stmt>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>bool</name></type> <name>m_isSDFShader</name></decl>;</decl_stmt>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// The material to be assigned to this text object.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <property><specifier>public</specifier> <specifier>virtual</specifier> <type><name>Material</name></type> <name>fontSharedMaterial</name>
        <block>{
            <function><name>get</name> <block>{ <return>return <expr><name>m_sharedMaterial</name></expr>;</return> }</block></function>
            <function><name>set</name> <block>{ <if>if <condition>(<expr><name>m_sharedMaterial</name> <operator>==</operator> <name>value</name></expr>)</condition><then> <block type="pseudo"><return>return;</return></block></then></if> <expr_stmt><expr><call><name>SetSharedMaterial</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>m_havePropertiesChanged</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt> <expr_stmt><expr><name>m_isInputParsingRequired</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt> <expr_stmt><expr><call><name>SetVerticesDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>SetMaterialDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt> }</block></function>
        }</block></property>
        <decl_stmt><decl><attribute>[<expr><name>SerializeField</name></expr>]</attribute>
        <specifier>protected</specifier> <type><name>Material</name></type> <name>m_sharedMaterial</name></decl>;</decl_stmt>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>Material</name></type> <name>m_currentMaterial</name></decl>;</decl_stmt>
        <decl_stmt><decl><specifier>protected</specifier> <type><name><name>MaterialReference</name><index>[]</index></name></type> <name>m_materialReferences</name> <init>= <expr><operator>new</operator> <name><name>MaterialReference</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><specifier>protected</specifier> <type><name><name>Dictionary</name><argument_list type="generic">&lt;<argument><name>int</name></argument>, <argument><name>int</name></argument>&gt;</argument_list></name></type> <name>m_materialReferenceIndexLookup</name> <init>= <expr><operator>new</operator> <call><name><name>Dictionary</name><argument_list type="generic">&lt;<argument><name>int</name></argument>, <argument><name>int</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><specifier>protected</specifier> <type><name><name>TMP_XmlTagStack</name><argument_list type="generic">&lt;<argument><name>MaterialReference</name></argument>&gt;</argument_list></name></type> <name>m_materialReferenceStack</name> <init>= <expr><operator>new</operator> <call><name><name>TMP_XmlTagStack</name><argument_list type="generic">&lt;<argument><name>MaterialReference</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>new</operator> <name><name>MaterialReference</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>int</name></type> <name>m_currentMaterialIndex</name></decl>;</decl_stmt>
        <comment type="line">//protected int m_sharedMaterialHashCode;</comment>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// An array containing the materials used by the text object.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <property><specifier>public</specifier> <specifier>virtual</specifier> <type><name><name>Material</name><index>[]</index></name></type> <name>fontSharedMaterials</name>
        <block>{
            <function><name>get</name> <block>{ <return>return <expr><call><name>GetSharedMaterials</name><argument_list>()</argument_list></call></expr>;</return> }</block></function>
            <function><name>set</name> <block>{ <expr_stmt><expr><call><name>SetSharedMaterials</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>m_havePropertiesChanged</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt> <expr_stmt><expr><name>m_isInputParsingRequired</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt> <expr_stmt><expr><call><name>SetVerticesDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>SetMaterialDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt> }</block></function>
        }</block></property>
        <decl_stmt><decl><attribute>[<expr><name>SerializeField</name></expr>]</attribute>
        <specifier>protected</specifier> <type><name><name>Material</name><index>[]</index></name></type> <name>m_fontSharedMaterials</name></decl>;</decl_stmt>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// The material to be assigned to this text object. An instance of the material will be assigned to the object's renderer.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <property><specifier>public</specifier> <type><name>Material</name></type> <name>fontMaterial</name>
        <block>{
            <comment type="line">// Return an Instance of the current material.</comment>
            <function><name>get</name> <block>{ <return>return <expr><call><name>GetMaterial</name><argument_list>(<argument><expr><name>m_sharedMaterial</name></expr></argument>)</argument_list></call></expr>;</return> }</block></function>

            <comment type="line">// Assign new font material</comment>
            <function><name>set</name>
            <block>{
                <if>if <condition>(<expr><name>m_sharedMaterial</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <call><name><name>m_sharedMaterial</name><operator>.</operator><name>GetInstanceID</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>value</name><operator>.</operator><name>GetInstanceID</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <block type="pseudo"><return>return;</return></block></then></if>

                <expr_stmt><expr><name>m_sharedMaterial</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>

                <expr_stmt><expr><name>m_padding</name> <operator>=</operator> <call><name>GetPaddingForMaterial</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>m_havePropertiesChanged</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>m_isInputParsingRequired</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>SetVerticesDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>SetMaterialDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></function>
        }</block></property>
        <decl_stmt><decl><attribute>[<expr><name>SerializeField</name></expr>]</attribute>
        <specifier>protected</specifier> <type><name>Material</name></type> <name>m_fontMaterial</name></decl>;</decl_stmt>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// The materials to be assigned to this text object. An instance of the materials will be assigned.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <property><specifier>public</specifier> <specifier>virtual</specifier> <type><name><name>Material</name><index>[]</index></name></type> <name>fontMaterials</name>
        <block>{
            <function><name>get</name> <block>{ <return>return <expr><call><name>GetMaterials</name><argument_list>(<argument><expr><name>m_fontSharedMaterials</name></expr></argument>)</argument_list></call></expr>;</return> }</block></function>

            <function><name>set</name> <block>{ <expr_stmt><expr><call><name>SetSharedMaterials</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>m_havePropertiesChanged</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt> <expr_stmt><expr><name>m_isInputParsingRequired</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt> <expr_stmt><expr><call><name>SetVerticesDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>SetMaterialDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt> }</block></function>
        }</block></property>
        <decl_stmt><decl><attribute>[<expr><name>SerializeField</name></expr>]</attribute>
        <specifier>protected</specifier> <type><name><name>Material</name><index>[]</index></name></type> <name>m_fontMaterials</name></decl>;</decl_stmt>

        <decl_stmt><decl><specifier>protected</specifier> <type><name>bool</name></type> <name>m_isMaterialDirty</name></decl>;</decl_stmt>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// This is the default vertex color assigned to each vertices. Color tags will override vertex colors unless the overrideColorTags is set.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <property><specifier>public</specifier> <specifier>override</specifier> <type><name>Color</name></type> <name>color</name>
        <block>{
            <function><name>get</name> <block>{ <return>return <expr><name>m_fontColor</name></expr>;</return> }</block></function>
            <function><name>set</name> <block>{ <if>if <condition>(<expr><name>m_fontColor</name> <operator>==</operator> <name>value</name></expr>)</condition><then> <block type="pseudo"><return>return;</return></block></then></if> <expr_stmt><expr><name>m_havePropertiesChanged</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt> <expr_stmt><expr><name>m_fontColor</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt> <expr_stmt><expr><call><name>SetVerticesDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt> }</block></function>
        }</block></property>
        <comment type="line">//[UnityEngine.Serialization.FormerlySerializedAs("m_fontColor")] // Required for backwards compatibility with pre-Unity 4.6 releases.</comment>
        <decl_stmt><decl><attribute>[<expr><name>SerializeField</name></expr>]</attribute>
        <specifier>protected</specifier> <type><name>Color32</name></type> <name>m_fontColor32</name> <init>= <expr><name><name>Color</name><operator>.</operator><name>white</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><attribute>[<expr><name>SerializeField</name></expr>]</attribute>
        <specifier>protected</specifier> <type><name>Color</name></type> <name>m_fontColor</name> <init>= <expr><name><name>Color</name><operator>.</operator><name>white</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><specifier>protected</specifier> <specifier>static</specifier> <type><name>Color32</name></type> <name>s_colorWhite</name> <init>= <expr><operator>new</operator> <call><name>Color32</name><argument_list>(<argument><expr><literal type="number">255</literal></expr></argument>, <argument><expr><literal type="number">255</literal></expr></argument>, <argument><expr><literal type="number">255</literal></expr></argument>, <argument><expr><literal type="number">255</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>Color32</name></type> <name>m_underlineColor</name> <init>= <expr><name>s_colorWhite</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>Color32</name></type> <name>m_strikethroughColor</name> <init>= <expr><name>s_colorWhite</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>Color32</name></type> <name>m_highlightColor</name> <init>= <expr><name>s_colorWhite</name></expr></init></decl>;</decl_stmt>
        

        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Sets the vertex color alpha value.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <property><specifier>public</specifier> <type><name>float</name></type> <name>alpha</name>
        <block>{
            <function><name>get</name> <block>{ <return>return <expr><name><name>m_fontColor</name><operator>.</operator><name>a</name></name></expr>;</return> }</block></function>
            <function><name>set</name> <block>{ <if>if <condition>(<expr><name><name>m_fontColor</name><operator>.</operator><name>a</name></name> <operator>==</operator> <name>value</name></expr>)</condition><then> <block type="pseudo"><return>return;</return></block></then></if> <expr_stmt><expr><name><name>m_fontColor</name><operator>.</operator><name>a</name></name> <operator>=</operator> <name>value</name></expr>;</expr_stmt> <expr_stmt><expr><name>m_havePropertiesChanged</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt> <expr_stmt><expr><call><name>SetVerticesDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt> }</block></function>
        }</block></property>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Determines if Vertex Color Gradient should be used</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;value&gt;&lt;c&gt;true&lt;/c&gt; if enable vertex gradient; otherwise, &lt;c&gt;false&lt;/c&gt;.&lt;/value&gt;</comment>
        <property><specifier>public</specifier> <type><name>bool</name></type> <name>enableVertexGradient</name>
        <block>{
            <function><name>get</name> <block>{ <return>return <expr><name>m_enableVertexGradient</name></expr>;</return> }</block></function>
            <function><name>set</name> <block>{ <if>if <condition>(<expr><name>m_enableVertexGradient</name> <operator>==</operator> <name>value</name></expr>)</condition><then> <block type="pseudo"><return>return;</return></block></then></if> <expr_stmt><expr><name>m_havePropertiesChanged</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt> <expr_stmt><expr><name>m_enableVertexGradient</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt> <expr_stmt><expr><call><name>SetVerticesDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt> }</block></function>
        }</block></property>
        <decl_stmt><decl><attribute>[<expr><name>SerializeField</name></expr>]</attribute>
        <specifier>protected</specifier> <type><name>bool</name></type> <name>m_enableVertexGradient</name></decl>;</decl_stmt>

        <decl_stmt><decl><attribute>[<expr><name>SerializeField</name></expr>]</attribute>
        <specifier>protected</specifier> <type><name>ColorMode</name></type> <name>m_colorMode</name> <init>= <expr><name><name>ColorMode</name><operator>.</operator><name>FourCornersGradient</name></name></expr></init></decl>;</decl_stmt>
        
        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Sets the vertex colors for each of the 4 vertices of the character quads.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;value&gt;The color gradient.&lt;/value&gt;</comment>
        <property><specifier>public</specifier> <type><name>VertexGradient</name></type> <name>colorGradient</name>
        <block>{
            <function><name>get</name> <block>{ <return>return <expr><name>m_fontColorGradient</name></expr>;</return> }</block></function>
            <function><name>set</name> <block>{ <expr_stmt><expr><name>m_havePropertiesChanged</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt> <expr_stmt><expr><name>m_fontColorGradient</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt> <expr_stmt><expr><call><name>SetVerticesDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt> }</block></function>
        }</block></property>
        <decl_stmt><decl><attribute>[<expr><name>SerializeField</name></expr>]</attribute>
        <specifier>protected</specifier> <type><name>VertexGradient</name></type> <name>m_fontColorGradient</name> <init>= <expr><operator>new</operator> <call><name>VertexGradient</name><argument_list>(<argument><expr><name><name>Color</name><operator>.</operator><name>white</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Set the vertex colors of the 4 vertices of each character quads.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <property><specifier>public</specifier> <type><name>TMP_ColorGradient</name></type> <name>colorGradientPreset</name>
        <block>{
            <function><name>get</name> <block>{ <return>return <expr><name>m_fontColorGradientPreset</name></expr>;</return> }</block></function>
            <function><name>set</name> <block>{ <expr_stmt><expr><name>m_havePropertiesChanged</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt> <expr_stmt><expr><name>m_fontColorGradientPreset</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt> <expr_stmt><expr><call><name>SetVerticesDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt> }</block></function>
        }</block></property>
        <decl_stmt><decl><attribute>[<expr><name>SerializeField</name></expr>]</attribute>
        <specifier>protected</specifier> <type><name>TMP_ColorGradient</name></type> <name>m_fontColorGradientPreset</name></decl>;</decl_stmt>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Default Sprite Asset used by the text object.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <property><specifier>public</specifier> <type><name>TMP_SpriteAsset</name></type> <name>spriteAsset</name>
        <block>{
            <function><name>get</name> <block>{ <return>return <expr><name>m_spriteAsset</name></expr>;</return> }</block></function>
            <function><name>set</name> <block>{ <expr_stmt><expr><name>m_spriteAsset</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt> <expr_stmt><expr><name>m_havePropertiesChanged</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt> <expr_stmt><expr><name>m_isInputParsingRequired</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt> <expr_stmt><expr><name>m_isCalculateSizeRequired</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt> <expr_stmt><expr><call><name>SetVerticesDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>SetLayoutDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt> }</block></function>
        }</block></property>
        <decl_stmt><decl><attribute>[<expr><name>SerializeField</name></expr>]</attribute>
        <specifier>protected</specifier> <type><name>TMP_SpriteAsset</name></type> <name>m_spriteAsset</name></decl>;</decl_stmt>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Determines whether or not the sprite color is multiplies by the vertex color of the text.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <property><specifier>public</specifier> <type><name>bool</name></type> <name>tintAllSprites</name>
        <block>{
            <function><name>get</name> <block>{ <return>return <expr><name>m_tintAllSprites</name></expr>;</return> }</block></function>
            <function><name>set</name> <block>{ <if>if <condition>(<expr><name>m_tintAllSprites</name> <operator>==</operator> <name>value</name></expr>)</condition><then> <block type="pseudo"><return>return;</return></block></then></if> <expr_stmt><expr><name>m_tintAllSprites</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt> <expr_stmt><expr><name>m_havePropertiesChanged</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt> <expr_stmt><expr><call><name>SetVerticesDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt> }</block></function>
        }</block></property>
        <decl_stmt><decl><attribute>[<expr><name>SerializeField</name></expr>]</attribute>
        <specifier>protected</specifier> <type><name>bool</name></type> <name>m_tintAllSprites</name></decl>;</decl_stmt>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>bool</name></type> <name>m_tintSprite</name></decl>;</decl_stmt>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>Color32</name></type> <name>m_spriteColor</name></decl>;</decl_stmt>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// This overrides the color tags forcing the vertex colors to be the default font color.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <property><specifier>public</specifier> <type><name>bool</name></type> <name>overrideColorTags</name>
        <block>{
            <function><name>get</name> <block>{ <return>return <expr><name>m_overrideHtmlColors</name></expr>;</return> }</block></function>
            <function><name>set</name> <block>{ <if>if <condition>(<expr><name>m_overrideHtmlColors</name> <operator>==</operator> <name>value</name></expr>)</condition><then> <block type="pseudo"><return>return;</return></block></then></if> <expr_stmt><expr><name>m_havePropertiesChanged</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt> <expr_stmt><expr><name>m_overrideHtmlColors</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt> <expr_stmt><expr><call><name>SetVerticesDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt> }</block></function>
        }</block></property>
        <decl_stmt><decl><attribute>[<expr><name>SerializeField</name></expr>]</attribute>
        <specifier>protected</specifier> <type><name>bool</name></type> <name>m_overrideHtmlColors</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Sets the color of the _FaceColor property of the assigned material. Changing face color will result in an instance of the material.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <property><specifier>public</specifier> <type><name>Color32</name></type> <name>faceColor</name>
        <block>{
            <function><name>get</name>
            <block>{
                <if>if <condition>(<expr><name>m_sharedMaterial</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block type="pseudo"><return>return <expr><name>m_faceColor</name></expr>;</return></block></then></if>

                <expr_stmt><expr><name>m_faceColor</name> <operator>=</operator> <call><name><name>m_sharedMaterial</name><operator>.</operator><name>GetColor</name></name><argument_list>(<argument><expr><name><name>ShaderUtilities</name><operator>.</operator><name>ID_FaceColor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>m_faceColor</name></expr>;</return>
            }</block></function>

            <function><name>set</name> <block>{ <if>if <condition>(<expr><call><name><name>m_faceColor</name><operator>.</operator><name>Compare</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block type="pseudo"><return>return;</return></block></then></if> <expr_stmt><expr><call><name>SetFaceColor</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>m_havePropertiesChanged</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt> <expr_stmt><expr><name>m_faceColor</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt> <expr_stmt><expr><call><name>SetVerticesDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>SetMaterialDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt> }</block></function>
        }</block></property>
        <decl_stmt><decl><attribute>[<expr><name>SerializeField</name></expr>]</attribute>
        <specifier>protected</specifier> <type><name>Color32</name></type> <name>m_faceColor</name> <init>= <expr><name><name>Color</name><operator>.</operator><name>white</name></name></expr></init></decl>;</decl_stmt>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Sets the color of the _OutlineColor property of the assigned material. Changing outline color will result in an instance of the material.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <property><specifier>public</specifier> <type><name>Color32</name></type> <name>outlineColor</name>
        <block>{
            <function><name>get</name>
            <block>{
                <if>if <condition>(<expr><name>m_sharedMaterial</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block type="pseudo"><return>return <expr><name>m_outlineColor</name></expr>;</return></block></then></if>

                <expr_stmt><expr><name>m_outlineColor</name> <operator>=</operator> <call><name><name>m_sharedMaterial</name><operator>.</operator><name>GetColor</name></name><argument_list>(<argument><expr><name><name>ShaderUtilities</name><operator>.</operator><name>ID_OutlineColor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>m_outlineColor</name></expr>;</return>
            }</block></function>

            <function><name>set</name> <block>{ <if>if <condition>(<expr><call><name><name>m_outlineColor</name><operator>.</operator><name>Compare</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block type="pseudo"><return>return;</return></block></then></if> <expr_stmt><expr><call><name>SetOutlineColor</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>m_havePropertiesChanged</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt> <expr_stmt><expr><name>m_outlineColor</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt> <expr_stmt><expr><call><name>SetVerticesDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt> }</block></function>
        }</block></property>
        <decl_stmt><decl><attribute>[<expr><name>SerializeField</name></expr>]</attribute>
        <specifier>protected</specifier> <type><name>Color32</name></type> <name>m_outlineColor</name> <init>= <expr><name><name>Color</name><operator>.</operator><name>black</name></name></expr></init></decl>;</decl_stmt>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Sets the thickness of the outline of the font. Setting this value will result in an instance of the material.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <property><specifier>public</specifier> <type><name>float</name></type> <name>outlineWidth</name>
        <block>{
            <function><name>get</name>
            <block>{
                <if>if <condition>(<expr><name>m_sharedMaterial</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block type="pseudo"><return>return <expr><name>m_outlineWidth</name></expr>;</return></block></then></if>

                <expr_stmt><expr><name>m_outlineWidth</name> <operator>=</operator> <call><name><name>m_sharedMaterial</name><operator>.</operator><name>GetFloat</name></name><argument_list>(<argument><expr><name><name>ShaderUtilities</name><operator>.</operator><name>ID_OutlineWidth</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>m_outlineWidth</name></expr>;</return>
            }</block></function>
            <function><name>set</name> <block>{ <if>if <condition>(<expr><name>m_outlineWidth</name> <operator>==</operator> <name>value</name></expr>)</condition><then> <block type="pseudo"><return>return;</return></block></then></if> <expr_stmt><expr><call><name>SetOutlineThickness</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>m_havePropertiesChanged</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt> <expr_stmt><expr><name>m_outlineWidth</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt> <expr_stmt><expr><call><name>SetVerticesDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt> }</block></function>
        }</block></property>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>float</name></type> <name>m_outlineWidth</name> <init>= <expr><literal type="number">0.0f</literal></expr></init></decl>;</decl_stmt>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// The point size of the font.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <property><specifier>public</specifier> <type><name>float</name></type> <name>fontSize</name>
        <block>{
            <function><name>get</name> <block>{ <return>return <expr><name>m_fontSize</name></expr>;</return> }</block></function>
            <function><name>set</name> <block>{ <if>if <condition>(<expr><name>m_fontSize</name> <operator>==</operator> <name>value</name></expr>)</condition><then> <block type="pseudo"><return>return;</return></block></then></if> <expr_stmt><expr><name>m_havePropertiesChanged</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt> <expr_stmt><expr><name>m_isCalculateSizeRequired</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt> <expr_stmt><expr><name>m_fontSize</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt> <if>if <condition>(<expr><operator>!</operator><name>m_enableAutoSizing</name></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><name>m_fontSizeBase</name> <operator>=</operator> <name>m_fontSize</name></expr>;</expr_stmt></block></then></if> <expr_stmt><expr><call><name>SetVerticesDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>SetLayoutDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt> }</block></function>
        }</block></property>
        <decl_stmt><decl><attribute>[<expr><name>SerializeField</name></expr>]</attribute>
        <specifier>protected</specifier> <type><name>float</name></type> <name>m_fontSize</name> <init>= <expr><literal type="number">36</literal></expr></init></decl>;</decl_stmt> <comment type="line">// Font Size</comment>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>float</name></type> <name>m_currentFontSize</name></decl>;</decl_stmt> <comment type="line">// Temporary Font Size affected by tags</comment>
        <decl_stmt><decl><attribute>[<expr><name>SerializeField</name></expr>]</attribute>
        <specifier>protected</specifier> <type><name>float</name></type> <name>m_fontSizeBase</name> <init>= <expr><literal type="number">36</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><specifier>protected</specifier> <type><name><name>TMP_XmlTagStack</name><argument_list type="generic">&lt;<argument><name>float</name></argument>&gt;</argument_list></name></type> <name>m_sizeStack</name> <init>= <expr><operator>new</operator> <call><name><name>TMP_XmlTagStack</name><argument_list type="generic">&lt;<argument><name>float</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>new</operator> <name><name>float</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// The scale of the current text.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <property><specifier>public</specifier> <type><name>float</name></type> <name>fontScale</name>
        <block>{
            <function><name>get</name> <block>{ <return>return <expr><name>m_fontScale</name></expr>;</return> }</block></function>
        }</block></property>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Control the weight of the font if an alternative font asset is assigned for the given weight in the font asset editor.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <property><specifier>public</specifier> <type><name>int</name></type> <name>fontWeight</name>
        <block>{
            <function><name>get</name> <block>{ <return>return <expr><name>m_fontWeight</name></expr>;</return> }</block></function>
            <function><name>set</name> <block>{ <if>if <condition>(<expr><name>m_fontWeight</name> <operator>==</operator> <name>value</name></expr>)</condition><then> <block type="pseudo"><return>return;</return></block></then></if> <expr_stmt><expr><name>m_fontWeight</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt> <expr_stmt><expr><name>m_havePropertiesChanged</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt> <expr_stmt><expr><name>m_isCalculateSizeRequired</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt> <expr_stmt><expr><name>m_isInputParsingRequired</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt> <expr_stmt><expr><call><name>SetVerticesDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>SetLayoutDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt> }</block></function>
        }</block></property>
        <decl_stmt><decl><attribute>[<expr><name>SerializeField</name></expr>]</attribute>
        <specifier>protected</specifier> <type><name>int</name></type> <name>m_fontWeight</name> <init>= <expr><literal type="number">400</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>int</name></type> <name>m_fontWeightInternal</name></decl>;</decl_stmt>
        <decl_stmt><decl><specifier>protected</specifier> <type><name><name>TMP_XmlTagStack</name><argument_list type="generic">&lt;<argument><name>int</name></argument>&gt;</argument_list></name></type> <name>m_fontWeightStack</name> <init>= <expr><operator>new</operator> <call><name><name>TMP_XmlTagStack</name><argument_list type="generic">&lt;<argument><name>int</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>new</operator> <name><name>int</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// </comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <property><specifier>public</specifier> <type><name>float</name></type> <name>pixelsPerUnit</name>
        <block>{
            <function><name>get</name>
            <block>{
                <decl_stmt><decl><type><name>var</name></type> <name>localCanvas</name> <init>= <expr><name>canvas</name></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><operator>!</operator><name>localCanvas</name></expr>)</condition><then>
                    <block type="pseudo"><return>return <expr><literal type="number">1</literal></expr>;</return></block></then></if>
                <comment type="line">// For dynamic fonts, ensure we use one pixel per pixel on the screen.</comment>
                <if>if <condition>(<expr><operator>!</operator><name>font</name></expr>)</condition><then>
                    <block type="pseudo"><return>return <expr><name><name>localCanvas</name><operator>.</operator><name>scaleFactor</name></name></expr>;</return></block></then></if>
                <comment type="line">// For non-dynamic fonts, calculate pixels per unit based on specified font size relative to font object's own font size.</comment>
                <if>if <condition>(<expr><name>m_currentFontAsset</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name><name>m_currentFontAsset</name><operator>.</operator><name>fontInfo</name><operator>.</operator><name>PointSize</name></name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>m_fontSize</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><then>
                    <block type="pseudo"><return>return <expr><literal type="number">1</literal></expr>;</return></block></then></if>
                <return>return <expr><name>m_fontSize</name> <operator>/</operator> <name><name>m_currentFontAsset</name><operator>.</operator><name>fontInfo</name><operator>.</operator><name>PointSize</name></name></expr>;</return>
            }</block></function>
        }</block></property>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Enable text auto-sizing</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <property><specifier>public</specifier> <type><name>bool</name></type> <name>enableAutoSizing</name>
        <block>{
            <function><name>get</name> <block>{ <return>return <expr><name>m_enableAutoSizing</name></expr>;</return> }</block></function>
            <function><name>set</name> <block>{ <if>if <condition>(<expr><name>m_enableAutoSizing</name> <operator>==</operator> <name>value</name></expr>)</condition><then> <block type="pseudo"><return>return;</return></block></then></if> <expr_stmt><expr><name>m_enableAutoSizing</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt> <expr_stmt><expr><call><name>SetVerticesDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>SetLayoutDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt> }</block></function>
        }</block></property>
        <decl_stmt><decl><attribute>[<expr><name>SerializeField</name></expr>]</attribute>
        <specifier>protected</specifier> <type><name>bool</name></type> <name>m_enableAutoSizing</name></decl>;</decl_stmt>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>float</name></type> <name>m_maxFontSize</name></decl>;</decl_stmt> <comment type="line">// Used in conjunction with auto-sizing</comment>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>float</name></type> <name>m_minFontSize</name></decl>;</decl_stmt> <comment type="line">// Used in conjunction with auto-sizing</comment>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Minimum point size of the font when text auto-sizing is enabled.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <property><specifier>public</specifier> <type><name>float</name></type> <name>fontSizeMin</name>
        <block>{
            <function><name>get</name> <block>{ <return>return <expr><name>m_fontSizeMin</name></expr>;</return> }</block></function>
            <function><name>set</name> <block>{ <if>if <condition>(<expr><name>m_fontSizeMin</name> <operator>==</operator> <name>value</name></expr>)</condition><then> <block type="pseudo"><return>return;</return></block></then></if> <expr_stmt><expr><name>m_fontSizeMin</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt> <expr_stmt><expr><call><name>SetVerticesDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>SetLayoutDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt> }</block></function>
        }</block></property>
        <decl_stmt><decl><attribute>[<expr><name>SerializeField</name></expr>]</attribute>
        <specifier>protected</specifier> <type><name>float</name></type> <name>m_fontSizeMin</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="line">// Text Auto Sizing Min Font Size.</comment>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Maximum point size of the font when text auto-sizing is enabled.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <property><specifier>public</specifier> <type><name>float</name></type> <name>fontSizeMax</name>
        <block>{
            <function><name>get</name> <block>{ <return>return <expr><name>m_fontSizeMax</name></expr>;</return> }</block></function>
            <function><name>set</name> <block>{ <if>if <condition>(<expr><name>m_fontSizeMax</name> <operator>==</operator> <name>value</name></expr>)</condition><then> <block type="pseudo"><return>return;</return></block></then></if> <expr_stmt><expr><name>m_fontSizeMax</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt> <expr_stmt><expr><call><name>SetVerticesDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>SetLayoutDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt> }</block></function>
        }</block></property>
        <decl_stmt><decl><attribute>[<expr><name>SerializeField</name></expr>]</attribute>
        <specifier>protected</specifier> <type><name>float</name></type> <name>m_fontSizeMax</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="line">// Text Auto Sizing Max Font Size.</comment>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// The style of the text</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <property><specifier>public</specifier> <type><name>FontStyles</name></type> <name>fontStyle</name>
        <block>{
            <function><name>get</name> <block>{ <return>return <expr><name>m_fontStyle</name></expr>;</return> }</block></function>
            <function><name>set</name> <block>{ <if>if <condition>(<expr><name>m_fontStyle</name> <operator>==</operator> <name>value</name></expr>)</condition><then> <block type="pseudo"><return>return;</return></block></then></if> <expr_stmt><expr><name>m_fontStyle</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt> <expr_stmt><expr><name>m_havePropertiesChanged</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt> <expr_stmt><expr><name>m_isCalculateSizeRequired</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt> <expr_stmt><expr><name>m_isInputParsingRequired</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt> <expr_stmt><expr><call><name>SetVerticesDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>SetLayoutDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt> }</block></function>
        }</block></property>
        <decl_stmt><decl><attribute>[<expr><name>SerializeField</name></expr>]</attribute>
        <specifier>protected</specifier> <type><name>FontStyles</name></type> <name>m_fontStyle</name> <init>= <expr><name><name>FontStyles</name><operator>.</operator><name>Normal</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>FontStyles</name></type> <name>m_style</name> <init>= <expr><name><name>FontStyles</name><operator>.</operator><name>Normal</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>TMP_BasicXmlTagStack</name></type> <name>m_fontStyleStack</name></decl>;</decl_stmt>

        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Property used in conjunction with padding calculation for the geometry.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <property><specifier>public</specifier> <type><name>bool</name></type> <name>isUsingBold</name> <block>{ <function><name>get</name> <block>{ <return>return <expr><name>m_isUsingBold</name></expr>;</return> }</block></function> }</block></property>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>bool</name></type> <name>m_isUsingBold</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt> <comment type="line">// Used to ensure GetPadding &amp; Ratios take into consideration bold characters.</comment>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Text alignment options</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <property><specifier>public</specifier> <type><name>TextAlignmentOptions</name></type> <name>alignment</name>
        <block>{
            <function><name>get</name> <block>{ <return>return <expr><name>m_textAlignment</name></expr>;</return> }</block></function>
            <function><name>set</name> <block>{ <if>if <condition>(<expr><name>m_textAlignment</name> <operator>==</operator> <name>value</name></expr>)</condition><then> <block type="pseudo"><return>return;</return></block></then></if> <expr_stmt><expr><name>m_havePropertiesChanged</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt> <expr_stmt><expr><name>m_textAlignment</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt> <expr_stmt><expr><call><name>SetVerticesDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt> }</block></function>
        }</block></property>
        <decl_stmt><decl><attribute>[<expr><name>SerializeField</name></expr>]</attribute>
        <attribute>[<expr><call><name><name>UnityEngine</name><operator>.</operator><name>Serialization</name><operator>.</operator><name>FormerlySerializedAs</name></name><argument_list>(<argument><expr><literal type="string">"m_lineJustification"</literal></expr></argument>)</argument_list></call></expr>]</attribute>
        <specifier>protected</specifier> <type><name>TextAlignmentOptions</name></type> <name>m_textAlignment</name> <init>= <expr><name><name>TextAlignmentOptions</name><operator>.</operator><name>TopLeft</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>TextAlignmentOptions</name></type> <name>m_lineJustification</name></decl>;</decl_stmt>
        <decl_stmt><decl><specifier>protected</specifier> <type><name><name>TMP_XmlTagStack</name><argument_list type="generic">&lt;<argument><name>TextAlignmentOptions</name></argument>&gt;</argument_list></name></type> <name>m_lineJustificationStack</name> <init>= <expr><operator>new</operator> <call><name><name>TMP_XmlTagStack</name><argument_list type="generic">&lt;<argument><name>TextAlignmentOptions</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>new</operator> <name><name>TextAlignmentOptions</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><specifier>protected</specifier> <type><name><name>Vector3</name><index>[]</index></name></type> <name>m_textContainerLocalCorners</name> <init>= <expr><operator>new</operator> <name><name>Vector3</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><attribute>[<expr><name>SerializeField</name></expr>]</attribute>
        <specifier>protected</specifier> <type><name>bool</name></type> <name>m_isAlignmentEnumConverted</name></decl>;</decl_stmt>

        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Use the extents of the text geometry for alignment instead of font metrics.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">//public bool alignByGeometry</comment>
        <comment type="line">//{</comment>
        <comment type="line">//    get { return m_alignByGeometry; }</comment>
        <comment type="line">//    set { if (m_alignByGeometry == value) return; m_havePropertiesChanged = true; m_alignByGeometry = value; SetVerticesDirty(); }</comment>
        <comment type="line">//}</comment>
        <comment type="line">//[SerializeField]</comment>
        <comment type="line">//protected bool m_alignByGeometry;</comment>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// The amount of additional spacing between characters.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <property><specifier>public</specifier> <type><name>float</name></type> <name>characterSpacing</name>
        <block>{
            <function><name>get</name> <block>{ <return>return <expr><name>m_characterSpacing</name></expr>;</return> }</block></function>
            <function><name>set</name> <block>{ <if>if <condition>(<expr><name>m_characterSpacing</name> <operator>==</operator> <name>value</name></expr>)</condition><then> <block type="pseudo"><return>return;</return></block></then></if> <expr_stmt><expr><name>m_havePropertiesChanged</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt> <expr_stmt><expr><name>m_isCalculateSizeRequired</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>  <expr_stmt><expr><name>m_characterSpacing</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt> <expr_stmt><expr><call><name>SetVerticesDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>SetLayoutDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt> }</block></function>
        }</block></property>
        <decl_stmt><decl><attribute>[<expr><name>SerializeField</name></expr>]</attribute>
        <specifier>protected</specifier> <type><name>float</name></type> <name>m_characterSpacing</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>float</name></type> <name>m_cSpacing</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>float</name></type> <name>m_monoSpacing</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// The amount of additional spacing between words.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <property><specifier>public</specifier> <type><name>float</name></type> <name>wordSpacing</name>
        <block>{
            <function><name>get</name> <block>{ <return>return <expr><name>m_wordSpacing</name></expr>;</return> }</block></function>
            <function><name>set</name> <block>{ <if>if <condition>(<expr><name>m_wordSpacing</name> <operator>==</operator> <name>value</name></expr>)</condition><then> <block type="pseudo"><return>return;</return></block></then></if> <expr_stmt><expr><name>m_havePropertiesChanged</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt> <expr_stmt><expr><name>m_isCalculateSizeRequired</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt> <expr_stmt><expr><name>m_wordSpacing</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt> <expr_stmt><expr><call><name>SetVerticesDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>SetLayoutDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt> }</block></function>
        }</block></property>
        <decl_stmt><decl><attribute>[<expr><name>SerializeField</name></expr>]</attribute>
        <specifier>protected</specifier> <type><name>float</name></type> <name>m_wordSpacing</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// The amount of additional spacing to add between each lines of text.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <property><specifier>public</specifier> <type><name>float</name></type> <name>lineSpacing</name>
        <block>{
            <function><name>get</name> <block>{ <return>return <expr><name>m_lineSpacing</name></expr>;</return> }</block></function>
            <function><name>set</name> <block>{ <if>if <condition>(<expr><name>m_lineSpacing</name> <operator>==</operator> <name>value</name></expr>)</condition><then> <block type="pseudo"><return>return;</return></block></then></if> <expr_stmt><expr><name>m_havePropertiesChanged</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt> <expr_stmt><expr><name>m_isCalculateSizeRequired</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt> <expr_stmt><expr><name>m_lineSpacing</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt> <expr_stmt><expr><call><name>SetVerticesDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>SetLayoutDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt> }</block></function>
        }</block></property>
        <decl_stmt><decl><attribute>[<expr><name>SerializeField</name></expr>]</attribute>
        <specifier>protected</specifier> <type><name>float</name></type> <name>m_lineSpacing</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>float</name></type> <name>m_lineSpacingDelta</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="line">// Used with Text Auto Sizing feature</comment>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>float</name></type> <name>m_lineHeight</name> <init>= <expr><name><name>TMP_Math</name><operator>.</operator><name>FLOAT_UNSET</name></name></expr></init></decl>;</decl_stmt> <comment type="line">// Used with the &lt;line-height=xx.x&gt; tag.</comment>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// The amount of potential line spacing adjustment before text auto sizing kicks in.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <property><specifier>public</specifier> <type><name>float</name></type> <name>lineSpacingAdjustment</name>
        <block>{
            <function><name>get</name> <block>{ <return>return <expr><name>m_lineSpacingMax</name></expr>;</return> }</block></function>
            <function><name>set</name> <block>{ <if>if <condition>(<expr><name>m_lineSpacingMax</name> <operator>==</operator> <name>value</name></expr>)</condition><then> <block type="pseudo"><return>return;</return></block></then></if> <expr_stmt><expr><name>m_havePropertiesChanged</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt> <expr_stmt><expr><name>m_isCalculateSizeRequired</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt> <expr_stmt><expr><name>m_lineSpacingMax</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt> <expr_stmt><expr><call><name>SetVerticesDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>SetLayoutDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt> }</block></function>
        }</block></property>
        <decl_stmt><decl><attribute>[<expr><name>SerializeField</name></expr>]</attribute>
        <specifier>protected</specifier> <type><name>float</name></type> <name>m_lineSpacingMax</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="line">// Text Auto Sizing Max Line spacing reduction.</comment>
        <comment type="line">//protected bool m_forceLineBreak;</comment>

        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// The amount of additional spacing to add between each lines of text.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <property><specifier>public</specifier> <type><name>float</name></type> <name>paragraphSpacing</name>
        <block>{
            <function><name>get</name> <block>{ <return>return <expr><name>m_paragraphSpacing</name></expr>;</return> }</block></function>
            <function><name>set</name> <block>{ <if>if <condition>(<expr><name>m_paragraphSpacing</name> <operator>==</operator> <name>value</name></expr>)</condition><then> <block type="pseudo"><return>return;</return></block></then></if> <expr_stmt><expr><name>m_havePropertiesChanged</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt> <expr_stmt><expr><name>m_isCalculateSizeRequired</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt> <expr_stmt><expr><name>m_paragraphSpacing</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt> <expr_stmt><expr><call><name>SetVerticesDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>SetLayoutDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt> }</block></function>
        }</block></property>
        <decl_stmt><decl><attribute>[<expr><name>SerializeField</name></expr>]</attribute>
        <specifier>protected</specifier> <type><name>float</name></type> <name>m_paragraphSpacing</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Percentage the width of characters can be adjusted before text auto-sizing begins to reduce the point size.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <property><specifier>public</specifier> <type><name>float</name></type> <name>characterWidthAdjustment</name>
        <block>{
            <function><name>get</name> <block>{ <return>return <expr><name>m_charWidthMaxAdj</name></expr>;</return> }</block></function>
            <function><name>set</name> <block>{ <if>if <condition>(<expr><name>m_charWidthMaxAdj</name> <operator>==</operator> <name>value</name></expr>)</condition><then> <block type="pseudo"><return>return;</return></block></then></if> <expr_stmt><expr><name>m_havePropertiesChanged</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt> <expr_stmt><expr><name>m_isCalculateSizeRequired</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt> <expr_stmt><expr><name>m_charWidthMaxAdj</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt> <expr_stmt><expr><call><name>SetVerticesDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>SetLayoutDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt> }</block></function>
        }</block></property>
        <decl_stmt><decl><attribute>[<expr><name>SerializeField</name></expr>]</attribute>
        <specifier>protected</specifier> <type><name>float</name></type> <name>m_charWidthMaxAdj</name> <init>= <expr><literal type="number">0f</literal></expr></init></decl>;</decl_stmt> <comment type="line">// Text Auto Sizing Max Character Width reduction.</comment>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>float</name></type> <name>m_charWidthAdjDelta</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Controls whether or not word wrapping is applied. When disabled, the text will be displayed on a single line.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <property><specifier>public</specifier> <type><name>bool</name></type> <name>enableWordWrapping</name>
        <block>{
            <function><name>get</name> <block>{ <return>return <expr><name>m_enableWordWrapping</name></expr>;</return> }</block></function>
            <function><name>set</name> <block>{ <if>if <condition>(<expr><name>m_enableWordWrapping</name> <operator>==</operator> <name>value</name></expr>)</condition><then> <block type="pseudo"><return>return;</return></block></then></if> <expr_stmt><expr><name>m_havePropertiesChanged</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt> <expr_stmt><expr><name>m_isInputParsingRequired</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt> <expr_stmt><expr><name>m_isCalculateSizeRequired</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt> <expr_stmt><expr><name>m_enableWordWrapping</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt> <expr_stmt><expr><call><name>SetVerticesDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>SetLayoutDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt> }</block></function>
        }</block></property>
        <decl_stmt><decl><attribute>[<expr><name>SerializeField</name></expr>]</attribute>
        <specifier>protected</specifier> <type><name>bool</name></type> <name>m_enableWordWrapping</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>bool</name></type> <name>m_isCharacterWrappingEnabled</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>bool</name></type> <name>m_isNonBreakingSpace</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>bool</name></type> <name>m_isIgnoringAlignment</name></decl>;</decl_stmt>

        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Controls the blending between using character and word spacing to fill-in the space for justified text.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <property><specifier>public</specifier> <type><name>float</name></type> <name>wordWrappingRatios</name>
        <block>{
            <function><name>get</name> <block>{ <return>return <expr><name>m_wordWrappingRatios</name></expr>;</return> }</block></function>
            <function><name>set</name> <block>{ <if>if <condition>(<expr><name>m_wordWrappingRatios</name> <operator>==</operator> <name>value</name></expr>)</condition><then> <block type="pseudo"><return>return;</return></block></then></if> <expr_stmt><expr><name>m_wordWrappingRatios</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt> <expr_stmt><expr><name>m_havePropertiesChanged</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt> <expr_stmt><expr><name>m_isCalculateSizeRequired</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt> <expr_stmt><expr><call><name>SetVerticesDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>SetLayoutDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt> }</block></function>
        }</block></property>
        <decl_stmt><decl><attribute>[<expr><name>SerializeField</name></expr>]</attribute>
        <specifier>protected</specifier> <type><name>float</name></type> <name>m_wordWrappingRatios</name> <init>= <expr><literal type="number">0.4f</literal></expr></init></decl>;</decl_stmt> <comment type="line">// Controls word wrapping ratios between word or characters.</comment>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// </comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">//public bool enableAdaptiveJustification</comment>
        <comment type="line">//{</comment>
        <comment type="line">//    get { return m_enableAdaptiveJustification; }</comment>
        <comment type="line">//    set { if (m_enableAdaptiveJustification == value) return;  m_enableAdaptiveJustification = value;  m_havePropertiesChanged = true;  m_isCalculateSizeRequired = true;  SetVerticesDirty(); SetLayoutDirty(); }</comment>
        <comment type="line">//}</comment>
        <comment type="line">//[SerializeField]</comment>
        <comment type="line">//protected bool m_enableAdaptiveJustification;</comment>
        <comment type="line">//protected float m_adaptiveJustificationThreshold = 10.0f;</comment>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Controls the Text Overflow Mode</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <property><specifier>public</specifier> <type><name>TextOverflowModes</name></type> <name>overflowMode</name>
        <block>{
            <function><name>get</name> <block>{ <return>return <expr><name>m_overflowMode</name></expr>;</return> }</block></function>
            <function><name>set</name> <block>{ <if>if <condition>(<expr><name>m_overflowMode</name> <operator>==</operator> <name>value</name></expr>)</condition><then> <block type="pseudo"><return>return;</return></block></then></if> <expr_stmt><expr><name>m_overflowMode</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt> <expr_stmt><expr><name>m_havePropertiesChanged</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt> <expr_stmt><expr><name>m_isCalculateSizeRequired</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt> <expr_stmt><expr><call><name>SetVerticesDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>SetLayoutDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt> }</block></function>
        }</block></property>
        <decl_stmt><decl><attribute>[<expr><name>SerializeField</name></expr>]</attribute>
        <specifier>protected</specifier> <type><name>TextOverflowModes</name></type> <name>m_overflowMode</name> <init>= <expr><name><name>TextOverflowModes</name><operator>.</operator><name>Overflow</name></name></expr></init></decl>;</decl_stmt>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Indicates if the text exceeds the vertical bounds of its text container.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <property><specifier>public</specifier> <type><name>bool</name></type> <name>isTextOverflowing</name>
        <block>{
            <function><name>get</name> <block>{ <if>if <condition>(<expr><name>m_firstOverflowCharacterIndex</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><then> <block type="pseudo"><return>return <expr><literal type="boolean">true</literal></expr>;</return></block></then></if> <return>return <expr><literal type="boolean">false</literal></expr>;</return> }</block></function>
        }</block></property>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// The first character which exceeds the vertical bounds of its text container.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <property><specifier>public</specifier> <type><name>int</name></type> <name>firstOverflowCharacterIndex</name>
        <block>{
            <function><name>get</name> <block>{ <return>return <expr><name>m_firstOverflowCharacterIndex</name></expr>;</return> }</block></function>
        }</block></property>
        <decl_stmt><decl><attribute>[<expr><name>SerializeField</name></expr>]</attribute>
        <specifier>protected</specifier> <type><name>int</name></type> <name>m_firstOverflowCharacterIndex</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// The linked text component used for flowing the text from one text component to another.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <property><specifier>public</specifier> <type><name>TMP_Text</name></type> <name>linkedTextComponent</name>
        <block>{
            <function><name>get</name> <block>{ <return>return <expr><name>m_linkedTextComponent</name></expr>;</return> }</block></function>

            <function><name>set</name>
            <block>{
                <if>if <condition>(<expr><name>m_linkedTextComponent</name> <operator>!=</operator> <name>value</name></expr>)</condition><then>
                <block>{
                    <comment type="line">// Release previously linked text component.</comment>
                    <if>if <condition>(<expr><name>m_linkedTextComponent</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><then>
                    <block>{
                        <expr_stmt><expr><name><name>m_linkedTextComponent</name><operator>.</operator><name>overflowMode</name></name> <operator>=</operator> <name><name>TextOverflowModes</name><operator>.</operator><name>Overflow</name></name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>m_linkedTextComponent</name><operator>.</operator><name>linkedTextComponent</name></name> <operator>=</operator> <literal type="null">null</literal></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>m_linkedTextComponent</name><operator>.</operator><name>isLinkedTextComponent</name></name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
                    }</block></then></if>

                    <expr_stmt><expr><name>m_linkedTextComponent</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>

                    <if>if <condition>(<expr><name>m_linkedTextComponent</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><then>
                        <block type="pseudo"><expr_stmt><expr><name><name>m_linkedTextComponent</name><operator>.</operator><name>isLinkedTextComponent</name></name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt></block></then></if>
                }</block></then></if>

                <expr_stmt><expr><name>m_havePropertiesChanged</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>m_isCalculateSizeRequired</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>SetVerticesDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>SetLayoutDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></function>
        }</block></property>
        <decl_stmt><decl><attribute>[<expr><name>SerializeField</name></expr>]</attribute>
        <specifier>protected</specifier> <type><name>TMP_Text</name></type> <name>m_linkedTextComponent</name></decl>;</decl_stmt>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Indicates whether this text component is linked to another.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <property><specifier>public</specifier> <type><name>bool</name></type> <name>isLinkedTextComponent</name>
        <block>{
            <function><name>get</name> <block>{ <return>return <expr><name>m_isLinkedTextComponent</name></expr>;</return> }</block></function>

            <function><name>set</name>
            <block>{
                <expr_stmt><expr><name>m_isLinkedTextComponent</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>

                <if>if <condition>(<expr><name>m_isLinkedTextComponent</name> <operator>==</operator> <literal type="boolean">false</literal></expr>)</condition><then>
                    <block type="pseudo"><expr_stmt><expr><name>m_firstVisibleCharacter</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block></then></if>

                <expr_stmt><expr><name>m_havePropertiesChanged</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>m_isCalculateSizeRequired</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>SetVerticesDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>SetLayoutDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></function>
        }</block></property>
        <decl_stmt><decl><attribute>[<expr><name>SerializeField</name></expr>]</attribute>
        <specifier>protected</specifier> <type><name>bool</name></type> <name>m_isLinkedTextComponent</name></decl>;</decl_stmt>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Property indicating whether the text is Truncated or using Ellipsis.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <property><specifier>public</specifier> <type><name>bool</name></type> <name>isTextTruncated</name> <block>{ <function><name>get</name> <block>{ <return>return <expr><name>m_isTextTruncated</name></expr>;</return> }</block></function> }</block></property>
        <decl_stmt><decl><attribute>[<expr><name>SerializeField</name></expr>]</attribute>
        <specifier>protected</specifier> <type><name>bool</name></type> <name>m_isTextTruncated</name></decl>;</decl_stmt>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Determines if kerning is enabled or disabled.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <property><specifier>public</specifier> <type><name>bool</name></type> <name>enableKerning</name>
        <block>{
            <function><name>get</name> <block>{ <return>return <expr><name>m_enableKerning</name></expr>;</return> }</block></function>
            <function><name>set</name> <block>{ <if>if <condition>(<expr><name>m_enableKerning</name> <operator>==</operator> <name>value</name></expr>)</condition><then> <block type="pseudo"><return>return;</return></block></then></if> <expr_stmt><expr><name>m_havePropertiesChanged</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt> <expr_stmt><expr><name>m_isCalculateSizeRequired</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt> <expr_stmt><expr><name>m_enableKerning</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt> <expr_stmt><expr><call><name>SetVerticesDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>SetLayoutDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt> }</block></function>
        }</block></property>
        <decl_stmt><decl><attribute>[<expr><name>SerializeField</name></expr>]</attribute>
        <specifier>protected</specifier> <type><name>bool</name></type> <name>m_enableKerning</name></decl>;</decl_stmt>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Adds extra padding around each character. This may be necessary when the displayed text is very small to prevent clipping.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <property><specifier>public</specifier> <type><name>bool</name></type> <name>extraPadding</name>
        <block>{
            <function><name>get</name> <block>{ <return>return <expr><name>m_enableExtraPadding</name></expr>;</return> }</block></function>
            <function><name>set</name> <block>{ <if>if <condition>(<expr><name>m_enableExtraPadding</name> <operator>==</operator> <name>value</name></expr>)</condition><then> <block type="pseudo"><return>return;</return></block></then></if> <expr_stmt><expr><name>m_havePropertiesChanged</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt> <expr_stmt><expr><name>m_enableExtraPadding</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt> <expr_stmt><expr><call><name>UpdateMeshPadding</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="block">/* m_isCalculateSizeRequired = true;*/</comment> <expr_stmt><expr><call><name>SetVerticesDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="block">/* SetLayoutDirty();*/</comment> }</block></function>
        }</block></property>
        <decl_stmt><decl><attribute>[<expr><name>SerializeField</name></expr>]</attribute>
        <specifier>protected</specifier> <type><name>bool</name></type> <name>m_enableExtraPadding</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><attribute>[<expr><name>SerializeField</name></expr>]</attribute>
        <specifier>protected</specifier> <type><name>bool</name></type> <name>checkPaddingRequired</name></decl>;</decl_stmt>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Enables or Disables Rich Text Tags</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <property><specifier>public</specifier> <type><name>bool</name></type> <name>richText</name>
        <block>{
            <function><name>get</name> <block>{ <return>return <expr><name>m_isRichText</name></expr>;</return> }</block></function>
            <function><name>set</name> <block>{ <if>if <condition>(<expr><name>m_isRichText</name> <operator>==</operator> <name>value</name></expr>)</condition><then> <block type="pseudo"><return>return;</return></block></then></if> <expr_stmt><expr><name>m_isRichText</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt> <expr_stmt><expr><name>m_havePropertiesChanged</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt> <expr_stmt><expr><name>m_isCalculateSizeRequired</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt> <expr_stmt><expr><name>m_isInputParsingRequired</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt> <expr_stmt><expr><call><name>SetVerticesDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>SetLayoutDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt> }</block></function>
        }</block></property>
        <decl_stmt><decl><attribute>[<expr><name>SerializeField</name></expr>]</attribute>
        <specifier>protected</specifier> <type><name>bool</name></type> <name>m_isRichText</name> <init>= <expr><literal type="boolean">true</literal></expr></init></decl>;</decl_stmt> <comment type="line">// Used to enable or disable Rich Text.</comment>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Enables or Disables parsing of CTRL characters in input text.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <property><specifier>public</specifier> <type><name>bool</name></type> <name>parseCtrlCharacters</name>
        <block>{
            <function><name>get</name> <block>{ <return>return <expr><name>m_parseCtrlCharacters</name></expr>;</return> }</block></function>
            <function><name>set</name> <block>{ <if>if <condition>(<expr><name>m_parseCtrlCharacters</name> <operator>==</operator> <name>value</name></expr>)</condition><then> <block type="pseudo"><return>return;</return></block></then></if> <expr_stmt><expr><name>m_parseCtrlCharacters</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt> <expr_stmt><expr><name>m_havePropertiesChanged</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt> <expr_stmt><expr><name>m_isCalculateSizeRequired</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt> <expr_stmt><expr><name>m_isInputParsingRequired</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt> <expr_stmt><expr><call><name>SetVerticesDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>SetLayoutDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt> }</block></function>
        }</block></property>
        <decl_stmt><decl><attribute>[<expr><name>SerializeField</name></expr>]</attribute>
        <specifier>protected</specifier> <type><name>bool</name></type> <name>m_parseCtrlCharacters</name> <init>= <expr><literal type="boolean">true</literal></expr></init></decl>;</decl_stmt>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Sets the RenderQueue along with Ztest to force the text to be drawn last and on top of scene elements.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <property><specifier>public</specifier> <type><name>bool</name></type> <name>isOverlay</name>
        <block>{
            <function><name>get</name> <block>{ <return>return <expr><name>m_isOverlay</name></expr>;</return> }</block></function>
            <function><name>set</name> <block>{ <if>if <condition>(<expr><name>m_isOverlay</name> <operator>==</operator> <name>value</name></expr>)</condition><then> <block type="pseudo"><return>return;</return></block></then></if> <expr_stmt><expr><name>m_isOverlay</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt> <expr_stmt><expr><call><name>SetShaderDepth</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>m_havePropertiesChanged</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt> <expr_stmt><expr><call><name>SetVerticesDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt> }</block></function>
        }</block></property>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>bool</name></type> <name>m_isOverlay</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Sets Perspective Correction to Zero for Orthographic Camera mode &amp; 0.875f for Perspective Camera mode.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <property><specifier>public</specifier> <type><name>bool</name></type> <name>isOrthographic</name>
        <block>{
            <function><name>get</name> <block>{ <return>return <expr><name>m_isOrthographic</name></expr>;</return> }</block></function>
            <function><name>set</name> <block>{ <if>if <condition>(<expr><name>m_isOrthographic</name> <operator>==</operator> <name>value</name></expr>)</condition><then> <block type="pseudo"><return>return;</return></block></then></if> <expr_stmt><expr><name>m_havePropertiesChanged</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt> <expr_stmt><expr><name>m_isOrthographic</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt> <expr_stmt><expr><call><name>SetVerticesDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt> }</block></function>
        }</block></property>
        <decl_stmt><decl><attribute>[<expr><name>SerializeField</name></expr>]</attribute>
        <specifier>protected</specifier> <type><name>bool</name></type> <name>m_isOrthographic</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Sets the culling on the shaders. Note changing this value will result in an instance of the material.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <property><specifier>public</specifier> <type><name>bool</name></type> <name>enableCulling</name>
        <block>{
            <function><name>get</name> <block>{ <return>return <expr><name>m_isCullingEnabled</name></expr>;</return> }</block></function>
            <function><name>set</name> <block>{ <if>if <condition>(<expr><name>m_isCullingEnabled</name> <operator>==</operator> <name>value</name></expr>)</condition><then> <block type="pseudo"><return>return;</return></block></then></if> <expr_stmt><expr><name>m_isCullingEnabled</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt> <expr_stmt><expr><call><name>SetCulling</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>m_havePropertiesChanged</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt> }</block></function>
        }</block></property>
        <decl_stmt><decl><attribute>[<expr><name>SerializeField</name></expr>]</attribute>
        <specifier>protected</specifier> <type><name>bool</name></type> <name>m_isCullingEnabled</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>

        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Controls whether or not the text object will be culled when using a 2D Rect Mask.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <property><specifier>public</specifier> <type><name>bool</name></type> <name>ignoreRectMaskCulling</name>
        <block>{
            <function><name>get</name> <block>{ <return>return <expr><name>m_ignoreRectMaskCulling</name></expr>;</return> }</block></function>
            <function><name>set</name> <block>{ <if>if <condition>(<expr><name>m_ignoreRectMaskCulling</name> <operator>==</operator> <name>value</name></expr>)</condition><then> <block type="pseudo"><return>return;</return></block></then></if> <expr_stmt><expr><name>m_ignoreRectMaskCulling</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt> <expr_stmt><expr><name>m_havePropertiesChanged</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt> }</block></function>
        }</block></property>
        <decl_stmt><decl><attribute>[<expr><name>SerializeField</name></expr>]</attribute>
        <specifier>protected</specifier> <type><name>bool</name></type> <name>m_ignoreRectMaskCulling</name></decl>;</decl_stmt>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Forces objects that are not visible to get refreshed.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <property><specifier>public</specifier> <type><name>bool</name></type> <name>ignoreVisibility</name>
        <block>{
            <function><name>get</name> <block>{ <return>return <expr><name>m_ignoreCulling</name></expr>;</return> }</block></function>
            <function><name>set</name> <block>{ <if>if <condition>(<expr><name>m_ignoreCulling</name> <operator>==</operator> <name>value</name></expr>)</condition><then> <block type="pseudo"><return>return;</return></block></then></if> <expr_stmt><expr><name>m_havePropertiesChanged</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt> <expr_stmt><expr><name>m_ignoreCulling</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt> }</block></function>
        }</block></property>
        <decl_stmt><decl><attribute>[<expr><name>SerializeField</name></expr>]</attribute>
        <specifier>protected</specifier> <type><name>bool</name></type> <name>m_ignoreCulling</name> <init>= <expr><literal type="boolean">true</literal></expr></init></decl>;</decl_stmt> <comment type="line">// Not implemented yet.</comment>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Controls how the face and outline textures will be applied to the text object.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <property><specifier>public</specifier> <type><name>TextureMappingOptions</name></type> <name>horizontalMapping</name>
        <block>{
            <function><name>get</name> <block>{ <return>return <expr><name>m_horizontalMapping</name></expr>;</return> }</block></function>
            <function><name>set</name> <block>{ <if>if <condition>(<expr><name>m_horizontalMapping</name> <operator>==</operator> <name>value</name></expr>)</condition><then> <block type="pseudo"><return>return;</return></block></then></if> <expr_stmt><expr><name>m_havePropertiesChanged</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt> <expr_stmt><expr><name>m_horizontalMapping</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt> <expr_stmt><expr><call><name>SetVerticesDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt> }</block></function>
        }</block></property>
        <decl_stmt><decl><attribute>[<expr><name>SerializeField</name></expr>]</attribute>
        <specifier>protected</specifier> <type><name>TextureMappingOptions</name></type> <name>m_horizontalMapping</name> <init>= <expr><name><name>TextureMappingOptions</name><operator>.</operator><name>Character</name></name></expr></init></decl>;</decl_stmt>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Controls how the face and outline textures will be applied to the text object.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <property><specifier>public</specifier> <type><name>TextureMappingOptions</name></type> <name>verticalMapping</name>
        <block>{
            <function><name>get</name> <block>{ <return>return <expr><name>m_verticalMapping</name></expr>;</return> }</block></function>
            <function><name>set</name> <block>{ <if>if <condition>(<expr><name>m_verticalMapping</name> <operator>==</operator> <name>value</name></expr>)</condition><then> <block type="pseudo"><return>return;</return></block></then></if> <expr_stmt><expr><name>m_havePropertiesChanged</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt> <expr_stmt><expr><name>m_verticalMapping</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt> <expr_stmt><expr><call><name>SetVerticesDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt> }</block></function>
        }</block></property>
        <decl_stmt><decl><attribute>[<expr><name>SerializeField</name></expr>]</attribute>
        <specifier>protected</specifier> <type><name>TextureMappingOptions</name></type> <name>m_verticalMapping</name> <init>= <expr><name><name>TextureMappingOptions</name><operator>.</operator><name>Character</name></name></expr></init></decl>;</decl_stmt>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Controls the UV Offset for the various texture mapping mode on the text object.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">//public Vector2 mappingUvOffset</comment>
        <comment type="line">//{</comment>
        <comment type="line">//    get { return m_uvOffset; }</comment>
        <comment type="line">//    set { if (m_uvOffset == value) return; m_havePropertiesChanged = true; m_uvOffset = value; SetVerticesDirty(); }</comment>
        <comment type="line">//}</comment>
        <comment type="line">//[SerializeField]</comment>
        <comment type="line">//protected Vector2 m_uvOffset = Vector2.zero; // Used to offset UV on Texturing</comment>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Controls the horizontal offset of the UV of the texture mapping mode for each line of the text object.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <property><specifier>public</specifier> <type><name>float</name></type> <name>mappingUvLineOffset</name>
        <block>{
            <function><name>get</name> <block>{ <return>return <expr><name>m_uvLineOffset</name></expr>;</return> }</block></function>
            <function><name>set</name> <block>{ <if>if <condition>(<expr><name>m_uvLineOffset</name> <operator>==</operator> <name>value</name></expr>)</condition><then> <block type="pseudo"><return>return;</return></block></then></if> <expr_stmt><expr><name>m_havePropertiesChanged</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt> <expr_stmt><expr><name>m_uvLineOffset</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt> <expr_stmt><expr><call><name>SetVerticesDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt> }</block></function>
        }</block></property>
        <decl_stmt><decl><attribute>[<expr><name>SerializeField</name></expr>]</attribute>
        <specifier>protected</specifier> <type><name>float</name></type> <name>m_uvLineOffset</name> <init>= <expr><literal type="number">0.0f</literal></expr></init></decl>;</decl_stmt> <comment type="line">// Used for UV line offset per line</comment>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Determines if the Mesh will be rendered.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <property><specifier>public</specifier> <type><name>TextRenderFlags</name></type> <name>renderMode</name>
        <block>{
            <function><name>get</name> <block>{ <return>return <expr><name>m_renderMode</name></expr>;</return> }</block></function>
            <function><name>set</name> <block>{ <if>if <condition>(<expr><name>m_renderMode</name> <operator>==</operator> <name>value</name></expr>)</condition><then> <block type="pseudo"><return>return;</return></block></then></if> <expr_stmt><expr><name>m_renderMode</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt> <expr_stmt><expr><name>m_havePropertiesChanged</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt> }</block></function>
        }</block></property>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>TextRenderFlags</name></type> <name>m_renderMode</name> <init>= <expr><name><name>TextRenderFlags</name><operator>.</operator><name>Render</name></name></expr></init></decl>;</decl_stmt>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Determines the sorting order of the geometry of the text object.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <property><specifier>public</specifier> <type><name>VertexSortingOrder</name></type> <name>geometrySortingOrder</name>
        <block>{
            <function><name>get</name> <block>{ <return>return <expr><name>m_geometrySortingOrder</name></expr>;</return> }</block></function>

            <function><name>set</name> <block>{ <expr_stmt><expr><name>m_geometrySortingOrder</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt> <expr_stmt><expr><name>m_havePropertiesChanged</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt> <expr_stmt><expr><call><name>SetVerticesDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt> }</block></function>

        }</block></property>
        <decl_stmt><decl><attribute>[<expr><name>SerializeField</name></expr>]</attribute>
        <specifier>protected</specifier> <type><name>VertexSortingOrder</name></type> <name>m_geometrySortingOrder</name></decl>;</decl_stmt>

        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// The first character which should be made visible in conjunction with the Text Overflow Linked mode.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <property><specifier>public</specifier> <type><name>int</name></type> <name>firstVisibleCharacter</name>
        <block>{
            <function><name>get</name> <block>{ <return>return <expr><name>m_firstVisibleCharacter</name></expr>;</return> }</block></function>
            <function><name>set</name> <block>{ <if>if <condition>(<expr><name>m_firstVisibleCharacter</name> <operator>==</operator> <name>value</name></expr>)</condition><then> <block type="pseudo"><return>return;</return></block></then></if> <expr_stmt><expr><name>m_havePropertiesChanged</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt> <expr_stmt><expr><name>m_firstVisibleCharacter</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt> <expr_stmt><expr><call><name>SetVerticesDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt> }</block></function>
        }</block></property>
        <decl_stmt><decl><attribute>[<expr><name>SerializeField</name></expr>]</attribute>
        <specifier>protected</specifier> <type><name>int</name></type> <name>m_firstVisibleCharacter</name></decl>;</decl_stmt>

        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Allows to control how many characters are visible from the input.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <property><specifier>public</specifier> <type><name>int</name></type> <name>maxVisibleCharacters</name>
        <block>{
            <function><name>get</name> <block>{ <return>return <expr><name>m_maxVisibleCharacters</name></expr>;</return> }</block></function>
            <function><name>set</name> <block>{ <if>if <condition>(<expr><name>m_maxVisibleCharacters</name> <operator>==</operator> <name>value</name></expr>)</condition><then> <block type="pseudo"><return>return;</return></block></then></if> <expr_stmt><expr><name>m_havePropertiesChanged</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt> <expr_stmt><expr><name>m_maxVisibleCharacters</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt> <expr_stmt><expr><call><name>SetVerticesDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt> }</block></function>
        }</block></property>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>int</name></type> <name>m_maxVisibleCharacters</name> <init>= <expr><literal type="number">99999</literal></expr></init></decl>;</decl_stmt>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Allows to control how many words are visible from the input.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <property><specifier>public</specifier> <type><name>int</name></type> <name>maxVisibleWords</name>
        <block>{
            <function><name>get</name> <block>{ <return>return <expr><name>m_maxVisibleWords</name></expr>;</return> }</block></function>
            <function><name>set</name> <block>{ <if>if <condition>(<expr><name>m_maxVisibleWords</name> <operator>==</operator> <name>value</name></expr>)</condition><then> <block type="pseudo"><return>return;</return></block></then></if> <expr_stmt><expr><name>m_havePropertiesChanged</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt> <expr_stmt><expr><name>m_maxVisibleWords</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt> <expr_stmt><expr><call><name>SetVerticesDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt> }</block></function>
        }</block></property>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>int</name></type> <name>m_maxVisibleWords</name> <init>= <expr><literal type="number">99999</literal></expr></init></decl>;</decl_stmt>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Allows control over how many lines of text are displayed.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <property><specifier>public</specifier> <type><name>int</name></type> <name>maxVisibleLines</name>
        <block>{
            <function><name>get</name> <block>{ <return>return <expr><name>m_maxVisibleLines</name></expr>;</return> }</block></function>
            <function><name>set</name> <block>{ <if>if <condition>(<expr><name>m_maxVisibleLines</name> <operator>==</operator> <name>value</name></expr>)</condition><then> <block type="pseudo"><return>return;</return></block></then></if> <expr_stmt><expr><name>m_havePropertiesChanged</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt> <expr_stmt><expr><name>m_isInputParsingRequired</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt> <expr_stmt><expr><name>m_maxVisibleLines</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt> <expr_stmt><expr><call><name>SetVerticesDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt> }</block></function>
        }</block></property>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>int</name></type> <name>m_maxVisibleLines</name> <init>= <expr><literal type="number">99999</literal></expr></init></decl>;</decl_stmt>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Determines if the text's vertical alignment will be adjusted based on visible descender of the text.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <property><specifier>public</specifier> <type><name>bool</name></type> <name>useMaxVisibleDescender</name>
        <block>{
            <function><name>get</name> <block>{ <return>return <expr><name>m_useMaxVisibleDescender</name></expr>;</return> }</block></function>
            <function><name>set</name> <block>{ <if>if <condition>(<expr><name>m_useMaxVisibleDescender</name> <operator>==</operator> <name>value</name></expr>)</condition><then> <block type="pseudo"><return>return;</return></block></then></if> <expr_stmt><expr><name>m_havePropertiesChanged</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt> <expr_stmt><expr><name>m_isInputParsingRequired</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt> <expr_stmt><expr><call><name>SetVerticesDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt> }</block></function>
        }</block></property>
        <decl_stmt><decl><attribute>[<expr><name>SerializeField</name></expr>]</attribute>
        <specifier>protected</specifier> <type><name>bool</name></type> <name>m_useMaxVisibleDescender</name> <init>= <expr><literal type="boolean">true</literal></expr></init></decl>;</decl_stmt>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Controls which page of text is shown</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <property><specifier>public</specifier> <type><name>int</name></type> <name>pageToDisplay</name>
        <block>{
            <function><name>get</name> <block>{ <return>return <expr><name>m_pageToDisplay</name></expr>;</return> }</block></function>
            <function><name>set</name> <block>{ <if>if <condition>(<expr><name>m_pageToDisplay</name> <operator>==</operator> <name>value</name></expr>)</condition><then> <block type="pseudo"><return>return;</return></block></then></if> <expr_stmt><expr><name>m_havePropertiesChanged</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt> <expr_stmt><expr><name>m_pageToDisplay</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt> <expr_stmt><expr><call><name>SetVerticesDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt> }</block></function>
        }</block></property>
        <decl_stmt><decl><attribute>[<expr><name>SerializeField</name></expr>]</attribute>
        <specifier>protected</specifier> <type><name>int</name></type> <name>m_pageToDisplay</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>bool</name></type> <name>m_isNewPage</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>

        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// The margins of the text object.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <property><specifier>public</specifier> <specifier>virtual</specifier> <type><name>Vector4</name></type> <name>margin</name>
        <block>{
            <function><name>get</name> <block>{ <return>return <expr><name>m_margin</name></expr>;</return> }</block></function>
            <function><name>set</name> <block>{ <if>if <condition>(<expr><name>m_margin</name> <operator>==</operator> <name>value</name></expr>)</condition><then> <block type="pseudo"><return>return;</return></block></then></if> <expr_stmt><expr><name>m_margin</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt> <expr_stmt><expr><call><name>ComputeMarginSize</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>m_havePropertiesChanged</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt> <expr_stmt><expr><call><name>SetVerticesDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt> }</block></function>
        }</block></property>
        <decl_stmt><decl><attribute>[<expr><name>SerializeField</name></expr>]</attribute>
        <specifier>protected</specifier> <type><name>Vector4</name></type> <name>m_margin</name> <init>= <expr><operator>new</operator> <call><name>Vector4</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>float</name></type> <name>m_marginLeft</name></decl>;</decl_stmt>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>float</name></type> <name>m_marginRight</name></decl>;</decl_stmt>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>float</name></type> <name>m_marginWidth</name></decl>;</decl_stmt>  <comment type="line">// Width of the RectTransform minus left and right margins.</comment>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>float</name></type> <name>m_marginHeight</name></decl>;</decl_stmt> <comment type="line">// Height of the RectTransform minus top and bottom margins.</comment>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>float</name></type> <name>m_width</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Returns data about the text object which includes information about each character, word, line, link, etc.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <property><specifier>public</specifier> <type><name>TMP_TextInfo</name></type> <name>textInfo</name>
        <block>{
            <function><name>get</name> <block>{ <return>return <expr><name>m_textInfo</name></expr>;</return> }</block></function>
        }</block></property>
        <decl_stmt><decl><attribute>[<expr><name>SerializeField</name></expr>]</attribute>
        <specifier>protected</specifier> <type><name>TMP_TextInfo</name></type> <name>m_textInfo</name></decl>;</decl_stmt> <comment type="line">// Class which holds information about the Text object such as characters, lines, mesh data as well as metrics. </comment>

        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Property tracking if any of the text properties have changed. Flag is set before the text is regenerated.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <property><specifier>public</specifier> <type><name>bool</name></type> <name>havePropertiesChanged</name>
        <block>{
            <function><name>get</name> <block>{ <return>return <expr><name>m_havePropertiesChanged</name></expr>;</return> }</block></function>
            <function><name>set</name> <block>{ <if>if <condition>(<expr><name>m_havePropertiesChanged</name> <operator>==</operator> <name>value</name></expr>)</condition><then> <block type="pseudo"><return>return;</return></block></then></if> <expr_stmt><expr><name>m_havePropertiesChanged</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt> <expr_stmt><expr><name>m_isInputParsingRequired</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt> <expr_stmt><expr><call><name>SetAllDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt> }</block></function>
        }</block></property>
        <decl_stmt><decl><attribute>[<expr><name>SerializeField</name></expr>]</attribute>
        <specifier>protected</specifier> <type><name>bool</name></type> <name>m_havePropertiesChanged</name></decl>;</decl_stmt>  <comment type="line">// Used to track when properties of the text object have changed.</comment>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Property to handle legacy animation component.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <property><specifier>public</specifier> <type><name>bool</name></type> <name>isUsingLegacyAnimationComponent</name>
        <block>{
            <function><name>get</name> <block>{ <return>return <expr><name>m_isUsingLegacyAnimationComponent</name></expr>;</return> }</block></function>
            <function><name>set</name> <block>{ <expr_stmt><expr><name>m_isUsingLegacyAnimationComponent</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt> }</block></function>
        }</block></property>
        <decl_stmt><decl><attribute>[<expr><name>SerializeField</name></expr>]</attribute>
        <specifier>protected</specifier> <type><name>bool</name></type> <name>m_isUsingLegacyAnimationComponent</name></decl>;</decl_stmt>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Returns are reference to the Transform</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <property><specifier>public</specifier> <specifier>new</specifier> <type><name>Transform</name></type> <name>transform</name>
        <block>{
            <function><name>get</name>
            <block>{
                <if>if <condition>(<expr><name>m_transform</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then>
                    <block type="pseudo"><expr_stmt><expr><name>m_transform</name> <operator>=</operator> <call><name><name>GetComponent</name><argument_list type="generic">&lt;<argument><name>Transform</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block></then></if>
                <return>return <expr><name>m_transform</name></expr>;</return>
            }</block></function>
        }</block></property>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>Transform</name></type> <name>m_transform</name></decl>;</decl_stmt>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Returns are reference to the RectTransform</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <property><specifier>public</specifier> <specifier>new</specifier> <type><name>RectTransform</name></type> <name>rectTransform</name>
        <block>{
            <function><name>get</name>
            <block>{
                <if>if <condition>(<expr><name>m_rectTransform</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then>
                    <block type="pseudo"><expr_stmt><expr><name>m_rectTransform</name> <operator>=</operator> <call><name><name>GetComponent</name><argument_list type="generic">&lt;<argument><name>RectTransform</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block></then></if>
                <return>return <expr><name>m_rectTransform</name></expr>;</return>
            }</block></function>
        }</block></property>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>RectTransform</name></type> <name>m_rectTransform</name></decl>;</decl_stmt>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Enables control over setting the size of the text container to match the text object.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <property><specifier>public</specifier> <specifier>virtual</specifier> <type><name>bool</name></type> <name>autoSizeTextContainer</name>
        <block>{
            <function_decl><name>get</name>;</function_decl>
            <function_decl><name>set</name>;</function_decl>
        }</block></property>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>bool</name></type> <name>m_autoSizeTextContainer</name></decl>;</decl_stmt>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// The mesh used by the font asset and material assigned to the text object.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <property><specifier>public</specifier> <specifier>virtual</specifier> <type><name>Mesh</name></type> <name>mesh</name>
        <block>{
            <function><name>get</name> <block>{ <return>return <expr><name>m_mesh</name></expr>;</return> }</block></function>
        }</block></property>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>Mesh</name></type> <name>m_mesh</name></decl>;</decl_stmt>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Determines if the geometry of the characters will be quads or volumetric (cubes).</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <property><specifier>public</specifier> <type><name>bool</name></type> <name>isVolumetricText</name>
        <block>{
            <function><name>get</name> <block>{ <return>return <expr><name>m_isVolumetricText</name></expr>;</return> }</block></function>
            <function><name>set</name> <block>{ <if>if <condition>(<expr><name>m_isVolumetricText</name> <operator>==</operator> <name>value</name></expr>)</condition><then> <block type="pseudo"><return>return;</return></block></then></if> <expr_stmt><expr><name>m_havePropertiesChanged</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt> <expr_stmt><expr><call><name><name>m_textInfo</name><operator>.</operator><name>ResetVertexLayout</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>m_isInputParsingRequired</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt> <expr_stmt><expr><call><name>SetVerticesDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>SetLayoutDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt> }</block></function>
        }</block></property>
        <decl_stmt><decl><attribute>[<expr><name>SerializeField</name></expr>]</attribute>
        <specifier>protected</specifier> <type><name>bool</name></type> <name>m_isVolumetricText</name></decl>;</decl_stmt>

        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Returns the bounds of the mesh of the text object in world space.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <property><specifier>public</specifier> <type><name>Bounds</name></type> <name>bounds</name>
        <block>{
            <function><name>get</name>
            <block>{
                <if>if <condition>(<expr><name>m_mesh</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block type="pseudo"><return>return <expr><operator>new</operator> <call><name>Bounds</name><argument_list>()</argument_list></call></expr>;</return></block></then></if>

                <return>return <expr><call><name>GetCompoundBounds</name><argument_list>()</argument_list></call></expr>;</return>
            }</block></function>
        }</block></property>

        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Returns the bounds of the text of the text object.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <property><specifier>public</specifier> <type><name>Bounds</name></type> <name>textBounds</name>
        <block>{
            <function><name>get</name>
            <block>{
                <if>if <condition>(<expr><name>m_textInfo</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block type="pseudo"><return>return <expr><operator>new</operator> <call><name>Bounds</name><argument_list>()</argument_list></call></expr>;</return></block></then></if>

                <return>return <expr><call><name>GetTextBounds</name><argument_list>()</argument_list></call></expr>;</return>
            }</block></function>
        }</block></property>

        <comment type="line">// *** Unity Event Handling ***</comment>

        <comment type="line">//[Serializable]</comment>
        <comment type="line">//public class TextChangedEvent : UnityEvent { }</comment>

        <comment type="line">///// &lt;summary&gt;</comment>
        <comment type="line">///// Event delegate triggered when text has changed and been rendered.</comment>
        <comment type="line">///// &lt;/summary&gt;</comment>
        <comment type="line">//public TextChangedEvent onTextChanged</comment>
        <comment type="line">//{</comment>
        <comment type="line">//    get { return m_OnTextChanged; }</comment>
        <comment type="line">//    set { m_OnTextChanged = value; }</comment>
        <comment type="line">//}</comment>
        <comment type="line">//[SerializeField]</comment>
        <comment type="line">//private TextChangedEvent m_OnTextChanged = new TextChangedEvent();</comment>

        <comment type="line">//protected void SendOnTextChanged()</comment>
        <comment type="line">//{</comment>
        <comment type="line">//    if (onTextChanged != null)</comment>
        <comment type="line">//        onTextChanged.Invoke();</comment>
        <comment type="line">//}</comment>


        <comment type="line">// *** SPECIAL COMPONENTS ***</comment>

        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Component used to control wrapping of text following some arbitrary shape.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">//public MarginShaper marginShaper</comment>
        <comment type="line">//{</comment>
        <comment type="line">//    get</comment>
        <comment type="line">//    {</comment>
        <comment type="line">//        if (m_marginShaper == null) m_marginShaper = GetComponent&lt;MarginShaper&gt;();</comment>

        <comment type="line">//        return m_marginShaper;</comment>
        <comment type="line">//    }</comment>
        <comment type="line">//}</comment>
        <comment type="line">//[SerializeField]</comment>
        <comment type="line">//protected MarginShaper m_marginShaper;</comment>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Component used to control and animate sprites in the text object.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <property><specifier>protected</specifier> <type><name>TMP_SpriteAnimator</name></type> <name>spriteAnimator</name>
        <block>{
            <function><name>get</name>
            <block>{
                <if>if <condition>(<expr><name>m_spriteAnimator</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then>
                <block>{
                    <expr_stmt><expr><name>m_spriteAnimator</name> <operator>=</operator> <call><name><name>GetComponent</name><argument_list type="generic">&lt;<argument><name>TMP_SpriteAnimator</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr><name>m_spriteAnimator</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><name>m_spriteAnimator</name> <operator>=</operator> <call><name><name>gameObject</name><operator>.</operator><name><name>AddComponent</name><argument_list type="generic">&lt;<argument><name>TMP_SpriteAnimator</name></argument>&gt;</argument_list></name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block></then></if>
                }</block></then></if>

                <return>return <expr><name>m_spriteAnimator</name></expr>;</return>
            }</block></function>

        }</block></property>
        <decl_stmt><decl><attribute>[<expr><name>SerializeField</name></expr>]</attribute>
        <specifier>protected</specifier> <type><name>TMP_SpriteAnimator</name></type> <name>m_spriteAnimator</name></decl>;</decl_stmt>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// </comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">//public TMP_TextShaper textShaper</comment>
        <comment type="line">//{</comment>
        <comment type="line">//    get</comment>
        <comment type="line">//    {</comment>
        <comment type="line">//        if (m_textShaper == null)</comment>
        <comment type="line">//            m_textShaper = GetComponent&lt;TMP_TextShaper&gt;();</comment>

        <comment type="line">//        return m_textShaper;</comment>
        <comment type="line">//    }</comment>
        <comment type="line">//}</comment>
        <comment type="line">//[SerializeField]</comment>
        <comment type="line">//protected TMP_TextShaper m_textShaper;</comment>

        <comment type="line">// *** PROPERTIES RELATED TO UNITY LAYOUT SYSTEM ***</comment>
        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// </comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <property><specifier>public</specifier> <type><name>float</name></type> <name>flexibleHeight</name> <block>{ <function><name>get</name> <block>{ <return>return <expr><name>m_flexibleHeight</name></expr>;</return> }</block></function> }</block></property>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>float</name></type> <name>m_flexibleHeight</name> <init>= <expr><operator>-</operator><literal type="number">1f</literal></expr></init></decl>;</decl_stmt>

        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// </comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <property><specifier>public</specifier> <type><name>float</name></type> <name>flexibleWidth</name> <block>{ <function><name>get</name> <block>{ <return>return <expr><name>m_flexibleWidth</name></expr>;</return> }</block></function> }</block></property>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>float</name></type> <name>m_flexibleWidth</name> <init>= <expr><operator>-</operator><literal type="number">1f</literal></expr></init></decl>;</decl_stmt>

        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// </comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <property><specifier>public</specifier> <type><name>float</name></type> <name>minWidth</name> <block>{ <function><name>get</name> <block>{ <return>return <expr><name>m_minWidth</name></expr>;</return> }</block></function> }</block></property>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>float</name></type> <name>m_minWidth</name></decl>;</decl_stmt>

        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// </comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <property><specifier>public</specifier> <type><name>float</name></type> <name>minHeight</name> <block>{ <function><name>get</name> <block>{ <return>return <expr><name>m_minHeight</name></expr>;</return> }</block></function> }</block></property>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>float</name></type> <name>m_minHeight</name></decl>;</decl_stmt>

        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// </comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <property><specifier>public</specifier> <type><name>float</name></type> <name>maxWidth</name> <block>{ <function><name>get</name> <block>{ <return>return <expr><name>m_maxWidth</name></expr>;</return> }</block></function> }</block></property>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>float</name></type> <name>m_maxWidth</name></decl>;</decl_stmt>

        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// </comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <property><specifier>public</specifier> <type><name>float</name></type> <name>maxHeight</name> <block>{ <function><name>get</name> <block>{ <return>return <expr><name>m_maxHeight</name></expr>;</return> }</block></function> }</block></property>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>float</name></type> <name>m_maxHeight</name></decl>;</decl_stmt>

        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// </comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <property><specifier>protected</specifier> <type><name>LayoutElement</name></type> <name>layoutElement</name>
        <block>{
            <function><name>get</name>
            <block>{
                <if>if <condition>(<expr><name>m_LayoutElement</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then>
                <block>{
                    <expr_stmt><expr><name>m_LayoutElement</name> <operator>=</operator> <call><name><name>GetComponent</name><argument_list type="generic">&lt;<argument><name>LayoutElement</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>

                <return>return <expr><name>m_LayoutElement</name></expr>;</return>
            }</block></function>
        }</block></property>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>LayoutElement</name></type> <name>m_LayoutElement</name></decl>;</decl_stmt>

        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Computed preferred width of the text object.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <property><specifier>public</specifier> <specifier>virtual</specifier> <type><name>float</name></type> <name>preferredWidth</name> <block>{ <function><name>get</name> <block>{ <if>if <condition>(<expr><operator>!</operator><name>m_isPreferredWidthDirty</name></expr>)</condition><then> <block type="pseudo"><return>return <expr><name>m_preferredWidth</name></expr>;</return></block></then></if> <expr_stmt><expr><name>m_preferredWidth</name> <operator>=</operator> <call><name>GetPreferredWidth</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <return>return <expr><name>m_preferredWidth</name></expr>;</return> }</block></function> }</block></property>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>float</name></type> <name>m_preferredWidth</name></decl>;</decl_stmt>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>float</name></type> <name>m_renderedWidth</name></decl>;</decl_stmt>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>bool</name></type> <name>m_isPreferredWidthDirty</name></decl>;</decl_stmt>

        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Computed preferred height of the text object.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <property><specifier>public</specifier> <specifier>virtual</specifier> <type><name>float</name></type> <name>preferredHeight</name> <block>{ <function><name>get</name> <block>{ <if>if <condition>(<expr><operator>!</operator><name>m_isPreferredHeightDirty</name></expr>)</condition><then> <block type="pseudo"><return>return <expr><name>m_preferredHeight</name></expr>;</return></block></then></if> <expr_stmt><expr><name>m_preferredHeight</name> <operator>=</operator> <call><name>GetPreferredHeight</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <return>return <expr><name>m_preferredHeight</name></expr>;</return> }</block></function> }</block></property>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>float</name></type> <name>m_preferredHeight</name></decl>;</decl_stmt>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>float</name></type> <name>m_renderedHeight</name></decl>;</decl_stmt>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>bool</name></type> <name>m_isPreferredHeightDirty</name></decl>;</decl_stmt>

        <decl_stmt><decl><specifier>protected</specifier> <type><name>bool</name></type> <name>m_isCalculatingPreferredValues</name></decl>;</decl_stmt>
        <decl_stmt><decl><specifier>private</specifier> <type><name>int</name></type> <name>m_recursiveCount</name></decl>;</decl_stmt>

        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Compute the rendered width of the text object.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <property><specifier>public</specifier> <specifier>virtual</specifier> <type><name>float</name></type> <name>renderedWidth</name> <block>{ <function><name>get</name> <block>{ <return>return <expr><call><name>GetRenderedWidth</name><argument_list>()</argument_list></call></expr>;</return> }</block></function> }</block></property>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Compute the rendered height of the text object.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <property><specifier>public</specifier> <specifier>virtual</specifier> <type><name>float</name></type> <name>renderedHeight</name> <block>{ <function><name>get</name> <block>{ <return>return <expr><call><name>GetRenderedHeight</name><argument_list>()</argument_list></call></expr>;</return> }</block></function> }</block></property>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// </comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <property><specifier>public</specifier> <type><name>int</name></type> <name>layoutPriority</name> <block>{ <function><name>get</name> <block>{ <return>return <expr><name>m_layoutPriority</name></expr>;</return> }</block></function> }</block></property>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>int</name></type> <name>m_layoutPriority</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><specifier>protected</specifier> <type><name>bool</name></type> <name>m_isCalculateSizeRequired</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>bool</name></type> <name>m_isLayoutDirty</name></decl>;</decl_stmt>

        <decl_stmt><decl><specifier>protected</specifier> <type><name>bool</name></type> <name>m_verticesAlreadyDirty</name></decl>;</decl_stmt>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>bool</name></type> <name>m_layoutAlreadyDirty</name></decl>;</decl_stmt>

        <decl_stmt><decl><specifier>protected</specifier> <type><name>bool</name></type> <name>m_isAwake</name></decl>;</decl_stmt>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>bool</name></type> <name>m_isWaitingOnResourceLoad</name></decl>;</decl_stmt>

        <decl_stmt><decl><attribute>[<expr><name>SerializeField</name></expr>]</attribute>
        <specifier>protected</specifier> <type><name>bool</name></type> <name>m_isInputParsingRequired</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt> <comment type="line">// Used to determine if the input text needs to be re-parsed.</comment>

        <comment type="line">// Protected Fields</comment>
        <enum><specifier>protected</specifier> enum <name>TextInputSources</name> <block>{ <decl><name>Text</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><name>SetText</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>, <decl><name>SetCharArray</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>, <decl><name>String</name> <init>= <expr><literal type="number">3</literal></expr></init></decl> }</block>;</enum>
        <decl_stmt><decl><attribute>[<expr><name>SerializeField</name></expr>]</attribute>
        <specifier>protected</specifier> <type><name>TextInputSources</name></type> <name>m_inputSource</name></decl>;</decl_stmt>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>string</name></type> <name>old_text</name></decl>;</decl_stmt> <comment type="line">// Used by SetText to determine if the text has changed.</comment>
        <comment type="line">//protected float old_arg0, old_arg1, old_arg2; // Used by SetText to determine if the args have changed.</comment>


        <decl_stmt><decl><specifier>protected</specifier> <type><name>float</name></type> <name>m_fontScale</name></decl>;</decl_stmt> <comment type="line">// Scaling of the font based on Atlas true Font Size and Rendered Font Size.  </comment>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>float</name></type> <name>m_fontScaleMultiplier</name></decl>;</decl_stmt> <comment type="line">// Used for handling of superscript and subscript.</comment>

        <decl_stmt><decl><specifier>protected</specifier> <type><name><name>char</name><index>[]</index></name></type> <name>m_htmlTag</name> <init>= <expr><operator>new</operator> <name><name>char</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></expr></init></decl>;</decl_stmt> <comment type="line">// Maximum length of rich text tag. This is preallocated to avoid GC.</comment>
        <decl_stmt><decl><specifier>protected</specifier> <type><name><name>XML_TagAttribute</name><index>[]</index></name></type> <name>m_xmlAttribute</name> <init>= <expr><operator>new</operator> <name><name>XML_TagAttribute</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><specifier>protected</specifier> <type><name><name>float</name><index>[]</index></name></type> <name>m_attributeParameterValues</name> <init>= <expr><operator>new</operator> <name><name>float</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><specifier>protected</specifier> <type><name>float</name></type> <name>tag_LineIndent</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>float</name></type> <name>tag_Indent</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><specifier>protected</specifier> <type><name><name>TMP_XmlTagStack</name><argument_list type="generic">&lt;<argument><name>float</name></argument>&gt;</argument_list></name></type> <name>m_indentStack</name> <init>= <expr><operator>new</operator> <call><name><name>TMP_XmlTagStack</name><argument_list type="generic">&lt;<argument><name>float</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>new</operator> <name><name>float</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>bool</name></type> <name>tag_NoParsing</name></decl>;</decl_stmt>
        <comment type="line">//protected TMP_LinkInfo tag_LinkInfo = new TMP_LinkInfo();</comment>

        <decl_stmt><decl><specifier>protected</specifier> <type><name>bool</name></type> <name>m_isParsingText</name></decl>;</decl_stmt>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>Matrix4x4</name></type> <name>m_FXMatrix</name></decl>;</decl_stmt>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>bool</name></type> <name>m_isFXMatrixSet</name></decl>;</decl_stmt>


        <decl_stmt><decl><specifier>protected</specifier> <type><name><name>int</name><index>[]</index></name></type> <name>m_char_buffer</name></decl>;</decl_stmt> <comment type="line">// This array holds the characters to be processed by GenerateMesh();</comment>
        <decl_stmt><decl><specifier>private</specifier> <type><name><name>TMP_CharacterInfo</name><index>[]</index></name></type> <name>m_internalCharacterInfo</name></decl>;</decl_stmt> <comment type="line">// Used by functions to calculate preferred values.</comment>
        <decl_stmt><decl><specifier>protected</specifier> <type><name><name>char</name><index>[]</index></name></type> <name>m_input_CharArray</name> <init>= <expr><operator>new</operator> <name><name>char</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></expr></init></decl>;</decl_stmt> <comment type="line">// This array hold the characters from the SetText();</comment>
        <decl_stmt><decl><specifier>private</specifier> <type><name>int</name></type> <name>m_charArray_Length</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>int</name></type> <name>m_totalCharacterCount</name></decl>;</decl_stmt>

        <comment type="line">// Structures used to save the state of the text layout in conjunction with line breaking / word wrapping.</comment>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>WordWrapState</name></type> <name>m_SavedWordWrapState</name> <init>= <expr><operator>new</operator> <call><name>WordWrapState</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>WordWrapState</name></type> <name>m_SavedLineState</name> <init>= <expr><operator>new</operator> <call><name>WordWrapState</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<comment type="line">//protected WordWrapState m_SavedAlignment = new WordWrapState ();</comment>


        <comment type="line">// Fields whose state is saved in conjunction with text parsing and word wrapping.</comment>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>int</name></type> <name>m_characterCount</name></decl>;</decl_stmt>
        <comment type="line">//protected int m_visibleCharacterCount;</comment>
        <comment type="line">//protected int m_visibleSpriteCount;</comment>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>int</name></type> <name>m_firstCharacterOfLine</name></decl>;</decl_stmt>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>int</name></type> <name>m_firstVisibleCharacterOfLine</name></decl>;</decl_stmt>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>int</name></type> <name>m_lastCharacterOfLine</name></decl>;</decl_stmt>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>int</name></type> <name>m_lastVisibleCharacterOfLine</name></decl>;</decl_stmt>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>int</name></type> <name>m_lineNumber</name></decl>;</decl_stmt>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>int</name></type> <name>m_lineVisibleCharacterCount</name></decl>;</decl_stmt>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>int</name></type> <name>m_pageNumber</name></decl>;</decl_stmt>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>float</name></type> <name>m_maxAscender</name></decl>;</decl_stmt>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>float</name></type> <name>m_maxCapHeight</name></decl>;</decl_stmt>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>float</name></type> <name>m_maxDescender</name></decl>;</decl_stmt>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>float</name></type> <name>m_maxLineAscender</name></decl>;</decl_stmt>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>float</name></type> <name>m_maxLineDescender</name></decl>;</decl_stmt>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>float</name></type> <name>m_startOfLineAscender</name></decl>;</decl_stmt>
        <comment type="line">//protected float m_maxFontScale;</comment>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>float</name></type> <name>m_lineOffset</name></decl>;</decl_stmt>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>Extents</name></type> <name>m_meshExtents</name></decl>;</decl_stmt>


        <comment type="line">// Fields used for vertex colors</comment>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>Color32</name></type> <name>m_htmlColor</name> <init>= <expr><operator>new</operator> <call><name>Color</name><argument_list>(<argument><expr><literal type="number">255</literal></expr></argument>, <argument><expr><literal type="number">255</literal></expr></argument>, <argument><expr><literal type="number">255</literal></expr></argument>, <argument><expr><literal type="number">128</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><specifier>protected</specifier> <type><name><name>TMP_XmlTagStack</name><argument_list type="generic">&lt;<argument><name>Color32</name></argument>&gt;</argument_list></name></type> <name>m_colorStack</name> <init>= <expr><operator>new</operator> <call><name><name>TMP_XmlTagStack</name><argument_list type="generic">&lt;<argument><name>Color32</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>new</operator> <name><name>Color32</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><specifier>protected</specifier> <type><name><name>TMP_XmlTagStack</name><argument_list type="generic">&lt;<argument><name>Color32</name></argument>&gt;</argument_list></name></type> <name>m_underlineColorStack</name> <init>= <expr><operator>new</operator> <call><name><name>TMP_XmlTagStack</name><argument_list type="generic">&lt;<argument><name>Color32</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>new</operator> <name><name>Color32</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><specifier>protected</specifier> <type><name><name>TMP_XmlTagStack</name><argument_list type="generic">&lt;<argument><name>Color32</name></argument>&gt;</argument_list></name></type> <name>m_strikethroughColorStack</name> <init>= <expr><operator>new</operator> <call><name><name>TMP_XmlTagStack</name><argument_list type="generic">&lt;<argument><name>Color32</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>new</operator> <name><name>Color32</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><specifier>protected</specifier> <type><name><name>TMP_XmlTagStack</name><argument_list type="generic">&lt;<argument><name>Color32</name></argument>&gt;</argument_list></name></type> <name>m_highlightColorStack</name> <init>= <expr><operator>new</operator> <call><name><name>TMP_XmlTagStack</name><argument_list type="generic">&lt;<argument><name>Color32</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>new</operator> <name><name>Color32</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><specifier>protected</specifier> <type><name>TMP_ColorGradient</name></type> <name>m_colorGradientPreset</name></decl>;</decl_stmt>
        <decl_stmt><decl><specifier>protected</specifier> <type><name><name>TMP_XmlTagStack</name><argument_list type="generic">&lt;<argument><name>TMP_ColorGradient</name></argument>&gt;</argument_list></name></type> <name>m_colorGradientStack</name> <init>= <expr><operator>new</operator> <call><name><name>TMP_XmlTagStack</name><argument_list type="generic">&lt;<argument><name>TMP_ColorGradient</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>new</operator> <name><name>TMP_ColorGradient</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><specifier>protected</specifier> <type><name>float</name></type> <name>m_tabSpacing</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>float</name></type> <name>m_spacing</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>


        <comment type="line">//protected bool IsRectTransformDriven;</comment>


        <comment type="line">// STYLE TAGS</comment>
        <decl_stmt><decl><specifier>protected</specifier> <type><name><name>TMP_XmlTagStack</name><argument_list type="generic">&lt;<argument><name>int</name></argument>&gt;</argument_list></name></type> <name>m_styleStack</name> <init>= <expr><operator>new</operator> <call><name><name>TMP_XmlTagStack</name><argument_list type="generic">&lt;<argument><name>int</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>new</operator> <name><name>int</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><specifier>protected</specifier> <type><name><name>TMP_XmlTagStack</name><argument_list type="generic">&lt;<argument><name>int</name></argument>&gt;</argument_list></name></type> <name>m_actionStack</name> <init>= <expr><operator>new</operator> <call><name><name>TMP_XmlTagStack</name><argument_list type="generic">&lt;<argument><name>int</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>new</operator> <name><name>int</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><specifier>protected</specifier> <type><name>float</name></type> <name>m_padding</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>float</name></type> <name>m_baselineOffset</name></decl>;</decl_stmt> <comment type="line">// Used for superscript and subscript.</comment>
        <decl_stmt><decl><specifier>protected</specifier> <type><name><name>TMP_XmlTagStack</name><argument_list type="generic">&lt;<argument><name>float</name></argument>&gt;</argument_list></name></type> <name>m_baselineOffsetStack</name> <init>= <expr><operator>new</operator> <call><name><name>TMP_XmlTagStack</name><argument_list type="generic">&lt;<argument><name>float</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>new</operator> <name><name>float</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>float</name></type> <name>m_xAdvance</name></decl>;</decl_stmt> <comment type="line">// Tracks x advancement from character to character.</comment>

        <decl_stmt><decl><specifier>protected</specifier> <type><name>TMP_TextElementType</name></type> <name>m_textElementType</name></decl>;</decl_stmt>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>TMP_TextElement</name></type> <name>m_cached_TextElement</name></decl>;</decl_stmt> <comment type="line">// Glyph / Character information is cached into this variable which is faster than having to fetch from the Dictionary multiple times.</comment>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>TMP_Glyph</name></type> <name>m_cached_Underline_GlyphInfo</name></decl>;</decl_stmt> <comment type="line">// Same as above but for the underline character which is used for Underline.</comment>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>TMP_Glyph</name></type> <name>m_cached_Ellipsis_GlyphInfo</name></decl>;</decl_stmt>

        <decl_stmt><decl><specifier>protected</specifier> <type><name>TMP_SpriteAsset</name></type> <name>m_defaultSpriteAsset</name></decl>;</decl_stmt>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>TMP_SpriteAsset</name></type> <name>m_currentSpriteAsset</name></decl>;</decl_stmt>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>int</name></type> <name>m_spriteCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>int</name></type> <name>m_spriteIndex</name></decl>;</decl_stmt>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>int</name></type> <name>m_spriteAnimationID</name></decl>;</decl_stmt>
        <comment type="line">//protected TMP_XmlTagStack&lt;int&gt; m_spriteAnimationStack = new TMP_XmlTagStack&lt;int&gt;(new int[16]);</comment>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Method which derived classes need to override to load Font Assets.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <function><specifier>protected</specifier> <specifier>virtual</specifier> <type><name>void</name></type> <name>LoadFontAsset</name><parameter_list>()</parameter_list> <block>{ }</block></function>

        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Function called internally when a new shared material is assigned via the fontSharedMaterial property.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;param name="mat"&gt;&lt;/param&gt;</comment>
        <function><specifier>protected</specifier> <specifier>virtual</specifier> <type><name>void</name></type> <name>SetSharedMaterial</name><parameter_list>(<parameter><decl><type><name>Material</name></type> <name>mat</name></decl></parameter>)</parameter_list> <block>{ }</block></function>

        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Function called internally when a new material is assigned via the fontMaterial property.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <function><specifier>protected</specifier> <specifier>virtual</specifier> <type><name>Material</name></type> <name>GetMaterial</name><parameter_list>(<parameter><decl><type><name>Material</name></type> <name>mat</name></decl></parameter>)</parameter_list> <block>{ <return>return <expr><literal type="null">null</literal></expr>;</return> }</block></function>

        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Function called internally when assigning a new base material.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;param name="mat"&gt;&lt;/param&gt;</comment>
        <function><specifier>protected</specifier> <specifier>virtual</specifier> <type><name>void</name></type> <name>SetFontBaseMaterial</name><parameter_list>(<parameter><decl><type><name>Material</name></type> <name>mat</name></decl></parameter>)</parameter_list> <block>{ }</block></function>

        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Method which returns an array containing the materials used by the text object.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;returns&gt;&lt;/returns&gt;</comment>
        <function><specifier>protected</specifier> <specifier>virtual</specifier> <type><name><name>Material</name><index>[]</index></name></type> <name>GetSharedMaterials</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><literal type="null">null</literal></expr>;</return> }</block></function>

        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// </comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <function><specifier>protected</specifier> <specifier>virtual</specifier> <type><name>void</name></type> <name>SetSharedMaterials</name><parameter_list>(<parameter><decl><type><name><name>Material</name><index>[]</index></name></type> <name>materials</name></decl></parameter>)</parameter_list> <block>{ }</block></function>

        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Method returning instances of the materials used by the text object.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;returns&gt;&lt;/returns&gt;</comment>
        <function><specifier>protected</specifier> <specifier>virtual</specifier> <type><name><name>Material</name><index>[]</index></name></type> <name>GetMaterials</name><parameter_list>(<parameter><decl><type><name><name>Material</name><index>[]</index></name></type> <name>mats</name></decl></parameter>)</parameter_list> <block>{ <return>return <expr><literal type="null">null</literal></expr>;</return> }</block></function>

        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Method to set the materials of the text and sub text objects.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;param name="mats"&gt;&lt;/param&gt;</comment>
        <comment type="line">//protected virtual void SetMaterials (Material[] mats) { }</comment>

        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Function used to create an instance of the material</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;param name="source"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;returns&gt;&lt;/returns&gt;</comment>
        <function><specifier>protected</specifier> <specifier>virtual</specifier> <type><name>Material</name></type> <name>CreateMaterialInstance</name><parameter_list>(<parameter><decl><type><name>Material</name></type> <name>source</name></decl></parameter>)</parameter_list>
        <block>{
            <decl_stmt><decl><type><name>Material</name></type> <name>mat</name> <init>= <expr><operator>new</operator> <call><name>Material</name><argument_list>(<argument><expr><name>source</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>mat</name><operator>.</operator><name>shaderKeywords</name></name> <operator>=</operator> <name><name>source</name><operator>.</operator><name>shaderKeywords</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>mat</name><operator>.</operator><name>name</name></name> <operator>+=</operator> <literal type="string">" (Instance)"</literal></expr>;</expr_stmt>

            <return>return <expr><name>mat</name></expr>;</return>
        }</block></function>

        <function><specifier>protected</specifier> <type><name>void</name></type> <name>SetVertexColorGradient</name><parameter_list>(<parameter><decl><type><name>TMP_ColorGradient</name></type> <name>gradient</name></decl></parameter>)</parameter_list>
        <block>{
            <if>if <condition>(<expr><name>gradient</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block type="pseudo"><return>return;</return></block></then></if>

            <expr_stmt><expr><name><name>m_fontColorGradient</name><operator>.</operator><name>bottomLeft</name></name> <operator>=</operator> <name><name>gradient</name><operator>.</operator><name>bottomLeft</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>m_fontColorGradient</name><operator>.</operator><name>bottomRight</name></name> <operator>=</operator> <name><name>gradient</name><operator>.</operator><name>bottomRight</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>m_fontColorGradient</name><operator>.</operator><name>topLeft</name></name> <operator>=</operator> <name><name>gradient</name><operator>.</operator><name>topLeft</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>m_fontColorGradient</name><operator>.</operator><name>topRight</name></name> <operator>=</operator> <name><name>gradient</name><operator>.</operator><name>topRight</name></name></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>SetVerticesDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></function>

        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Function to control the sorting of the geometry of the text object.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <function><specifier>protected</specifier> <type><name>void</name></type> <name>SetTextSortingOrder</name><parameter_list>(<parameter><decl><type><name>VertexSortingOrder</name></type> <name>order</name></decl></parameter>)</parameter_list>
        <block>{
            
        }</block></function>

        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Function to sort the geometry of the text object in accordance to the provided order.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;param name="order"&gt;&lt;/param&gt;</comment>
        <function><specifier>protected</specifier> <type><name>void</name></type> <name>SetTextSortingOrder</name><parameter_list>(<parameter><decl><type><name><name>int</name><index>[]</index></name></type> <name>order</name></decl></parameter>)</parameter_list>
        <block>{

        }</block></function>

        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Function called internally to set the face color of the material. This will results in an instance of the material.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;param name="color"&gt;&lt;/param&gt;</comment>
        <function><specifier>protected</specifier> <specifier>virtual</specifier> <type><name>void</name></type> <name>SetFaceColor</name><parameter_list>(<parameter><decl><type><name>Color32</name></type> <name>color</name></decl></parameter>)</parameter_list> <block>{ }</block></function>

        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Function called internally to set the outline color of the material. This will results in an instance of the material.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;param name="color"&gt;&lt;/param&gt;</comment>
        <function><specifier>protected</specifier> <specifier>virtual</specifier> <type><name>void</name></type> <name>SetOutlineColor</name><parameter_list>(<parameter><decl><type><name>Color32</name></type> <name>color</name></decl></parameter>)</parameter_list> <block>{ }</block></function>

        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Function called internally to set the outline thickness property of the material. This will results in an instance of the material.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;param name="thickness"&gt;&lt;/param&gt;</comment>
        <function><specifier>protected</specifier> <specifier>virtual</specifier> <type><name>void</name></type> <name>SetOutlineThickness</name><parameter_list>(<parameter><decl><type><name>float</name></type> <name>thickness</name></decl></parameter>)</parameter_list> <block>{ }</block></function>

        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Set the Render Queue and ZTest mode on the current material</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <function><specifier>protected</specifier> <specifier>virtual</specifier> <type><name>void</name></type> <name>SetShaderDepth</name><parameter_list>()</parameter_list> <block>{ }</block></function>

        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Set the culling mode on the material.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <function><specifier>protected</specifier> <specifier>virtual</specifier> <type><name>void</name></type> <name>SetCulling</name><parameter_list>()</parameter_list> <block>{ }</block></function>

        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Get the padding value for the currently assigned material</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;returns&gt;&lt;/returns&gt;</comment>
        <function><specifier>protected</specifier> <specifier>virtual</specifier> <type><name>float</name></type> <name>GetPaddingForMaterial</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><literal type="number">0</literal></expr>;</return> }</block></function>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Get the padding value for the given material</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;returns&gt;&lt;/returns&gt;</comment>
        <function><specifier>protected</specifier> <specifier>virtual</specifier> <type><name>float</name></type> <name>GetPaddingForMaterial</name><parameter_list>(<parameter><decl><type><name>Material</name></type> <name>mat</name></decl></parameter>)</parameter_list> <block>{ <return>return <expr><literal type="number">0</literal></expr>;</return> }</block></function>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Method to return the local corners of the Text Container or RectTransform.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;returns&gt;&lt;/returns&gt;</comment>
        <function><specifier>protected</specifier> <specifier>virtual</specifier> <type><name><name>Vector3</name><index>[]</index></name></type> <name>GetTextContainerLocalCorners</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><literal type="null">null</literal></expr>;</return> }</block></function>


        <comment type="line">// PUBLIC FUNCTIONS</comment>
        <decl_stmt><decl><specifier>protected</specifier> <type><name>bool</name></type> <name>m_ignoreActiveState</name></decl>;</decl_stmt>
        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Function to force the regeneration of the text object.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <function><specifier>public</specifier> <specifier>virtual</specifier> <type><name>void</name></type> <name>ForceMeshUpdate</name><parameter_list>()</parameter_list> <block>{ }</block></function>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Method used for resetting vertex layout when switching to and from Volumetric Text mode.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;param name="updateMesh"&gt;&lt;/param&gt;</comment>
        <comment type="line">//protected virtual void ResetVertexLayout() { }</comment>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Function to force the regeneration of the text object.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;param name="ignoreActiveState"&gt;If set to true, the text object will be regenerated regardless of is active state.&lt;/param&gt;</comment>
        <function><specifier>public</specifier> <specifier>virtual</specifier> <type><name>void</name></type> <name>ForceMeshUpdate</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>ignoreActiveState</name></decl></parameter>)</parameter_list> <block>{ }</block></function>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Internal function used by the Text Input Field to populate TMP_TextInfo data. </comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <function><specifier>internal</specifier> <type><name>void</name></type> <name>SetTextInternal</name><parameter_list>(<parameter><decl><type><name>string</name></type> <name>text</name></decl></parameter>)</parameter_list>
        <block>{
            <expr_stmt><expr><name>m_text</name> <operator>=</operator> <name>text</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>m_renderMode</name> <operator>=</operator> <name><name>TextRenderFlags</name><operator>.</operator><name>DontRender</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>m_isInputParsingRequired</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ForceMeshUpdate</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>m_renderMode</name> <operator>=</operator> <name><name>TextRenderFlags</name><operator>.</operator><name>Render</name></name></expr>;</expr_stmt>
        }</block></function>

        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Function to force the regeneration of the text object.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;param name="flags"&gt; Flags to control which portions of the geometry gets uploaded.&lt;/param&gt;</comment>
        <comment type="line">//public virtual void ForceMeshUpdate(TMP_VertexDataUpdateFlags flags) { }</comment>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Function to update the geometry of the main and sub text objects.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;param name="mesh"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="index"&gt;&lt;/param&gt;</comment>
        <function><specifier>public</specifier> <specifier>virtual</specifier> <type><name>void</name></type> <name>UpdateGeometry</name><parameter_list>(<parameter><decl><type><name>Mesh</name></type> <name>mesh</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>index</name></decl></parameter>)</parameter_list> <block>{ }</block></function>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Function to push the updated vertex data into the mesh and renderer.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <function><specifier>public</specifier> <specifier>virtual</specifier> <type><name>void</name></type> <name>UpdateVertexData</name><parameter_list>(<parameter><decl><type><name>TMP_VertexDataUpdateFlags</name></type> <name>flags</name></decl></parameter>)</parameter_list> <block>{ }</block></function>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Function to push the updated vertex data into the mesh and renderer.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <function><specifier>public</specifier> <specifier>virtual</specifier> <type><name>void</name></type> <name>UpdateVertexData</name><parameter_list>()</parameter_list> <block>{ }</block></function>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Function to push a new set of vertices to the mesh.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;param name="vertices"&gt;&lt;/param&gt;</comment>
        <function><specifier>public</specifier> <specifier>virtual</specifier> <type><name>void</name></type> <name>SetVertices</name><parameter_list>(<parameter><decl><type><name><name>Vector3</name><index>[]</index></name></type> <name>vertices</name></decl></parameter>)</parameter_list> <block>{ }</block></function>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Function to be used to force recomputing of character padding when Shader / Material properties have been changed via script.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <function><specifier>public</specifier> <specifier>virtual</specifier> <type><name>void</name></type> <name>UpdateMeshPadding</name><parameter_list>()</parameter_list> <block>{ }</block></function>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// </comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">//public virtual new void UpdateGeometry() { }</comment>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Tweens the CanvasRenderer color associated with this Graphic.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;param name="targetColor"&gt;Target color.&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="duration"&gt;Tween duration.&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="ignoreTimeScale"&gt;Should ignore Time.scale?&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="useAlpha"&gt;Should also Tween the alpha channel?&lt;/param&gt;</comment>
        <function><specifier>public</specifier> <specifier>override</specifier> <type><name>void</name></type> <name>CrossFadeColor</name><parameter_list>(<parameter><decl><type><name>Color</name></type> <name>targetColor</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>duration</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>ignoreTimeScale</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>useAlpha</name></decl></parameter>)</parameter_list>
        <block>{
            <expr_stmt><expr><call><name><name>base</name><operator>.</operator><name>CrossFadeColor</name></name><argument_list>(<argument><expr><name>targetColor</name></expr></argument>, <argument><expr><name>duration</name></expr></argument>, <argument><expr><name>ignoreTimeScale</name></expr></argument>, <argument><expr><name>useAlpha</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>InternalCrossFadeColor</name><argument_list>(<argument><expr><name>targetColor</name></expr></argument>, <argument><expr><name>duration</name></expr></argument>, <argument><expr><name>ignoreTimeScale</name></expr></argument>, <argument><expr><name>useAlpha</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></function>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Tweens the alpha of the CanvasRenderer color associated with this Graphic.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;param name="alpha"&gt;Target alpha.&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="duration"&gt;Duration of the tween in seconds.&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="ignoreTimeScale"&gt;Should ignore Time.scale?&lt;/param&gt;</comment>
        <function><specifier>public</specifier> <specifier>override</specifier> <type><name>void</name></type> <name>CrossFadeAlpha</name><parameter_list>(<parameter><decl><type><name>float</name></type> <name>alpha</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>duration</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>ignoreTimeScale</name></decl></parameter>)</parameter_list>
        <block>{
            <expr_stmt><expr><call><name><name>base</name><operator>.</operator><name>CrossFadeAlpha</name></name><argument_list>(<argument><expr><name>alpha</name></expr></argument>, <argument><expr><name>duration</name></expr></argument>, <argument><expr><name>ignoreTimeScale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>InternalCrossFadeAlpha</name><argument_list>(<argument><expr><name>alpha</name></expr></argument>, <argument><expr><name>duration</name></expr></argument>, <argument><expr><name>ignoreTimeScale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></function>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// </comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;param name="targetColor"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="duration"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="ignoreTimeScale"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="useAlpha"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="useRGB"&gt;&lt;/param&gt;</comment>
        <function><specifier>protected</specifier> <specifier>virtual</specifier> <type><name>void</name></type> <name>InternalCrossFadeColor</name><parameter_list>(<parameter><decl><type><name>Color</name></type> <name>targetColor</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>duration</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>ignoreTimeScale</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>useAlpha</name></decl></parameter>)</parameter_list> <block>{ }</block></function>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// </comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;param name="alpha"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="duration"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="ignoreTimeScale"&gt;&lt;/param&gt;</comment>
        <function><specifier>protected</specifier> <specifier>virtual</specifier> <type><name>void</name></type> <name>InternalCrossFadeAlpha</name><parameter_list>(<parameter><decl><type><name>float</name></type> <name>alpha</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>duration</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>ignoreTimeScale</name></decl></parameter>)</parameter_list> <block>{ }</block></function>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Method to parse the input text based on its source</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <function><specifier>protected</specifier> <type><name>void</name></type> <name>ParseInputText</name><parameter_list>()</parameter_list>
        <block>{
            <comment type="line">//Debug.Log("Re-parsing Text.");</comment>
            <comment type="line">////Profiler.BeginSample("ParseInputText()");</comment>

            <expr_stmt><expr><name>m_isInputParsingRequired</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>

            <switch>switch <condition>(<expr><name>m_inputSource</name></expr>)</condition>
            <block>{
                <case>case <expr><name><name>TextInputSources</name><operator>.</operator><name>String</name></name></expr>:</case>
                <case>case <expr><name><name>TextInputSources</name><operator>.</operator><name>Text</name></name></expr>:</case>
                    <expr_stmt><expr><call><name>StringToCharArray</name><argument_list>(<argument><expr><name>m_text</name></expr></argument>, <argument><modifier>ref</modifier> <expr><name>m_char_buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><name><name>TextInputSources</name><operator>.</operator><name>SetText</name></name></expr>:</case>
                    <expr_stmt><expr><call><name>SetTextArrayToCharArray</name><argument_list>(<argument><expr><name>m_input_CharArray</name></expr></argument>, <argument><modifier>ref</modifier> <expr><name>m_char_buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><name><name>TextInputSources</name><operator>.</operator><name>SetCharArray</name></name></expr>:</case>
                    <break>break;</break>
            }</block></switch>

            <expr_stmt><expr><call><name>SetArraySizes</name><argument_list>(<argument><expr><name>m_char_buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="line">////Profiler.EndSample();</comment>
        }</block></function>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// </comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;param name="text"&gt;&lt;/param&gt;</comment>
        <function><specifier>public</specifier> <type><name>void</name></type> <name>SetText</name><parameter_list>(<parameter><decl><type><name>string</name></type> <name>text</name></decl></parameter>)</parameter_list>
        <block>{
            <expr_stmt><expr><call><name>SetText</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></function>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// </comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;param name="text"&gt;&lt;/param&gt;</comment>
        <function><specifier>public</specifier> <type><name>void</name></type> <name>SetText</name><parameter_list>(<parameter><decl><type><name>string</name></type> <name>text</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>syncTextInputBox</name></decl></parameter>)</parameter_list>
        <block>{
            <comment type="line">//if (text == old_text) return;</comment>

            <comment type="line">//old_text = text;</comment>

            <expr_stmt><expr><name>m_inputSource</name> <operator>=</operator> <name><name>TextInputSources</name><operator>.</operator><name>SetCharArray</name></name></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>StringToCharArray</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><modifier>ref</modifier> <expr><name>m_char_buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>UNITY_EDITOR</name></expr></cpp:if>
            <comment type="line">// Set the text in the Text Input Box in the Unity Editor only.</comment>
            <comment type="line">// TODO: Could revise to convert to string literal</comment>
            <if>if <condition>(<expr><name>syncTextInputBox</name></expr>)</condition><then>
                <block type="pseudo"><expr_stmt><expr><name>m_text</name> <operator>=</operator> <name>text</name></expr>;</expr_stmt></block></then></if>
            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <expr_stmt><expr><name>m_isInputParsingRequired</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>m_havePropertiesChanged</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>m_isCalculateSizeRequired</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>SetVerticesDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SetLayoutDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></function>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// &lt;para&gt;Formatted string containing a pattern and a value representing the text to be rendered.&lt;/para&gt;</comment>
        <comment type="line">/// &lt;para&gt;ex. TextMeshPro.SetText ("Number is {0:1}.", 5.56f);&lt;/para&gt;</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;typeparam name="T"&gt;&lt;/typeparam&gt;</comment>
        <comment type="line">/// &lt;param name="text"&gt;String containing the pattern."&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="arg0"&gt;Value is a float.&lt;/param&gt;</comment>
        <function><specifier>public</specifier> <type><name>void</name></type> <name>SetText</name><parameter_list>(<parameter><decl><type><name>string</name></type> <name>text</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>arg0</name></decl></parameter>)</parameter_list>
        <block>{
            <expr_stmt><expr><call><name>SetText</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>arg0</name></expr></argument>, <argument><expr><literal type="number">255</literal></expr></argument>, <argument><expr><literal type="number">255</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></function>

        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// &lt;para&gt;Formatted string containing a pattern and a value representing the text to be rendered.&lt;/para&gt;</comment>
        <comment type="line">/// &lt;para&gt;ex. TextMeshPro.SetText ("First number is {0} and second is {1:2}.", 10, 5.756f);&lt;/para&gt;</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;typeparam name="T"&gt;&lt;/typeparam&gt;</comment>
        <comment type="line">/// &lt;param name="text"&gt;String containing the pattern."&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="arg0"&gt;Value is a float.&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="arg1"&gt;Value is a float.&lt;/param&gt;</comment>
        <function><specifier>public</specifier> <type><name>void</name></type> <name>SetText</name><parameter_list>(<parameter><decl><type><name>string</name></type> <name>text</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>arg0</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>arg1</name></decl></parameter>)</parameter_list>
        <block>{
            <expr_stmt><expr><call><name>SetText</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>arg0</name></expr></argument>, <argument><expr><name>arg1</name></expr></argument>, <argument><expr><literal type="number">255</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></function>

        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// &lt;para&gt;Formatted string containing a pattern and a value representing the text to be rendered.&lt;/para&gt;</comment>
        <comment type="line">/// &lt;para&gt;ex. TextMeshPro.SetText ("A = {0}, B = {1} and C = {2}.", 2, 5, 7);&lt;/para&gt;</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;typeparam name="T"&gt;&lt;/typeparam&gt;</comment>
        <comment type="line">/// &lt;param name="text"&gt;String containing the pattern."&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="arg0"&gt;Value is a float.&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="arg1"&gt;Value is a float.&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="arg2"&gt;Value is a float.&lt;/param&gt;</comment>
        <function><specifier>public</specifier> <type><name>void</name></type> <name>SetText</name><parameter_list>(<parameter><decl><type><name>string</name></type> <name>text</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>arg0</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>arg1</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>arg2</name></decl></parameter>)</parameter_list>
        <block>{
            <comment type="line">// Early out if nothing has been changed from previous invocation.</comment>
            <comment type="line">//if (text == old_text &amp;&amp; arg0 == old_arg0 &amp;&amp; arg1 == old_arg1 &amp;&amp; arg2 == old_arg2)</comment>
            <comment type="line">//{</comment>
            <comment type="line">//    return;</comment>
            <comment type="line">//}</comment>

            <comment type="line">//old_text = text;</comment>
            <comment type="line">//old_arg1 = 255;</comment>
            <comment type="line">//old_arg2 = 255;</comment>

            <decl_stmt><decl><type><name>int</name></type> <name>decimalPrecision</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>text</name><operator>.</operator><name>Length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{
                <decl_stmt><decl><type><name>char</name></type> <name>c</name> <init>= <expr><name><name>text</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

                <if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="number">123</literal></expr>)</condition><then> <comment type="line">// '{'</comment>
                <block>{
                    <comment type="line">// Check if user is requesting some decimal precision. Format is {0:2}</comment>
                    <if>if <condition>(<expr><name><name>text</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="number">58</literal></expr>)</condition><then> <comment type="line">// ':'</comment>
                    <block>{
                        <expr_stmt><expr><name>decimalPrecision</name> <operator>=</operator> <name><name>text</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">3</literal></expr>]</index></name> <operator>-</operator> <literal type="number">48</literal></expr>;</expr_stmt>
                    }</block></then></if>

                    <switch>switch <condition>(<expr><name><name>text</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <literal type="number">48</literal></expr>)</condition>
                    <block>{
                        <case>case <expr><literal type="number">0</literal></expr>:</case> <comment type="line">// 1st Arg</comment>
                            <comment type="line">//old_arg0 = arg0;</comment>
                            <expr_stmt><expr><call><name>AddFloatToCharArray</name><argument_list>(<argument><expr><name>arg0</name></expr></argument>, <argument><modifier>ref</modifier> <expr><name>index</name></expr></argument>, <argument><expr><name>decimalPrecision</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <break>break;</break>
                        <case>case <expr><literal type="number">1</literal></expr>:</case> <comment type="line">// 2nd Arg</comment>
                            <comment type="line">//old_arg1 = arg1;</comment>
                            <expr_stmt><expr><call><name>AddFloatToCharArray</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><modifier>ref</modifier> <expr><name>index</name></expr></argument>, <argument><expr><name>decimalPrecision</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <break>break;</break>
                        <case>case <expr><literal type="number">2</literal></expr>:</case> <comment type="line">// 3rd Arg</comment>
                            <comment type="line">//old_arg2 = arg2;</comment>
                            <expr_stmt><expr><call><name>AddFloatToCharArray</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>, <argument><modifier>ref</modifier> <expr><name>index</name></expr></argument>, <argument><expr><name>decimalPrecision</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <break>break;</break>
                    }</block></switch>

                    <if>if <condition>(<expr><name><name>text</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="number">58</literal></expr>)</condition><then>
                        <block type="pseudo"><expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt></block></then>
                    <else>else
                        <block type="pseudo"><expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block></else></if>

                    <continue>continue;</continue>
                }</block></then></if>
                <expr_stmt><expr><name><name>m_input_CharArray</name><index>[<expr><name>index</name></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>index</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            }</block></for>

            <expr_stmt><expr><name><name>m_input_CharArray</name><index>[<expr><name>index</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>m_charArray_Length</name> <operator>=</operator> <name>index</name></expr>;</expr_stmt> <comment type="line">// Set the length to where this '0' termination is.</comment>

            <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>UNITY_EDITOR</name></expr></cpp:if>
            <comment type="line">// Create new string to be displayed in the Input Text Box of the Editor Panel.</comment>
            <expr_stmt><expr><name>m_text</name> <operator>=</operator> <operator>new</operator> <call><name>string</name><argument_list>(<argument><expr><name>m_input_CharArray</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <expr_stmt><expr><name>m_inputSource</name> <operator>=</operator> <name><name>TextInputSources</name><operator>.</operator><name>SetText</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>m_isInputParsingRequired</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>m_havePropertiesChanged</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>m_isCalculateSizeRequired</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>SetVerticesDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SetLayoutDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></function>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Set the text using a StringBuilder.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;description&gt;</comment>
        <comment type="line">/// Using a StringBuilder instead of concatenating strings prevents memory pollution with temporary objects.</comment>
        <comment type="line">/// &lt;/description&gt;</comment>
        <comment type="line">/// &lt;param name="text"&gt;StringBuilder with text to display.&lt;/param&gt;</comment>
        <function><specifier>public</specifier> <type><name>void</name></type> <name>SetText</name><parameter_list>(<parameter><decl><type><name>StringBuilder</name></type> <name>text</name></decl></parameter>)</parameter_list>
        <block>{
            <expr_stmt><expr><name>m_inputSource</name> <operator>=</operator> <name><name>TextInputSources</name><operator>.</operator><name>SetCharArray</name></name></expr>;</expr_stmt>

            <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>UNITY_EDITOR</name></expr></cpp:if>
            <comment type="line">// Set the text in the Text Input Box in the Unity Editor only.</comment>
            <expr_stmt><expr><name>m_text</name> <operator>=</operator> <call><name><name>text</name><operator>.</operator><name>ToString</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <expr_stmt><expr><call><name>StringBuilderToIntArray</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><modifier>ref</modifier> <expr><name>m_char_buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>m_isInputParsingRequired</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>m_havePropertiesChanged</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>m_isCalculateSizeRequired</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>SetVerticesDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SetLayoutDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></function>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Character array containing the text to be displayed.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;param name="sourceText"&gt;&lt;/param&gt;</comment>
        <function><specifier>public</specifier> <type><name>void</name></type> <name>SetCharArray</name><parameter_list>(<parameter><decl><type><name><name>char</name><index>[]</index></name></type> <name>sourceText</name></decl></parameter>)</parameter_list>
        <block>{
            <comment type="line">// Initialize internal character buffer if necessary</comment>
            <if>if <condition>(<expr><name>m_char_buffer</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><name>m_char_buffer</name> <operator>=</operator> <operator>new</operator> <name><name>int</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></expr>;</expr_stmt></block></then></if>

            <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>UNITY_EDITOR</name></expr></cpp:if>
            <comment type="line">// Create new string to be displayed in the Input Text Box of the Editor Panel.</comment>
            <if>if <condition>(<expr><name>sourceText</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name><name>sourceText</name><operator>.</operator><name>Length</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then>
                <block type="pseudo"><expr_stmt><expr><name>m_text</name> <operator>=</operator> <name><name>string</name><operator>.</operator><name>Empty</name></name></expr>;</expr_stmt></block></then>
            <else>else
                <block type="pseudo"><expr_stmt><expr><name>m_text</name> <operator>=</operator> <operator>new</operator> <call><name>string</name><argument_list>(<argument><expr><name>sourceText</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block></else></if>
            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <comment type="line">// Clear the Style stack.</comment>
            <expr_stmt><expr><call><name><name>m_styleStack</name><operator>.</operator><name>Clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <decl_stmt><decl><type><name>int</name></type> <name>writeIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>sourceText</name> <operator>!=</operator> <literal type="null">null</literal> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name><name>sourceText</name><operator>.</operator><name>Length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{
                <if>if <condition>(<expr><name><name>sourceText</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="number">92</literal> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name><name>sourceText</name><operator>.</operator><name>Length</name></name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><then>
                <block>{
                    <switch>switch <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator><name><name>sourceText</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition>
                    <block>{
                        <case>case <expr><literal type="number">110</literal></expr>:</case> <comment type="line">// \n LineFeed</comment>
                            <if>if <condition>(<expr><name>writeIndex</name> <operator>==</operator> <name><name>m_char_buffer</name><operator>.</operator><name>Length</name></name></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><call><name>ResizeInternalArray</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>m_char_buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block></then></if>

                            <expr_stmt><expr><name><name>m_char_buffer</name><index>[<expr><name>writeIndex</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><literal type="number">10</literal></expr>;</expr_stmt>
                            <expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                            <expr_stmt><expr><name>writeIndex</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                            <continue>continue;</continue>
                        <case>case <expr><literal type="number">114</literal></expr>:</case> <comment type="line">// \r LineFeed</comment>
                            <if>if <condition>(<expr><name>writeIndex</name> <operator>==</operator> <name><name>m_char_buffer</name><operator>.</operator><name>Length</name></name></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><call><name>ResizeInternalArray</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>m_char_buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block></then></if>

                            <expr_stmt><expr><name><name>m_char_buffer</name><index>[<expr><name>writeIndex</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><literal type="number">13</literal></expr>;</expr_stmt>
                            <expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                            <expr_stmt><expr><name>writeIndex</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                            <continue>continue;</continue>
                        <case>case <expr><literal type="number">116</literal></expr>:</case> <comment type="line">// \t Tab</comment>
                            <if>if <condition>(<expr><name>writeIndex</name> <operator>==</operator> <name><name>m_char_buffer</name><operator>.</operator><name>Length</name></name></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><call><name>ResizeInternalArray</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>m_char_buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block></then></if>

                            <expr_stmt><expr><name><name>m_char_buffer</name><index>[<expr><name>writeIndex</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><literal type="number">9</literal></expr>;</expr_stmt>
                            <expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                            <expr_stmt><expr><name>writeIndex</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                            <continue>continue;</continue>
                    }</block></switch>
                }</block></then></if>

                <comment type="line">// Handle inline replacement of &lt;stlye&gt; and &lt;br&gt; tags.</comment>
                <if>if <condition>(<expr><name><name>sourceText</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="number">60</literal></expr>)</condition><then>
                <block>{
                    <if>if <condition>(<expr><call><name>IsTagName</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>sourceText</name></expr></argument>, <argument><expr><literal type="string">"&lt;BR&gt;"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <block>{
                        <if>if <condition>(<expr><name>writeIndex</name> <operator>==</operator> <name><name>m_char_buffer</name><operator>.</operator><name>Length</name></name></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><call><name>ResizeInternalArray</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>m_char_buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block></then></if>

                        <expr_stmt><expr><name><name>m_char_buffer</name><index>[<expr><name>writeIndex</name></expr>]</index></name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt> <empty_stmt>;</empty_stmt>
                        <expr_stmt><expr><name>writeIndex</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                        <expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>

                        <continue>continue;</continue>
                    }</block></then>
                    <elseif>else <if>if <condition>(<expr><call><name>IsTagName</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>sourceText</name></expr></argument>, <argument><expr><literal type="string">"&lt;STYLE="</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <block>{
                        <decl_stmt><decl><type><name>int</name></type> <name>srcOffset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                        <if>if <condition>(<expr><call><name>ReplaceOpeningStyleTag</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>sourceText</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><modifier>out</modifier> <expr><name>srcOffset</name></expr></argument>, <argument><modifier>ref</modifier> <expr><name>m_char_buffer</name></expr></argument>, <argument><modifier>ref</modifier> <expr><name>writeIndex</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                        <block>{
                            <expr_stmt><expr><name>i</name> <operator>=</operator> <name>srcOffset</name></expr>;</expr_stmt>
                            <continue>continue;</continue>
                        }</block></then></if>
                    }</block></then></if></elseif>
                    <elseif>else <if>if <condition>(<expr><call><name>IsTagName</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>sourceText</name></expr></argument>, <argument><expr><literal type="string">"&lt;/STYLE&gt;"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <block>{
                        <expr_stmt><expr><call><name>ReplaceClosingStyleTag</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>sourceText</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><modifier>ref</modifier> <expr><name>m_char_buffer</name></expr></argument>, <argument><modifier>ref</modifier> <expr><name>writeIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <comment type="line">// Strip &lt;/style&gt; even if style is invalid.</comment>
                        <expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">7</literal></expr>;</expr_stmt>
                        <continue>continue;</continue>
                    }</block></then></if></elseif></if>
                }</block></then></if>

                <if>if <condition>(<expr><name>writeIndex</name> <operator>==</operator> <name><name>m_char_buffer</name><operator>.</operator><name>Length</name></name></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><call><name>ResizeInternalArray</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>m_char_buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block></then></if>

                <expr_stmt><expr><name><name>m_char_buffer</name><index>[<expr><name>writeIndex</name></expr>]</index></name> <operator>=</operator> <name><name>sourceText</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>writeIndex</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            }</block></for>

            <if>if <condition>(<expr><name>writeIndex</name> <operator>==</operator> <name><name>m_char_buffer</name><operator>.</operator><name>Length</name></name></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><call><name>ResizeInternalArray</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>m_char_buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block></then></if>

            <expr_stmt><expr><name><name>m_char_buffer</name><index>[<expr><name>writeIndex</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><literal type="number">0</literal></expr>;</expr_stmt>

            <expr_stmt><expr><name>m_inputSource</name> <operator>=</operator> <name><name>TextInputSources</name><operator>.</operator><name>SetCharArray</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>m_isInputParsingRequired</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>m_havePropertiesChanged</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>m_isCalculateSizeRequired</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>SetVerticesDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SetLayoutDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></function>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Character array containing the text to be displayed.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;param name="sourceText"&gt;&lt;/param&gt;</comment>
        <function><specifier>public</specifier> <type><name>void</name></type> <name>SetCharArray</name><parameter_list>(<parameter><decl><type><name><name>char</name><index>[]</index></name></type> <name>sourceText</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>start</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>length</name></decl></parameter>)</parameter_list>
        <block>{
            <comment type="line">// Initialize internal character buffer if necessary</comment>
            <if>if <condition>(<expr><name>m_char_buffer</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><name>m_char_buffer</name> <operator>=</operator> <operator>new</operator> <name><name>int</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></expr>;</expr_stmt></block></then></if>

            <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>UNITY_EDITOR</name></expr></cpp:if>
            <comment type="line">// Create new string to be displayed in the Input Text Box of the Editor Panel.</comment>
            <if>if <condition>(<expr><name>sourceText</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name><name>sourceText</name><operator>.</operator><name>Length</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>length</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then>
            <block>{
                <expr_stmt><expr><name>m_text</name> <operator>=</operator> <name><name>string</name><operator>.</operator><name>Empty</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>start</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>length</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            }</block></then>
            <else>else
            <block>{
                <comment type="line">// TODO: Add potential range check on start + length relative to array size.</comment>
                <expr_stmt><expr><name>m_text</name> <operator>=</operator> <operator>new</operator> <call><name>string</name><argument_list>(<argument><expr><name>sourceText</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <comment type="line">// Clear the Style stack.</comment>
            <expr_stmt><expr><call><name><name>m_styleStack</name><operator>.</operator><name>Clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <decl_stmt><decl><type><name>int</name></type> <name>writeIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

            <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>start</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>end</name> <init>= <expr><name>start</name> <operator>+</operator> <name>length</name></expr></init></decl>;</decl_stmt>
            <for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>end</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{
                <if>if <condition>(<expr><name><name>sourceText</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="number">92</literal> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name>length</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><then>
                <block>{
                    <switch>switch <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator><name><name>sourceText</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition>
                    <block>{
                        <case>case <expr><literal type="number">110</literal></expr>:</case> <comment type="line">// \n LineFeed</comment>
                            <if>if <condition>(<expr><name>writeIndex</name> <operator>==</operator> <name><name>m_char_buffer</name><operator>.</operator><name>Length</name></name></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><call><name>ResizeInternalArray</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>m_char_buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block></then></if>

                            <expr_stmt><expr><name><name>m_char_buffer</name><index>[<expr><name>writeIndex</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><literal type="number">10</literal></expr>;</expr_stmt>
                            <expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                            <expr_stmt><expr><name>writeIndex</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                            <continue>continue;</continue>
                        <case>case <expr><literal type="number">114</literal></expr>:</case> <comment type="line">// \r LineFeed</comment>
                            <if>if <condition>(<expr><name>writeIndex</name> <operator>==</operator> <name><name>m_char_buffer</name><operator>.</operator><name>Length</name></name></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><call><name>ResizeInternalArray</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>m_char_buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block></then></if>

                            <expr_stmt><expr><name><name>m_char_buffer</name><index>[<expr><name>writeIndex</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><literal type="number">13</literal></expr>;</expr_stmt>
                            <expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                            <expr_stmt><expr><name>writeIndex</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                            <continue>continue;</continue>
                        <case>case <expr><literal type="number">116</literal></expr>:</case> <comment type="line">// \t Tab</comment>
                            <if>if <condition>(<expr><name>writeIndex</name> <operator>==</operator> <name><name>m_char_buffer</name><operator>.</operator><name>Length</name></name></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><call><name>ResizeInternalArray</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>m_char_buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block></then></if>

                            <expr_stmt><expr><name><name>m_char_buffer</name><index>[<expr><name>writeIndex</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><literal type="number">9</literal></expr>;</expr_stmt>
                            <expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                            <expr_stmt><expr><name>writeIndex</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                            <continue>continue;</continue>
                    }</block></switch>
                }</block></then></if>

                <comment type="line">// Handle inline replacement of &lt;stlye&gt; and &lt;br&gt; tags.</comment>
                <if>if <condition>(<expr><name><name>sourceText</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="number">60</literal></expr>)</condition><then>
                <block>{
                    <if>if <condition>(<expr><call><name>IsTagName</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>sourceText</name></expr></argument>, <argument><expr><literal type="string">"&lt;BR&gt;"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <block>{
                        <if>if <condition>(<expr><name>writeIndex</name> <operator>==</operator> <name><name>m_char_buffer</name><operator>.</operator><name>Length</name></name></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><call><name>ResizeInternalArray</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>m_char_buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block></then></if>

                        <expr_stmt><expr><name><name>m_char_buffer</name><index>[<expr><name>writeIndex</name></expr>]</index></name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt> <empty_stmt>;</empty_stmt>
                        <expr_stmt><expr><name>writeIndex</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                        <expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>

                        <continue>continue;</continue>
                    }</block></then>
                    <elseif>else <if>if <condition>(<expr><call><name>IsTagName</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>sourceText</name></expr></argument>, <argument><expr><literal type="string">"&lt;STYLE="</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <block>{
                        <decl_stmt><decl><type><name>int</name></type> <name>srcOffset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                        <if>if <condition>(<expr><call><name>ReplaceOpeningStyleTag</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>sourceText</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><modifier>out</modifier> <expr><name>srcOffset</name></expr></argument>, <argument><modifier>ref</modifier> <expr><name>m_char_buffer</name></expr></argument>, <argument><modifier>ref</modifier> <expr><name>writeIndex</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                        <block>{
                            <expr_stmt><expr><name>i</name> <operator>=</operator> <name>srcOffset</name></expr>;</expr_stmt>
                            <continue>continue;</continue>
                        }</block></then></if>
                    }</block></then></if></elseif>
                    <elseif>else <if>if <condition>(<expr><call><name>IsTagName</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>sourceText</name></expr></argument>, <argument><expr><literal type="string">"&lt;/STYLE&gt;"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <block>{
                        <expr_stmt><expr><call><name>ReplaceClosingStyleTag</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>sourceText</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><modifier>ref</modifier> <expr><name>m_char_buffer</name></expr></argument>, <argument><modifier>ref</modifier> <expr><name>writeIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <comment type="line">// Strip &lt;/style&gt; even if style is invalid.</comment>
                        <expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">7</literal></expr>;</expr_stmt>
                        <continue>continue;</continue>
                    }</block></then></if></elseif></if>
                }</block></then></if>

                <if>if <condition>(<expr><name>writeIndex</name> <operator>==</operator> <name><name>m_char_buffer</name><operator>.</operator><name>Length</name></name></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><call><name>ResizeInternalArray</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>m_char_buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block></then></if>

                <expr_stmt><expr><name><name>m_char_buffer</name><index>[<expr><name>writeIndex</name></expr>]</index></name> <operator>=</operator> <name><name>sourceText</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>writeIndex</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            }</block></for>

            <if>if <condition>(<expr><name>writeIndex</name> <operator>==</operator> <name><name>m_char_buffer</name><operator>.</operator><name>Length</name></name></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><call><name>ResizeInternalArray</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>m_char_buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block></then></if>

            <expr_stmt><expr><name><name>m_char_buffer</name><index>[<expr><name>writeIndex</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><literal type="number">0</literal></expr>;</expr_stmt>

            <expr_stmt><expr><name>m_inputSource</name> <operator>=</operator> <name><name>TextInputSources</name><operator>.</operator><name>SetCharArray</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>m_havePropertiesChanged</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>m_isInputParsingRequired</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>m_isCalculateSizeRequired</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>SetVerticesDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SetLayoutDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></function>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Character array containing the text to be displayed.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;param name="sourceText"&gt;&lt;/param&gt;</comment>
        <function><specifier>public</specifier> <type><name>void</name></type> <name>SetCharArray</name><parameter_list>(<parameter><decl><type><name><name>int</name><index>[]</index></name></type> <name>sourceText</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>start</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>length</name></decl></parameter>)</parameter_list>
        <block>{
            <comment type="line">// Initialize internal character buffer if necessary</comment>
            <if>if <condition>(<expr><name>m_char_buffer</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><name>m_char_buffer</name> <operator>=</operator> <operator>new</operator> <name><name>int</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></expr>;</expr_stmt></block></then></if>

            <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>UNITY_EDITOR</name></expr></cpp:if>
            <comment type="line">// Create new string to be displayed in the Input Text Box of the Editor Panel.</comment>
            <if>if <condition>(<expr><name>sourceText</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name><name>sourceText</name><operator>.</operator><name>Length</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>length</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then>
            <block>{
                <expr_stmt><expr><name>m_text</name> <operator>=</operator> <name><name>string</name><operator>.</operator><name>Empty</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>start</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>length</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            }</block></then>
            <else>else
            <block>{
                <expr_stmt><expr><name>m_text</name> <operator>=</operator> <call><name><name>sourceText</name><operator>.</operator><name>IntToString</name></name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <comment type="line">// Clear the Style stack.</comment>
            <expr_stmt><expr><call><name><name>m_styleStack</name><operator>.</operator><name>Clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <decl_stmt><decl><type><name>int</name></type> <name>writeIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

            <decl_stmt><decl><type><name>int</name></type> <name>end</name> <init>= <expr><name>start</name> <operator>+</operator> <name>length</name></expr></init></decl>;</decl_stmt>
            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>start</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>end</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{
                <if>if <condition>(<expr><name><name>sourceText</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="number">92</literal> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name>length</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><then>
                <block>{
                    <switch>switch <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator><name><name>sourceText</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition>
                    <block>{
                        <case>case <expr><literal type="number">110</literal></expr>:</case> <comment type="line">// \n LineFeed</comment>
                            <if>if <condition>(<expr><name>writeIndex</name> <operator>==</operator> <name><name>m_char_buffer</name><operator>.</operator><name>Length</name></name></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><call><name>ResizeInternalArray</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>m_char_buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block></then></if>

                            <expr_stmt><expr><name><name>m_char_buffer</name><index>[<expr><name>writeIndex</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><literal type="number">10</literal></expr>;</expr_stmt>
                            <expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                            <expr_stmt><expr><name>writeIndex</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                            <continue>continue;</continue>
                        <case>case <expr><literal type="number">114</literal></expr>:</case> <comment type="line">// \r LineFeed</comment>
                            <if>if <condition>(<expr><name>writeIndex</name> <operator>==</operator> <name><name>m_char_buffer</name><operator>.</operator><name>Length</name></name></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><call><name>ResizeInternalArray</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>m_char_buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block></then></if>

                            <expr_stmt><expr><name><name>m_char_buffer</name><index>[<expr><name>writeIndex</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><literal type="number">13</literal></expr>;</expr_stmt>
                            <expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                            <expr_stmt><expr><name>writeIndex</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                            <continue>continue;</continue>
                        <case>case <expr><literal type="number">116</literal></expr>:</case> <comment type="line">// \t Tab</comment>
                            <if>if <condition>(<expr><name>writeIndex</name> <operator>==</operator> <name><name>m_char_buffer</name><operator>.</operator><name>Length</name></name></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><call><name>ResizeInternalArray</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>m_char_buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block></then></if>

                            <expr_stmt><expr><name><name>m_char_buffer</name><index>[<expr><name>writeIndex</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><literal type="number">9</literal></expr>;</expr_stmt>
                            <expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                            <expr_stmt><expr><name>writeIndex</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                            <continue>continue;</continue>
                    }</block></switch>
                }</block></then></if>

                <comment type="line">// Handle inline replacement of &lt;stlye&gt; and &lt;br&gt; tags.</comment>
                <if>if <condition>(<expr><name><name>sourceText</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="number">60</literal></expr>)</condition><then>
                <block>{
                    <if>if <condition>(<expr><call><name>IsTagName</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>sourceText</name></expr></argument>, <argument><expr><literal type="string">"&lt;BR&gt;"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <block>{
                        <if>if <condition>(<expr><name>writeIndex</name> <operator>==</operator> <name><name>m_char_buffer</name><operator>.</operator><name>Length</name></name></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><call><name>ResizeInternalArray</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>m_char_buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block></then></if>

                        <expr_stmt><expr><name><name>m_char_buffer</name><index>[<expr><name>writeIndex</name></expr>]</index></name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt> <empty_stmt>;</empty_stmt>
                        <expr_stmt><expr><name>writeIndex</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                        <expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>

                        <continue>continue;</continue>
                    }</block></then>
                    <elseif>else <if>if <condition>(<expr><call><name>IsTagName</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>sourceText</name></expr></argument>, <argument><expr><literal type="string">"&lt;STYLE="</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <block>{
                        <decl_stmt><decl><type><name>int</name></type> <name>srcOffset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                        <if>if <condition>(<expr><call><name>ReplaceOpeningStyleTag</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>sourceText</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><modifier>out</modifier> <expr><name>srcOffset</name></expr></argument>, <argument><modifier>ref</modifier> <expr><name>m_char_buffer</name></expr></argument>, <argument><modifier>ref</modifier> <expr><name>writeIndex</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                        <block>{
                            <expr_stmt><expr><name>i</name> <operator>=</operator> <name>srcOffset</name></expr>;</expr_stmt>
                            <continue>continue;</continue>
                        }</block></then></if>
                    }</block></then></if></elseif>
                    <elseif>else <if>if <condition>(<expr><call><name>IsTagName</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>sourceText</name></expr></argument>, <argument><expr><literal type="string">"&lt;/STYLE&gt;"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <block>{
                        <expr_stmt><expr><call><name>ReplaceClosingStyleTag</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>sourceText</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><modifier>ref</modifier> <expr><name>m_char_buffer</name></expr></argument>, <argument><modifier>ref</modifier> <expr><name>writeIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <comment type="line">// Strip &lt;/style&gt; even if style is invalid.</comment>
                        <expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">7</literal></expr>;</expr_stmt>
                        <continue>continue;</continue>
                    }</block></then></if></elseif></if>
                }</block></then></if>

                <if>if <condition>(<expr><name>writeIndex</name> <operator>==</operator> <name><name>m_char_buffer</name><operator>.</operator><name>Length</name></name></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><call><name>ResizeInternalArray</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>m_char_buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block></then></if>

                <expr_stmt><expr><name><name>m_char_buffer</name><index>[<expr><name>writeIndex</name></expr>]</index></name> <operator>=</operator> <name><name>sourceText</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>writeIndex</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            }</block></for>

            <if>if <condition>(<expr><name>writeIndex</name> <operator>==</operator> <name><name>m_char_buffer</name><operator>.</operator><name>Length</name></name></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><call><name>ResizeInternalArray</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>m_char_buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block></then></if>

            <expr_stmt><expr><name><name>m_char_buffer</name><index>[<expr><name>writeIndex</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><literal type="number">0</literal></expr>;</expr_stmt>

            <expr_stmt><expr><name>m_inputSource</name> <operator>=</operator> <name><name>TextInputSources</name><operator>.</operator><name>SetCharArray</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>m_havePropertiesChanged</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>m_isInputParsingRequired</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>m_isCalculateSizeRequired</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>SetVerticesDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SetLayoutDirty</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></function>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Copies Content of formatted SetText() to charBuffer.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;param name="sourceText"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="charBuffer"&gt;&lt;/param&gt;</comment>
        <function><specifier>protected</specifier> <type><name>void</name></type> <name>SetTextArrayToCharArray</name><parameter_list>(<parameter><decl><type><name><name>char</name><index>[]</index></name></type> <name>sourceText</name></decl></parameter>, <parameter><decl><type><name><modifier>ref</modifier> <name>int</name><index>[]</index></name></type> <name>charBuffer</name></decl></parameter>)</parameter_list>
        <block>{
            <comment type="line">//Debug.Log("SetText Array to Char called.");</comment>
            <if>if <condition>(<expr><name>sourceText</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name>m_charArray_Length</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then>
                <block type="pseudo"><return>return;</return></block></then></if>

            <if>if <condition>(<expr><name>charBuffer</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><name>charBuffer</name> <operator>=</operator> <operator>new</operator> <name><name>int</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></expr>;</expr_stmt></block></then></if>

            <comment type="line">// Clear the Style stack.</comment>
            <expr_stmt><expr><call><name><name>m_styleStack</name><operator>.</operator><name>Clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <decl_stmt><decl><type><name>int</name></type> <name>writeIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>m_charArray_Length</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{
                <comment type="line">// Handle UTF-32 in the input text (string).</comment>
                <if>if <condition>(<expr><call><name><name>char</name><operator>.</operator><name>IsHighSurrogate</name></name><argument_list>(<argument><expr><name><name>sourceText</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>char</name><operator>.</operator><name>IsLowSurrogate</name></name><argument_list>(<argument><expr><name><name>sourceText</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <block>{
                    <if>if <condition>(<expr><name>writeIndex</name> <operator>==</operator> <name><name>charBuffer</name><operator>.</operator><name>Length</name></name></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><call><name>ResizeInternalArray</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>charBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block></then></if>

                    <expr_stmt><expr><name><name>charBuffer</name><index>[<expr><name>writeIndex</name></expr>]</index></name> <operator>=</operator> <call><name><name>char</name><operator>.</operator><name>ConvertToUtf32</name></name><argument_list>(<argument><expr><name><name>sourceText</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>sourceText</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><name>writeIndex</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                    <continue>continue;</continue>
                }</block></then></if>

                <comment type="line">// Handle inline replacement of &lt;stlye&gt; and &lt;br&gt; tags.</comment>
                <if>if <condition>(<expr><name><name>sourceText</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="number">60</literal></expr>)</condition><then>
                <block>{
                    <if>if <condition>(<expr><call><name>IsTagName</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>sourceText</name></expr></argument>, <argument><expr><literal type="string">"&lt;BR&gt;"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <block>{
                        <if>if <condition>(<expr><name>writeIndex</name> <operator>==</operator> <name><name>charBuffer</name><operator>.</operator><name>Length</name></name></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><call><name>ResizeInternalArray</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>charBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block></then></if>

                        <expr_stmt><expr><name><name>charBuffer</name><index>[<expr><name>writeIndex</name></expr>]</index></name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
                        <expr_stmt><expr><name>writeIndex</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                        <expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>

                        <continue>continue;</continue>
                    }</block></then>
                    <elseif>else <if>if <condition>(<expr><call><name>IsTagName</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>sourceText</name></expr></argument>, <argument><expr><literal type="string">"&lt;STYLE="</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <block>{
                        <decl_stmt><decl><type><name>int</name></type> <name>srcOffset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                        <if>if <condition>(<expr><call><name>ReplaceOpeningStyleTag</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>sourceText</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><modifier>out</modifier> <expr><name>srcOffset</name></expr></argument>, <argument><modifier>ref</modifier> <expr><name>charBuffer</name></expr></argument>, <argument><modifier>ref</modifier> <expr><name>writeIndex</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                        <block>{
                            <expr_stmt><expr><name>i</name> <operator>=</operator> <name>srcOffset</name></expr>;</expr_stmt>
                            <continue>continue;</continue>
                        }</block></then></if>
                    }</block></then></if></elseif>
                    <elseif>else <if>if <condition>(<expr><call><name>IsTagName</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>sourceText</name></expr></argument>, <argument><expr><literal type="string">"&lt;/STYLE&gt;"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <block>{
                        <expr_stmt><expr><call><name>ReplaceClosingStyleTag</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>sourceText</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><modifier>ref</modifier> <expr><name>charBuffer</name></expr></argument>, <argument><modifier>ref</modifier> <expr><name>writeIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <comment type="line">// Strip &lt;/style&gt; even if style is invalid.</comment>
                        <expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">7</literal></expr>;</expr_stmt>
                        <continue>continue;</continue>
                    }</block></then></if></elseif></if>
                }</block></then></if>

                <if>if <condition>(<expr><name>writeIndex</name> <operator>==</operator> <name><name>charBuffer</name><operator>.</operator><name>Length</name></name></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><call><name>ResizeInternalArray</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>charBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block></then></if>

                <expr_stmt><expr><name><name>charBuffer</name><index>[<expr><name>writeIndex</name></expr>]</index></name> <operator>=</operator> <name><name>sourceText</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>writeIndex</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            }</block></for>

            <if>if <condition>(<expr><name>writeIndex</name> <operator>==</operator> <name><name>charBuffer</name><operator>.</operator><name>Length</name></name></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><call><name>ResizeInternalArray</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>charBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block></then></if>

            <expr_stmt><expr><name><name>charBuffer</name><index>[<expr><name>writeIndex</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        }</block></function>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Method to store the content of a string into an integer array.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;param name="sourceText"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="charBuffer"&gt;&lt;/param&gt;</comment>
        <function><specifier>protected</specifier> <type><name>void</name></type> <name>StringToCharArray</name><parameter_list>(<parameter><decl><type><name>string</name></type> <name>sourceText</name></decl></parameter>, <parameter><decl><type><name><modifier>ref</modifier> <name>int</name><index>[]</index></name></type> <name>charBuffer</name></decl></parameter>)</parameter_list>
        <block>{
            <if>if <condition>(<expr><name>sourceText</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then>
            <block>{
                <expr_stmt><expr><name><name>charBuffer</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <return>return;</return>
            }</block></then></if>

            <if>if <condition>(<expr><name>charBuffer</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><name>charBuffer</name> <operator>=</operator> <operator>new</operator> <name><name>int</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></expr>;</expr_stmt></block></then></if>

            <comment type="line">// Clear the Style stack.</comment>
            <expr_stmt><expr><call><name><name>m_styleStack</name><operator>.</operator><name>SetDefault</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <decl_stmt><decl><type><name>int</name></type> <name>writeIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>sourceText</name><operator>.</operator><name>Length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{
                <if>if <condition>(<expr><name>m_inputSource</name> <operator>==</operator> <name><name>TextInputSources</name><operator>.</operator><name>Text</name></name> <operator>&amp;&amp;</operator> <name><name>sourceText</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="number">92</literal> <operator>&amp;&amp;</operator> <name><name>sourceText</name><operator>.</operator><name>Length</name></name> <operator>&gt;</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition><then>
                <block>{
                    <switch>switch <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator><name><name>sourceText</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition>
                    <block>{
                        <case>case <expr><literal type="number">85</literal></expr>:</case> <comment type="line">// \U00000000 for UTF-32 Unicode</comment>
                            <if>if <condition>(<expr><name><name>sourceText</name><operator>.</operator><name>Length</name></name> <operator>&gt;</operator> <name>i</name> <operator>+</operator> <literal type="number">9</literal></expr>)</condition><then>
                            <block>{
                                <if>if <condition>(<expr><name>writeIndex</name> <operator>==</operator> <name><name>charBuffer</name><operator>.</operator><name>Length</name></name></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><call><name>ResizeInternalArray</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>charBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block></then></if>

                                <expr_stmt><expr><name><name>charBuffer</name><index>[<expr><name>writeIndex</name></expr>]</index></name> <operator>=</operator> <call><name>GetUTF32</name><argument_list>(<argument><expr><name>sourceText</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">9</literal></expr>;</expr_stmt>
                                <expr_stmt><expr><name>writeIndex</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                                <continue>continue;</continue>
                            }</block></then></if>
                            <break>break;</break>
                        <case>case <expr><literal type="number">92</literal></expr>:</case> <comment type="line">// \ escape</comment>
                            <if>if <condition>(<expr><operator>!</operator><name>m_parseCtrlCharacters</name></expr>)</condition><then> <block type="pseudo"><break>break;</break></block></then></if>

                            <if>if <condition>(<expr><name><name>sourceText</name><operator>.</operator><name>Length</name></name> <operator>&lt;=</operator> <name>i</name> <operator>+</operator> <literal type="number">2</literal></expr>)</condition><then> <block type="pseudo"><break>break;</break></block></then></if>

                            <if>if <condition>(<expr><name>writeIndex</name> <operator>+</operator> <literal type="number">2</literal> <operator>&gt;</operator> <name><name>charBuffer</name><operator>.</operator><name>Length</name></name></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><call><name>ResizeInternalArray</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>charBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block></then></if>

                            <expr_stmt><expr><name><name>charBuffer</name><index>[<expr><name>writeIndex</name></expr>]</index></name> <operator>=</operator> <name><name>sourceText</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>charBuffer</name><index>[<expr><name>writeIndex</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>sourceText</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
                            <expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
                            <expr_stmt><expr><name>writeIndex</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
                            <continue>continue;</continue>
                        <case>case <expr><literal type="number">110</literal></expr>:</case> <comment type="line">// \n LineFeed</comment>
                            <if>if <condition>(<expr><operator>!</operator><name>m_parseCtrlCharacters</name></expr>)</condition><then> <block type="pseudo"><break>break;</break></block></then></if>

                            <if>if <condition>(<expr><name>writeIndex</name> <operator>==</operator> <name><name>charBuffer</name><operator>.</operator><name>Length</name></name></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><call><name>ResizeInternalArray</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>charBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block></then></if>

                            <expr_stmt><expr><name><name>charBuffer</name><index>[<expr><name>writeIndex</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><literal type="number">10</literal></expr>;</expr_stmt>
                            <expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                            <expr_stmt><expr><name>writeIndex</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                            <continue>continue;</continue>
                        <case>case <expr><literal type="number">114</literal></expr>:</case> <comment type="line">// \r</comment>
                            <if>if <condition>(<expr><operator>!</operator><name>m_parseCtrlCharacters</name></expr>)</condition><then> <block type="pseudo"><break>break;</break></block></then></if>

                            <if>if <condition>(<expr><name>writeIndex</name> <operator>==</operator> <name><name>charBuffer</name><operator>.</operator><name>Length</name></name></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><call><name>ResizeInternalArray</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>charBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block></then></if>

                            <expr_stmt><expr><name><name>charBuffer</name><index>[<expr><name>writeIndex</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><literal type="number">13</literal></expr>;</expr_stmt>
                            <expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                            <expr_stmt><expr><name>writeIndex</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                            <continue>continue;</continue>
                        <case>case <expr><literal type="number">116</literal></expr>:</case> <comment type="line">// \t Tab</comment>
                            <if>if <condition>(<expr><operator>!</operator><name>m_parseCtrlCharacters</name></expr>)</condition><then> <block type="pseudo"><break>break;</break></block></then></if>

                            <if>if <condition>(<expr><name>writeIndex</name> <operator>==</operator> <name><name>charBuffer</name><operator>.</operator><name>Length</name></name></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><call><name>ResizeInternalArray</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>charBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block></then></if>

                            <expr_stmt><expr><name><name>charBuffer</name><index>[<expr><name>writeIndex</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><literal type="number">9</literal></expr>;</expr_stmt>
                            <expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                            <expr_stmt><expr><name>writeIndex</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                            <continue>continue;</continue>
                        <case>case <expr><literal type="number">117</literal></expr>:</case> <comment type="line">// \u0000 for UTF-16 Unicode</comment>
                            <if>if <condition>(<expr><name><name>sourceText</name><operator>.</operator><name>Length</name></name> <operator>&gt;</operator> <name>i</name> <operator>+</operator> <literal type="number">5</literal></expr>)</condition><then>
                            <block>{
                                <if>if <condition>(<expr><name>writeIndex</name> <operator>==</operator> <name><name>charBuffer</name><operator>.</operator><name>Length</name></name></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><call><name>ResizeInternalArray</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>charBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block></then></if>

                                <expr_stmt><expr><name><name>charBuffer</name><index>[<expr><name>writeIndex</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><call><name>GetUTF16</name><argument_list>(<argument><expr><name>sourceText</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">5</literal></expr>;</expr_stmt>
                                <expr_stmt><expr><name>writeIndex</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                                <continue>continue;</continue>
                            }</block></then></if>
                            <break>break;</break>
                    }</block></switch>
                }</block></then></if>

                <comment type="line">// Handle UTF-32 in the input text (string). // Not sure this is needed //</comment>
                <if>if <condition>(<expr><call><name><name>char</name><operator>.</operator><name>IsHighSurrogate</name></name><argument_list>(<argument><expr><name><name>sourceText</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>char</name><operator>.</operator><name>IsLowSurrogate</name></name><argument_list>(<argument><expr><name><name>sourceText</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <block>{
                    <if>if <condition>(<expr><name>writeIndex</name> <operator>==</operator> <name><name>charBuffer</name><operator>.</operator><name>Length</name></name></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><call><name>ResizeInternalArray</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>charBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block></then></if>

                    <expr_stmt><expr><name><name>charBuffer</name><index>[<expr><name>writeIndex</name></expr>]</index></name> <operator>=</operator> <call><name><name>char</name><operator>.</operator><name>ConvertToUtf32</name></name><argument_list>(<argument><expr><name><name>sourceText</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>sourceText</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><name>writeIndex</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                    <continue>continue;</continue>
                }</block></then></if>

                <comment type="line">//// Handle inline replacement of &lt;stlye&gt; and &lt;br&gt; tags.</comment>
                <if>if <condition>(<expr><name><name>sourceText</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="number">60</literal> <operator>&amp;&amp;</operator> <name>m_isRichText</name></expr>)</condition><then>
                <block>{
                    <if>if <condition>(<expr><call><name>IsTagName</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>sourceText</name></expr></argument>, <argument><expr><literal type="string">"&lt;BR&gt;"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <block>{
                        <if>if <condition>(<expr><name>writeIndex</name> <operator>==</operator> <name><name>charBuffer</name><operator>.</operator><name>Length</name></name></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><call><name>ResizeInternalArray</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>charBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block></then></if>

                        <expr_stmt><expr><name><name>charBuffer</name><index>[<expr><name>writeIndex</name></expr>]</index></name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt> <empty_stmt>;</empty_stmt>
                        <expr_stmt><expr><name>writeIndex</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                        <expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>

                        <continue>continue;</continue>
                    }</block></then>
                    <elseif>else <if>if <condition>(<expr><call><name>IsTagName</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>sourceText</name></expr></argument>, <argument><expr><literal type="string">"&lt;STYLE="</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <block>{
                        <decl_stmt><decl><type><name>int</name></type> <name>srcOffset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                        <if>if <condition>(<expr><call><name>ReplaceOpeningStyleTag</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>sourceText</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><modifier>out</modifier> <expr><name>srcOffset</name></expr></argument>, <argument><modifier>ref</modifier> <expr><name>charBuffer</name></expr></argument>, <argument><modifier>ref</modifier> <expr><name>writeIndex</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                        <block>{
                            <expr_stmt><expr><name>i</name> <operator>=</operator> <name>srcOffset</name></expr>;</expr_stmt>
                            <continue>continue;</continue>
                        }</block></then></if>
                    }</block></then></if></elseif>
                    <elseif>else <if>if <condition>(<expr><call><name>IsTagName</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>sourceText</name></expr></argument>, <argument><expr><literal type="string">"&lt;/STYLE&gt;"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <block>{
                        <expr_stmt><expr><call><name>ReplaceClosingStyleTag</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>sourceText</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><modifier>ref</modifier> <expr><name>charBuffer</name></expr></argument>, <argument><modifier>ref</modifier> <expr><name>writeIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <comment type="line">// Strip &lt;/style&gt; even if style is invalid.</comment>
                        <expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">7</literal></expr>;</expr_stmt>
                        <continue>continue;</continue>
                    }</block></then></if></elseif></if>
                }</block></then></if>

                <if>if <condition>(<expr><name>writeIndex</name> <operator>==</operator> <name><name>charBuffer</name><operator>.</operator><name>Length</name></name></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><call><name>ResizeInternalArray</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>charBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block></then></if>

                <expr_stmt><expr><name><name>charBuffer</name><index>[<expr><name>writeIndex</name></expr>]</index></name> <operator>=</operator> <name><name>sourceText</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>writeIndex</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            }</block></for>

            <if>if <condition>(<expr><name>writeIndex</name> <operator>==</operator> <name><name>charBuffer</name><operator>.</operator><name>Length</name></name></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><call><name>ResizeInternalArray</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>charBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block></then></if>

            <expr_stmt><expr><name><name>charBuffer</name><index>[<expr><name>writeIndex</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><literal type="number">0</literal></expr>;</expr_stmt>
        }</block></function>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Copy contents of StringBuilder into int array.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;param name="sourceText"&gt;Text to copy.&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="charBuffer"&gt;Array to store contents.&lt;/param&gt;</comment>
        <function><specifier>protected</specifier> <type><name>void</name></type> <name>StringBuilderToIntArray</name><parameter_list>(<parameter><decl><type><name>StringBuilder</name></type> <name>sourceText</name></decl></parameter>, <parameter><decl><type><name><modifier>ref</modifier> <name>int</name><index>[]</index></name></type> <name>charBuffer</name></decl></parameter>)</parameter_list>
        <block>{
            <if>if <condition>(<expr><name>sourceText</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then>
            <block>{
                <expr_stmt><expr><name><name>charBuffer</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <return>return;</return>
            }</block></then></if>

            <if>if <condition>(<expr><name>charBuffer</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><name>charBuffer</name> <operator>=</operator> <operator>new</operator> <name><name>int</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></expr>;</expr_stmt></block></then></if>

            <comment type="line">// Clear the Style stack.</comment>
            <expr_stmt><expr><call><name><name>m_styleStack</name><operator>.</operator><name>Clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>UNITY_EDITOR</name></expr></cpp:if>
            <comment type="line">// Create new string to be displayed in the Input Text Box of the Editor Panel.</comment>
            <expr_stmt><expr><name>m_text</name> <operator>=</operator> <call><name><name>sourceText</name><operator>.</operator><name>ToString</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <decl_stmt><decl><type><name>int</name></type> <name>writeIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>sourceText</name><operator>.</operator><name>Length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{
                <if>if <condition>(<expr><name>m_parseCtrlCharacters</name> <operator>&amp;&amp;</operator> <name><name>sourceText</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="number">92</literal> <operator>&amp;&amp;</operator> <name><name>sourceText</name><operator>.</operator><name>Length</name></name> <operator>&gt;</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition><then>
                <block>{
                    <switch>switch <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator><name><name>sourceText</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition>
                    <block>{
                        <case>case <expr><literal type="number">85</literal></expr>:</case> <comment type="line">// \U00000000 for UTF-32 Unicode</comment>
                            <if>if <condition>(<expr><name><name>sourceText</name><operator>.</operator><name>Length</name></name> <operator>&gt;</operator> <name>i</name> <operator>+</operator> <literal type="number">9</literal></expr>)</condition><then>
                            <block>{
                                <if>if <condition>(<expr><name>writeIndex</name> <operator>==</operator> <name><name>charBuffer</name><operator>.</operator><name>Length</name></name></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><call><name>ResizeInternalArray</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>charBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block></then></if>

                                <expr_stmt><expr><name><name>charBuffer</name><index>[<expr><name>writeIndex</name></expr>]</index></name> <operator>=</operator> <call><name>GetUTF32</name><argument_list>(<argument><expr><name>sourceText</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">9</literal></expr>;</expr_stmt>
                                <expr_stmt><expr><name>writeIndex</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                                <continue>continue;</continue>
                            }</block></then></if>
                            <break>break;</break>
                        <case>case <expr><literal type="number">92</literal></expr>:</case> <comment type="line">// \ escape</comment>
                            <if>if <condition>(<expr><name><name>sourceText</name><operator>.</operator><name>Length</name></name> <operator>&lt;=</operator> <name>i</name> <operator>+</operator> <literal type="number">2</literal></expr>)</condition><then> <block type="pseudo"><break>break;</break></block></then></if>

                            <if>if <condition>(<expr><name>writeIndex</name> <operator>+</operator> <literal type="number">2</literal> <operator>&gt;</operator> <name><name>charBuffer</name><operator>.</operator><name>Length</name></name></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><call><name>ResizeInternalArray</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>charBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block></then></if>

                            <expr_stmt><expr><name><name>charBuffer</name><index>[<expr><name>writeIndex</name></expr>]</index></name> <operator>=</operator> <name><name>sourceText</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>charBuffer</name><index>[<expr><name>writeIndex</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>sourceText</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
                            <expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
                            <expr_stmt><expr><name>writeIndex</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
                            <continue>continue;</continue>
                        <case>case <expr><literal type="number">110</literal></expr>:</case> <comment type="line">// \n LineFeed</comment>
                            <if>if <condition>(<expr><name>writeIndex</name> <operator>==</operator> <name><name>charBuffer</name><operator>.</operator><name>Length</name></name></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><call><name>ResizeInternalArray</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>charBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block></then></if>

                            <expr_stmt><expr><name><name>charBuffer</name><index>[<expr><name>writeIndex</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><literal type="number">10</literal></expr>;</expr_stmt>
                            <expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                            <expr_stmt><expr><name>writeIndex</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                            <continue>continue;</continue>
                        <case>case <expr><literal type="number">114</literal></expr>:</case> <comment type="line">// \r</comment>
                            <if>if <condition>(<expr><name>writeIndex</name> <operator>==</operator> <name><name>charBuffer</name><operator>.</operator><name>Length</name></name></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><call><name>ResizeInternalArray</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>charBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block></then></if>

                            <expr_stmt><expr><name><name>charBuffer</name><index>[<expr><name>writeIndex</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><literal type="number">13</literal></expr>;</expr_stmt>
                            <expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                            <expr_stmt><expr><name>writeIndex</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                            <continue>continue;</continue>
                        <case>case <expr><literal type="number">116</literal></expr>:</case> <comment type="line">// \t Tab</comment>
                            <if>if <condition>(<expr><name>writeIndex</name> <operator>==</operator> <name><name>charBuffer</name><operator>.</operator><name>Length</name></name></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><call><name>ResizeInternalArray</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>charBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block></then></if>

                            <expr_stmt><expr><name><name>charBuffer</name><index>[<expr><name>writeIndex</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><literal type="number">9</literal></expr>;</expr_stmt>
                            <expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                            <expr_stmt><expr><name>writeIndex</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                            <continue>continue;</continue>
                        <case>case <expr><literal type="number">117</literal></expr>:</case> <comment type="line">// \u0000 for UTF-16 Unicode</comment>
                            <if>if <condition>(<expr><name><name>sourceText</name><operator>.</operator><name>Length</name></name> <operator>&gt;</operator> <name>i</name> <operator>+</operator> <literal type="number">5</literal></expr>)</condition><then>
                            <block>{
                                <if>if <condition>(<expr><name>writeIndex</name> <operator>==</operator> <name><name>charBuffer</name><operator>.</operator><name>Length</name></name></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><call><name>ResizeInternalArray</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>charBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block></then></if>

                                <expr_stmt><expr><name><name>charBuffer</name><index>[<expr><name>writeIndex</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><call><name>GetUTF16</name><argument_list>(<argument><expr><name>sourceText</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">5</literal></expr>;</expr_stmt>
                                <expr_stmt><expr><name>writeIndex</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                                <continue>continue;</continue>
                            }</block></then></if>
                            <break>break;</break>
                    }</block></switch>
                }</block></then></if>

                <comment type="line">// Handle UTF-32 in the input text (string).</comment>
                <if>if <condition>(<expr><call><name><name>char</name><operator>.</operator><name>IsHighSurrogate</name></name><argument_list>(<argument><expr><name><name>sourceText</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>char</name><operator>.</operator><name>IsLowSurrogate</name></name><argument_list>(<argument><expr><name><name>sourceText</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <block>{
                    <if>if <condition>(<expr><name>writeIndex</name> <operator>==</operator> <name><name>charBuffer</name><operator>.</operator><name>Length</name></name></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><call><name>ResizeInternalArray</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>charBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block></then></if>

                    <expr_stmt><expr><name><name>charBuffer</name><index>[<expr><name>writeIndex</name></expr>]</index></name> <operator>=</operator> <call><name><name>char</name><operator>.</operator><name>ConvertToUtf32</name></name><argument_list>(<argument><expr><name><name>sourceText</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>sourceText</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><name>writeIndex</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                    <continue>continue;</continue>
                }</block></then></if>

                <comment type="line">// Handle inline replacement of &lt;stlye&gt; and &lt;br&gt; tags.</comment>
                <if>if <condition>(<expr><name><name>sourceText</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="number">60</literal></expr>)</condition><then>
                <block>{
                    <if>if <condition>(<expr><call><name>IsTagName</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>sourceText</name></expr></argument>, <argument><expr><literal type="string">"&lt;BR&gt;"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <block>{
                        <if>if <condition>(<expr><name>writeIndex</name> <operator>==</operator> <name><name>charBuffer</name><operator>.</operator><name>Length</name></name></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><call><name>ResizeInternalArray</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>charBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block></then></if>

                        <expr_stmt><expr><name><name>charBuffer</name><index>[<expr><name>writeIndex</name></expr>]</index></name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
                        <expr_stmt><expr><name>writeIndex</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                        <expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>

                        <continue>continue;</continue>
                    }</block></then>
                    <elseif>else <if>if <condition>(<expr><call><name>IsTagName</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>sourceText</name></expr></argument>, <argument><expr><literal type="string">"&lt;STYLE="</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <block>{
                        <decl_stmt><decl><type><name>int</name></type> <name>srcOffset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                        <if>if <condition>(<expr><call><name>ReplaceOpeningStyleTag</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>sourceText</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><modifier>out</modifier> <expr><name>srcOffset</name></expr></argument>, <argument><modifier>ref</modifier> <expr><name>charBuffer</name></expr></argument>, <argument><modifier>ref</modifier> <expr><name>writeIndex</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                        <block>{
                            <expr_stmt><expr><name>i</name> <operator>=</operator> <name>srcOffset</name></expr>;</expr_stmt>
                            <continue>continue;</continue>
                        }</block></then></if>
                    }</block></then></if></elseif>
                    <elseif>else <if>if <condition>(<expr><call><name>IsTagName</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>sourceText</name></expr></argument>, <argument><expr><literal type="string">"&lt;/STYLE&gt;"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <block>{
                        <expr_stmt><expr><call><name>ReplaceClosingStyleTag</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>sourceText</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><modifier>ref</modifier> <expr><name>charBuffer</name></expr></argument>, <argument><modifier>ref</modifier> <expr><name>writeIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <comment type="line">// Strip &lt;/style&gt; even if style is invalid.</comment>
                        <expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">7</literal></expr>;</expr_stmt>
                        <continue>continue;</continue>
                    }</block></then></if></elseif></if>
                }</block></then></if>

                <if>if <condition>(<expr><name>writeIndex</name> <operator>==</operator> <name><name>charBuffer</name><operator>.</operator><name>Length</name></name></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><call><name>ResizeInternalArray</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>charBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block></then></if>

                <expr_stmt><expr><name><name>charBuffer</name><index>[<expr><name>writeIndex</name></expr>]</index></name> <operator>=</operator> <name><name>sourceText</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>writeIndex</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            }</block></for>

            <if>if <condition>(<expr><name>writeIndex</name> <operator>==</operator> <name><name>charBuffer</name><operator>.</operator><name>Length</name></name></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><call><name>ResizeInternalArray</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>charBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block></then></if>

            <expr_stmt><expr><name><name>charBuffer</name><index>[<expr><name>writeIndex</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><literal type="number">0</literal></expr>;</expr_stmt>
        }</block></function>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Method to handle inline replacement of style tag by opening style definition.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;param name="sourceText"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="srcIndex"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="srcOffset"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="charBuffer"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="writeIndex"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;returns&gt;&lt;/returns&gt;</comment>
        <function><type><name>bool</name></type> <name>ReplaceOpeningStyleTag</name><parameter_list>(<parameter><decl><type><modifier>ref</modifier> <name>string</name></type> <name>sourceText</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>srcIndex</name></decl></parameter>, <parameter><decl><type><modifier>out</modifier> <name>int</name></type> <name>srcOffset</name></decl></parameter>, <parameter><decl><type><name><modifier>ref</modifier> <name>int</name><index>[]</index></name></type> <name>charBuffer</name></decl></parameter>, <parameter><decl><type><modifier>ref</modifier> <name>int</name></type> <name>writeIndex</name></decl></parameter>)</parameter_list>
        <block>{
            <comment type="line">// Validate &lt;style&gt; tag.</comment>
            <decl_stmt><decl><type><name>int</name></type> <name>hashCode</name> <init>= <expr><call><name>GetTagHashCode</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>sourceText</name></expr></argument>, <argument><expr><name>srcIndex</name> <operator>+</operator> <literal type="number">7</literal></expr></argument>, <argument><modifier>out</modifier> <expr><name>srcOffset</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <decl_stmt><decl><type><name>TMP_Style</name></type> <name>style</name> <init>= <expr><call><name><name>TMP_StyleSheet</name><operator>.</operator><name>GetStyle</name></name><argument_list>(<argument><expr><name>hashCode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// Return if we don't have a valid style.</comment>
            <if>if <condition>(<expr><name>style</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name>srcOffset</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block type="pseudo"><return>return <expr><literal type="boolean">false</literal></expr>;</return></block></then></if>

            <expr_stmt><expr><call><name><name>m_styleStack</name><operator>.</operator><name>Add</name></name><argument_list>(<argument><expr><name><name>style</name><operator>.</operator><name>hashCode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <decl_stmt><decl><type><name>int</name></type> <name>styleLength</name> <init>= <expr><name><name>style</name><operator>.</operator><name>styleOpeningTagArray</name><operator>.</operator><name>Length</name></name></expr></init></decl>;</decl_stmt>

            <comment type="line">// Replace &lt;style&gt; tag with opening definition</comment>
            <decl_stmt><decl><type><name><name>int</name><index>[]</index></name></type> <name>openingTagArray</name> <init>= <expr><name><name>style</name><operator>.</operator><name>styleOpeningTagArray</name></name></expr></init></decl>;</decl_stmt>

            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>styleLength</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{
                <decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><name><name>openingTagArray</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

                <if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="number">60</literal></expr>)</condition><then>
                <block>{
                    <if>if <condition>(<expr><call><name>IsTagName</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>openingTagArray</name></expr></argument>, <argument><expr><literal type="string">"&lt;BR&gt;"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <block>{
                        <if>if <condition>(<expr><name>writeIndex</name> <operator>==</operator> <name><name>charBuffer</name><operator>.</operator><name>Length</name></name></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><call><name>ResizeInternalArray</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>charBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block></then></if>

                        <expr_stmt><expr><name><name>charBuffer</name><index>[<expr><name>writeIndex</name></expr>]</index></name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
                        <expr_stmt><expr><name>writeIndex</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                        <expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>

                        <continue>continue;</continue>
                    }</block></then>
                    <elseif>else <if>if <condition>(<expr><call><name>IsTagName</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>openingTagArray</name></expr></argument>, <argument><expr><literal type="string">"&lt;STYLE="</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <block>{
                        <decl_stmt><decl><type><name>int</name></type> <name>offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                        <if>if <condition>(<expr><call><name>ReplaceOpeningStyleTag</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>openingTagArray</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><modifier>out</modifier> <expr><name>offset</name></expr></argument>, <argument><modifier>ref</modifier> <expr><name>charBuffer</name></expr></argument>, <argument><modifier>ref</modifier> <expr><name>writeIndex</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                        <block>{
                            <expr_stmt><expr><name>i</name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
                            <continue>continue;</continue>
                        }</block></then></if>
                    }</block></then></if></elseif>
                    <elseif>else <if>if <condition>(<expr><call><name>IsTagName</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>openingTagArray</name></expr></argument>, <argument><expr><literal type="string">"&lt;/STYLE&gt;"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <block>{
                        <expr_stmt><expr><call><name>ReplaceClosingStyleTag</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>openingTagArray</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><modifier>ref</modifier> <expr><name>charBuffer</name></expr></argument>, <argument><modifier>ref</modifier> <expr><name>writeIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        
                        <comment type="line">// Strip &lt;/style&gt; even if style is invalid.</comment>
                        <expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">7</literal></expr>;</expr_stmt>
                        <continue>continue;</continue>
                    }</block></then></if></elseif></if>
                }</block></then></if>

                <if>if <condition>(<expr><name>writeIndex</name> <operator>==</operator> <name><name>charBuffer</name><operator>.</operator><name>Length</name></name></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><call><name>ResizeInternalArray</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>charBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block></then></if>

                <expr_stmt><expr><name><name>charBuffer</name><index>[<expr><name>writeIndex</name></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>writeIndex</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            }</block></for>

            <return>return <expr><literal type="boolean">true</literal></expr>;</return>
        }</block></function>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Method to handle inline replacement of style tag by opening style definition.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;param name="sourceText"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="srcIndex"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="srcOffset"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="charBuffer"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="writeIndex"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;returns&gt;&lt;/returns&gt;</comment>
        <function><type><name>bool</name></type> <name>ReplaceOpeningStyleTag</name><parameter_list>(<parameter><decl><type><name><modifier>ref</modifier> <name>int</name><index>[]</index></name></type> <name>sourceText</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>srcIndex</name></decl></parameter>, <parameter><decl><type><modifier>out</modifier> <name>int</name></type> <name>srcOffset</name></decl></parameter>, <parameter><decl><type><name><modifier>ref</modifier> <name>int</name><index>[]</index></name></type> <name>charBuffer</name></decl></parameter>, <parameter><decl><type><modifier>ref</modifier> <name>int</name></type> <name>writeIndex</name></decl></parameter>)</parameter_list>
        <block>{
            <comment type="line">// Validate &lt;style&gt; tag.</comment>
            <decl_stmt><decl><type><name>int</name></type> <name>hashCode</name> <init>= <expr><call><name>GetTagHashCode</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>sourceText</name></expr></argument>, <argument><expr><name>srcIndex</name> <operator>+</operator> <literal type="number">7</literal></expr></argument>, <argument><modifier>out</modifier> <expr><name>srcOffset</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <decl_stmt><decl><type><name>TMP_Style</name></type> <name>style</name> <init>= <expr><call><name><name>TMP_StyleSheet</name><operator>.</operator><name>GetStyle</name></name><argument_list>(<argument><expr><name>hashCode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// Return if we don't have a valid style.</comment>
            <if>if <condition>(<expr><name>style</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name>srcOffset</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block type="pseudo"><return>return <expr><literal type="boolean">false</literal></expr>;</return></block></then></if>

            <expr_stmt><expr><call><name><name>m_styleStack</name><operator>.</operator><name>Add</name></name><argument_list>(<argument><expr><name><name>style</name><operator>.</operator><name>hashCode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <decl_stmt><decl><type><name>int</name></type> <name>styleLength</name> <init>= <expr><name><name>style</name><operator>.</operator><name>styleOpeningTagArray</name><operator>.</operator><name>Length</name></name></expr></init></decl>;</decl_stmt>

            <comment type="line">// Replace &lt;style&gt; tag with opening definition</comment>
            <decl_stmt><decl><type><name><name>int</name><index>[]</index></name></type> <name>openingTagArray</name> <init>= <expr><name><name>style</name><operator>.</operator><name>styleOpeningTagArray</name></name></expr></init></decl>;</decl_stmt>

            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>styleLength</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{
                <decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><name><name>openingTagArray</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

                <if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="number">60</literal></expr>)</condition><then>
                <block>{
                    <if>if <condition>(<expr><call><name>IsTagName</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>openingTagArray</name></expr></argument>, <argument><expr><literal type="string">"&lt;BR&gt;"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <block>{
                        <if>if <condition>(<expr><name>writeIndex</name> <operator>==</operator> <name><name>charBuffer</name><operator>.</operator><name>Length</name></name></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><call><name>ResizeInternalArray</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>charBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block></then></if>

                        <expr_stmt><expr><name><name>charBuffer</name><index>[<expr><name>writeIndex</name></expr>]</index></name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
                        <expr_stmt><expr><name>writeIndex</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                        <expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>

                        <continue>continue;</continue>
                    }</block></then>
                    <elseif>else <if>if <condition>(<expr><call><name>IsTagName</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>openingTagArray</name></expr></argument>, <argument><expr><literal type="string">"&lt;STYLE="</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <block>{
                        <decl_stmt><decl><type><name>int</name></type> <name>offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                        <if>if <condition>(<expr><call><name>ReplaceOpeningStyleTag</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>openingTagArray</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><modifier>out</modifier> <expr><name>offset</name></expr></argument>, <argument><modifier>ref</modifier> <expr><name>charBuffer</name></expr></argument>, <argument><modifier>ref</modifier> <expr><name>writeIndex</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                        <block>{
                            <expr_stmt><expr><name>i</name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
                            <continue>continue;</continue>
                        }</block></then></if>
                    }</block></then></if></elseif>
                    <elseif>else <if>if <condition>(<expr><call><name>IsTagName</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>openingTagArray</name></expr></argument>, <argument><expr><literal type="string">"&lt;/STYLE&gt;"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <block>{
                        <expr_stmt><expr><call><name>ReplaceClosingStyleTag</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>openingTagArray</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><modifier>ref</modifier> <expr><name>charBuffer</name></expr></argument>, <argument><modifier>ref</modifier> <expr><name>writeIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        
                        <comment type="line">// Strip &lt;/style&gt; even if style is invalid.</comment>
                        <expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">7</literal></expr>;</expr_stmt>
                        <continue>continue;</continue>
                    }</block></then></if></elseif></if>
                }</block></then></if>

                <if>if <condition>(<expr><name>writeIndex</name> <operator>==</operator> <name><name>charBuffer</name><operator>.</operator><name>Length</name></name></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><call><name>ResizeInternalArray</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>charBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block></then></if>

                <expr_stmt><expr><name><name>charBuffer</name><index>[<expr><name>writeIndex</name></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>writeIndex</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            }</block></for>

            <return>return <expr><literal type="boolean">true</literal></expr>;</return>
        }</block></function>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Method to handle inline replacement of style tag by opening style definition.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;param name="sourceText"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="srcIndex"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="srcOffset"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="charBuffer"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="writeIndex"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;returns&gt;&lt;/returns&gt;</comment>
        <function><type><name>bool</name></type> <name>ReplaceOpeningStyleTag</name><parameter_list>(<parameter><decl><type><name><modifier>ref</modifier> <name>char</name><index>[]</index></name></type> <name>sourceText</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>srcIndex</name></decl></parameter>, <parameter><decl><type><modifier>out</modifier> <name>int</name></type> <name>srcOffset</name></decl></parameter>, <parameter><decl><type><name><modifier>ref</modifier> <name>int</name><index>[]</index></name></type> <name>charBuffer</name></decl></parameter>, <parameter><decl><type><modifier>ref</modifier> <name>int</name></type> <name>writeIndex</name></decl></parameter>)</parameter_list>
        <block>{
            <comment type="line">// Validate &lt;style&gt; tag.</comment>
            <decl_stmt><decl><type><name>int</name></type> <name>hashCode</name> <init>= <expr><call><name>GetTagHashCode</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>sourceText</name></expr></argument>, <argument><expr><name>srcIndex</name> <operator>+</operator> <literal type="number">7</literal></expr></argument>, <argument><modifier>out</modifier> <expr><name>srcOffset</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <decl_stmt><decl><type><name>TMP_Style</name></type> <name>style</name> <init>= <expr><call><name><name>TMP_StyleSheet</name><operator>.</operator><name>GetStyle</name></name><argument_list>(<argument><expr><name>hashCode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// Return if we don't have a valid style.</comment>
            <if>if <condition>(<expr><name>style</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name>srcOffset</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block type="pseudo"><return>return <expr><literal type="boolean">false</literal></expr>;</return></block></then></if>

            <expr_stmt><expr><call><name><name>m_styleStack</name><operator>.</operator><name>Add</name></name><argument_list>(<argument><expr><name><name>style</name><operator>.</operator><name>hashCode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <decl_stmt><decl><type><name>int</name></type> <name>styleLength</name> <init>= <expr><name><name>style</name><operator>.</operator><name>styleOpeningTagArray</name><operator>.</operator><name>Length</name></name></expr></init></decl>;</decl_stmt>

            <comment type="line">// Replace &lt;style&gt; tag with opening definition</comment>
            <decl_stmt><decl><type><name><name>int</name><index>[]</index></name></type> <name>openingTagArray</name> <init>= <expr><name><name>style</name><operator>.</operator><name>styleOpeningTagArray</name></name></expr></init></decl>;</decl_stmt>

            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>styleLength</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{
                <decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><name><name>openingTagArray</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

                <if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="number">60</literal></expr>)</condition><then>
                <block>{
                    <if>if <condition>(<expr><call><name>IsTagName</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>openingTagArray</name></expr></argument>, <argument><expr><literal type="string">"&lt;BR&gt;"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <block>{
                        <if>if <condition>(<expr><name>writeIndex</name> <operator>==</operator> <name><name>charBuffer</name><operator>.</operator><name>Length</name></name></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><call><name>ResizeInternalArray</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>charBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block></then></if>

                        <expr_stmt><expr><name><name>charBuffer</name><index>[<expr><name>writeIndex</name></expr>]</index></name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
                        <expr_stmt><expr><name>writeIndex</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                        <expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>

                        <continue>continue;</continue>
                    }</block></then>
                    <elseif>else <if>if <condition>(<expr><call><name>IsTagName</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>openingTagArray</name></expr></argument>, <argument><expr><literal type="string">"&lt;STYLE="</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <block>{
                        <decl_stmt><decl><type><name>int</name></type> <name>offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                        <if>if <condition>(<expr><call><name>ReplaceOpeningStyleTag</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>openingTagArray</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><modifier>out</modifier> <expr><name>offset</name></expr></argument>, <argument><modifier>ref</modifier> <expr><name>charBuffer</name></expr></argument>, <argument><modifier>ref</modifier> <expr><name>writeIndex</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                        <block>{
                            <expr_stmt><expr><name>i</name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
                            <continue>continue;</continue>
                        }</block></then></if>
                    }</block></then></if></elseif>
                    <elseif>else <if>if <condition>(<expr><call><name>IsTagName</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>openingTagArray</name></expr></argument>, <argument><expr><literal type="string">"&lt;/STYLE&gt;"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <block>{
                        <expr_stmt><expr><call><name>ReplaceClosingStyleTag</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>openingTagArray</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><modifier>ref</modifier> <expr><name>charBuffer</name></expr></argument>, <argument><modifier>ref</modifier> <expr><name>writeIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <comment type="line">// Strip &lt;/style&gt; even if style is invalid.</comment>
                        <expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">7</literal></expr>;</expr_stmt>
                        <continue>continue;</continue>
                    }</block></then></if></elseif></if>
                }</block></then></if>

                <if>if <condition>(<expr><name>writeIndex</name> <operator>==</operator> <name><name>charBuffer</name><operator>.</operator><name>Length</name></name></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><call><name>ResizeInternalArray</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>charBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block></then></if>

                <expr_stmt><expr><name><name>charBuffer</name><index>[<expr><name>writeIndex</name></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>writeIndex</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            }</block></for>

            <return>return <expr><literal type="boolean">true</literal></expr>;</return>
        }</block></function>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Method to handle inline replacement of style tag by opening style definition.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;param name="sourceText"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="srcIndex"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="srcOffset"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="charBuffer"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="writeIndex"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;returns&gt;&lt;/returns&gt;</comment>
        <function><type><name>bool</name></type> <name>ReplaceOpeningStyleTag</name><parameter_list>(<parameter><decl><type><modifier>ref</modifier> <name>StringBuilder</name></type> <name>sourceText</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>srcIndex</name></decl></parameter>, <parameter><decl><type><modifier>out</modifier> <name>int</name></type> <name>srcOffset</name></decl></parameter>, <parameter><decl><type><name><modifier>ref</modifier> <name>int</name><index>[]</index></name></type> <name>charBuffer</name></decl></parameter>, <parameter><decl><type><modifier>ref</modifier> <name>int</name></type> <name>writeIndex</name></decl></parameter>)</parameter_list>
        <block>{
            <comment type="line">// Validate &lt;style&gt; tag.</comment>
            <decl_stmt><decl><type><name>int</name></type> <name>hashCode</name> <init>= <expr><call><name>GetTagHashCode</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>sourceText</name></expr></argument>, <argument><expr><name>srcIndex</name> <operator>+</operator> <literal type="number">7</literal></expr></argument>, <argument><modifier>out</modifier> <expr><name>srcOffset</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <decl_stmt><decl><type><name>TMP_Style</name></type> <name>style</name> <init>= <expr><call><name><name>TMP_StyleSheet</name><operator>.</operator><name>GetStyle</name></name><argument_list>(<argument><expr><name>hashCode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// Return if we don't have a valid style.</comment>
            <if>if <condition>(<expr><name>style</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name>srcOffset</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block type="pseudo"><return>return <expr><literal type="boolean">false</literal></expr>;</return></block></then></if>

            <expr_stmt><expr><call><name><name>m_styleStack</name><operator>.</operator><name>Add</name></name><argument_list>(<argument><expr><name><name>style</name><operator>.</operator><name>hashCode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <decl_stmt><decl><type><name>int</name></type> <name>styleLength</name> <init>= <expr><name><name>style</name><operator>.</operator><name>styleOpeningTagArray</name><operator>.</operator><name>Length</name></name></expr></init></decl>;</decl_stmt>

            <comment type="line">// Replace &lt;style&gt; tag with opening definition</comment>
            <decl_stmt><decl><type><name><name>int</name><index>[]</index></name></type> <name>openingTagArray</name> <init>= <expr><name><name>style</name><operator>.</operator><name>styleOpeningTagArray</name></name></expr></init></decl>;</decl_stmt>

            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>styleLength</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{
                <decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><name><name>openingTagArray</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

                <if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="number">60</literal></expr>)</condition><then>
                <block>{
                    <if>if <condition>(<expr><call><name>IsTagName</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>openingTagArray</name></expr></argument>, <argument><expr><literal type="string">"&lt;BR&gt;"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <block>{
                        <if>if <condition>(<expr><name>writeIndex</name> <operator>==</operator> <name><name>charBuffer</name><operator>.</operator><name>Length</name></name></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><call><name>ResizeInternalArray</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>charBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block></then></if>

                        <expr_stmt><expr><name><name>charBuffer</name><index>[<expr><name>writeIndex</name></expr>]</index></name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
                        <expr_stmt><expr><name>writeIndex</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                        <expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>

                        <continue>continue;</continue>
                    }</block></then>
                    <elseif>else <if>if <condition>(<expr><call><name>IsTagName</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>openingTagArray</name></expr></argument>, <argument><expr><literal type="string">"&lt;STYLE="</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <block>{
                        <decl_stmt><decl><type><name>int</name></type> <name>offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                        <if>if <condition>(<expr><call><name>ReplaceOpeningStyleTag</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>openingTagArray</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><modifier>out</modifier> <expr><name>offset</name></expr></argument>, <argument><modifier>ref</modifier> <expr><name>charBuffer</name></expr></argument>, <argument><modifier>ref</modifier> <expr><name>writeIndex</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                        <block>{
                            <expr_stmt><expr><name>i</name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
                            <continue>continue;</continue>
                        }</block></then></if>
                    }</block></then></if></elseif>
                    <elseif>else <if>if <condition>(<expr><call><name>IsTagName</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>openingTagArray</name></expr></argument>, <argument><expr><literal type="string">"&lt;/STYLE&gt;"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <block>{
                        <expr_stmt><expr><call><name>ReplaceClosingStyleTag</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>openingTagArray</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><modifier>ref</modifier> <expr><name>charBuffer</name></expr></argument>, <argument><modifier>ref</modifier> <expr><name>writeIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <comment type="line">// Strip &lt;/style&gt; even if style is invalid.</comment>
                        <expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">7</literal></expr>;</expr_stmt>
                        <continue>continue;</continue>
                    }</block></then></if></elseif></if>
                }</block></then></if>

                <if>if <condition>(<expr><name>writeIndex</name> <operator>==</operator> <name><name>charBuffer</name><operator>.</operator><name>Length</name></name></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><call><name>ResizeInternalArray</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>charBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block></then></if>

                <expr_stmt><expr><name><name>charBuffer</name><index>[<expr><name>writeIndex</name></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>writeIndex</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            }</block></for>

            <return>return <expr><literal type="boolean">true</literal></expr>;</return>
        }</block></function>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Method to handle inline replacement of style tag by closing style definition.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;param name="sourceText"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="srcIndex"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="charBuffer"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="writeIndex"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;returns&gt;&lt;/returns&gt;</comment>
        <function><type><name>bool</name></type> <name>ReplaceClosingStyleTag</name><parameter_list>(<parameter><decl><type><modifier>ref</modifier> <name>string</name></type> <name>sourceText</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>srcIndex</name></decl></parameter>, <parameter><decl><type><name><modifier>ref</modifier> <name>int</name><index>[]</index></name></type> <name>charBuffer</name></decl></parameter>, <parameter><decl><type><modifier>ref</modifier> <name>int</name></type> <name>writeIndex</name></decl></parameter>)</parameter_list>
        <block>{
            <comment type="line">// Get style from the Style Stack</comment>
            <decl_stmt><decl><type><name>int</name></type> <name>hashCode</name> <init>= <expr><call><name><name>m_styleStack</name><operator>.</operator><name>CurrentItem</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>TMP_Style</name></type> <name>style</name> <init>= <expr><call><name><name>TMP_StyleSheet</name><operator>.</operator><name>GetStyle</name></name><argument_list>(<argument><expr><name>hashCode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name><name>m_styleStack</name><operator>.</operator><name>Remove</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// Return if we don't have a valid style.</comment>
            <if>if <condition>(<expr><name>style</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block type="pseudo"><return>return <expr><literal type="boolean">false</literal></expr>;</return></block></then></if>

            <decl_stmt><decl><type><name>int</name></type> <name>styleLength</name> <init>= <expr><name><name>style</name><operator>.</operator><name>styleClosingTagArray</name><operator>.</operator><name>Length</name></name></expr></init></decl>;</decl_stmt>

            <comment type="line">// Replace &lt;style&gt; tag with opening definition</comment>
            <decl_stmt><decl><type><name><name>int</name><index>[]</index></name></type> <name>closingTagArray</name> <init>= <expr><name><name>style</name><operator>.</operator><name>styleClosingTagArray</name></name></expr></init></decl>;</decl_stmt>

            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>styleLength</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{
                <decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><name><name>closingTagArray</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

                <if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="number">60</literal></expr>)</condition><then>
                <block>{
                    <if>if <condition>(<expr><call><name>IsTagName</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>closingTagArray</name></expr></argument>, <argument><expr><literal type="string">"&lt;BR&gt;"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <block>{
                        <if>if <condition>(<expr><name>writeIndex</name> <operator>==</operator> <name><name>charBuffer</name><operator>.</operator><name>Length</name></name></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><call><name>ResizeInternalArray</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>charBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block></then></if>

                        <expr_stmt><expr><name><name>charBuffer</name><index>[<expr><name>writeIndex</name></expr>]</index></name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
                        <expr_stmt><expr><name>writeIndex</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                        <expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>

                        <continue>continue;</continue>
                    }</block></then>
                    <elseif>else <if>if <condition>(<expr><call><name>IsTagName</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>closingTagArray</name></expr></argument>, <argument><expr><literal type="string">"&lt;STYLE="</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <block>{
                        <decl_stmt><decl><type><name>int</name></type> <name>offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                        <if>if <condition>(<expr><call><name>ReplaceOpeningStyleTag</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>closingTagArray</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><modifier>out</modifier> <expr><name>offset</name></expr></argument>, <argument><modifier>ref</modifier> <expr><name>charBuffer</name></expr></argument>, <argument><modifier>ref</modifier> <expr><name>writeIndex</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                        <block>{
                            <expr_stmt><expr><name>i</name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
                            <continue>continue;</continue>
                        }</block></then></if>
                    }</block></then></if></elseif>
                    <elseif>else <if>if <condition>(<expr><call><name>IsTagName</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>closingTagArray</name></expr></argument>, <argument><expr><literal type="string">"&lt;/STYLE&gt;"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <block>{
                        <expr_stmt><expr><call><name>ReplaceClosingStyleTag</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>closingTagArray</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><modifier>ref</modifier> <expr><name>charBuffer</name></expr></argument>, <argument><modifier>ref</modifier> <expr><name>writeIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <comment type="line">// Strip &lt;/style&gt; even if style is invalid.</comment>
                        <expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">7</literal></expr>;</expr_stmt>
                        <continue>continue;</continue>
                    }</block></then></if></elseif></if>
                }</block></then></if>

                <if>if <condition>(<expr><name>writeIndex</name> <operator>==</operator> <name><name>charBuffer</name><operator>.</operator><name>Length</name></name></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><call><name>ResizeInternalArray</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>charBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block></then></if>

                <expr_stmt><expr><name><name>charBuffer</name><index>[<expr><name>writeIndex</name></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>writeIndex</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            }</block></for>

            <return>return <expr><literal type="boolean">true</literal></expr>;</return>
        }</block></function>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Method to handle inline replacement of style tag by closing style definition.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;param name="sourceText"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="srcIndex"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="charBuffer"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="writeIndex"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;returns&gt;&lt;/returns&gt;</comment>
        <function><type><name>bool</name></type> <name>ReplaceClosingStyleTag</name><parameter_list>(<parameter><decl><type><name><modifier>ref</modifier> <name>int</name><index>[]</index></name></type> <name>sourceText</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>srcIndex</name></decl></parameter>, <parameter><decl><type><name><modifier>ref</modifier> <name>int</name><index>[]</index></name></type> <name>charBuffer</name></decl></parameter>, <parameter><decl><type><modifier>ref</modifier> <name>int</name></type> <name>writeIndex</name></decl></parameter>)</parameter_list>
        <block>{
            <comment type="line">// Get style from the Style Stack</comment>
            <decl_stmt><decl><type><name>int</name></type> <name>hashCode</name> <init>= <expr><call><name><name>m_styleStack</name><operator>.</operator><name>CurrentItem</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>TMP_Style</name></type> <name>style</name> <init>= <expr><call><name><name>TMP_StyleSheet</name><operator>.</operator><name>GetStyle</name></name><argument_list>(<argument><expr><name>hashCode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name><name>m_styleStack</name><operator>.</operator><name>Remove</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// Return if we don't have a valid style.</comment>
            <if>if <condition>(<expr><name>style</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block type="pseudo"><return>return <expr><literal type="boolean">false</literal></expr>;</return></block></then></if>

            <decl_stmt><decl><type><name>int</name></type> <name>styleLength</name> <init>= <expr><name><name>style</name><operator>.</operator><name>styleClosingTagArray</name><operator>.</operator><name>Length</name></name></expr></init></decl>;</decl_stmt>

            <comment type="line">// Replace &lt;style&gt; tag with opening definition</comment>
            <decl_stmt><decl><type><name><name>int</name><index>[]</index></name></type> <name>closingTagArray</name> <init>= <expr><name><name>style</name><operator>.</operator><name>styleClosingTagArray</name></name></expr></init></decl>;</decl_stmt>

            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>styleLength</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{
                <decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><name><name>closingTagArray</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

                <if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="number">60</literal></expr>)</condition><then>
                <block>{
                    <if>if <condition>(<expr><call><name>IsTagName</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>closingTagArray</name></expr></argument>, <argument><expr><literal type="string">"&lt;BR&gt;"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <block>{
                        <if>if <condition>(<expr><name>writeIndex</name> <operator>==</operator> <name><name>charBuffer</name><operator>.</operator><name>Length</name></name></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><call><name>ResizeInternalArray</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>charBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block></then></if>

                        <expr_stmt><expr><name><name>charBuffer</name><index>[<expr><name>writeIndex</name></expr>]</index></name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
                        <expr_stmt><expr><name>writeIndex</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                        <expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>

                        <continue>continue;</continue>
                    }</block></then>
                    <elseif>else <if>if <condition>(<expr><call><name>IsTagName</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>closingTagArray</name></expr></argument>, <argument><expr><literal type="string">"&lt;STYLE="</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <block>{
                        <decl_stmt><decl><type><name>int</name></type> <name>offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                        <if>if <condition>(<expr><call><name>ReplaceOpeningStyleTag</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>closingTagArray</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><modifier>out</modifier> <expr><name>offset</name></expr></argument>, <argument><modifier>ref</modifier> <expr><name>charBuffer</name></expr></argument>, <argument><modifier>ref</modifier> <expr><name>writeIndex</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                        <block>{
                            <expr_stmt><expr><name>i</name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
                            <continue>continue;</continue>
                        }</block></then></if>
                    }</block></then></if></elseif>
                    <elseif>else <if>if <condition>(<expr><call><name>IsTagName</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>closingTagArray</name></expr></argument>, <argument><expr><literal type="string">"&lt;/STYLE&gt;"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <block>{
                        <expr_stmt><expr><call><name>ReplaceClosingStyleTag</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>closingTagArray</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><modifier>ref</modifier> <expr><name>charBuffer</name></expr></argument>, <argument><modifier>ref</modifier> <expr><name>writeIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <comment type="line">// Strip &lt;/style&gt; even if style is invalid.</comment>
                        <expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">7</literal></expr>;</expr_stmt>
                        <continue>continue;</continue>
                    }</block></then></if></elseif></if>
                }</block></then></if>

                <if>if <condition>(<expr><name>writeIndex</name> <operator>==</operator> <name><name>charBuffer</name><operator>.</operator><name>Length</name></name></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><call><name>ResizeInternalArray</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>charBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block></then></if>

                <expr_stmt><expr><name><name>charBuffer</name><index>[<expr><name>writeIndex</name></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>writeIndex</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            }</block></for>

            <return>return <expr><literal type="boolean">true</literal></expr>;</return>
        }</block></function>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Method to handle inline replacement of style tag by closing style definition.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;param name="sourceText"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="srcIndex"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="charBuffer"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="writeIndex"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;returns&gt;&lt;/returns&gt;</comment>
        <function><type><name>bool</name></type> <name>ReplaceClosingStyleTag</name><parameter_list>(<parameter><decl><type><name><modifier>ref</modifier> <name>char</name><index>[]</index></name></type> <name>sourceText</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>srcIndex</name></decl></parameter>, <parameter><decl><type><name><modifier>ref</modifier> <name>int</name><index>[]</index></name></type> <name>charBuffer</name></decl></parameter>, <parameter><decl><type><modifier>ref</modifier> <name>int</name></type> <name>writeIndex</name></decl></parameter>)</parameter_list>
        <block>{
            <comment type="line">// Get style from the Style Stack</comment>
            <decl_stmt><decl><type><name>int</name></type> <name>hashCode</name> <init>= <expr><call><name><name>m_styleStack</name><operator>.</operator><name>CurrentItem</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>TMP_Style</name></type> <name>style</name> <init>= <expr><call><name><name>TMP_StyleSheet</name><operator>.</operator><name>GetStyle</name></name><argument_list>(<argument><expr><name>hashCode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name><name>m_styleStack</name><operator>.</operator><name>Remove</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// Return if we don't have a valid style.</comment>
            <if>if <condition>(<expr><name>style</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block type="pseudo"><return>return <expr><literal type="boolean">false</literal></expr>;</return></block></then></if>

            <decl_stmt><decl><type><name>int</name></type> <name>styleLength</name> <init>= <expr><name><name>style</name><operator>.</operator><name>styleClosingTagArray</name><operator>.</operator><name>Length</name></name></expr></init></decl>;</decl_stmt>

            <comment type="line">// Replace &lt;style&gt; tag with opening definition</comment>
            <decl_stmt><decl><type><name><name>int</name><index>[]</index></name></type> <name>closingTagArray</name> <init>= <expr><name><name>style</name><operator>.</operator><name>styleClosingTagArray</name></name></expr></init></decl>;</decl_stmt>

            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>styleLength</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{
                <decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><name><name>closingTagArray</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

                <if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="number">60</literal></expr>)</condition><then>
                <block>{
                    <if>if <condition>(<expr><call><name>IsTagName</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>closingTagArray</name></expr></argument>, <argument><expr><literal type="string">"&lt;BR&gt;"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <block>{
                        <if>if <condition>(<expr><name>writeIndex</name> <operator>==</operator> <name><name>charBuffer</name><operator>.</operator><name>Length</name></name></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><call><name>ResizeInternalArray</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>charBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block></then></if>

                        <expr_stmt><expr><name><name>charBuffer</name><index>[<expr><name>writeIndex</name></expr>]</index></name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
                        <expr_stmt><expr><name>writeIndex</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                        <expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>

                        <continue>continue;</continue>
                    }</block></then>
                    <elseif>else <if>if <condition>(<expr><call><name>IsTagName</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>closingTagArray</name></expr></argument>, <argument><expr><literal type="string">"&lt;STYLE="</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <block>{
                        <decl_stmt><decl><type><name>int</name></type> <name>offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                        <if>if <condition>(<expr><call><name>ReplaceOpeningStyleTag</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>closingTagArray</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><modifier>out</modifier> <expr><name>offset</name></expr></argument>, <argument><modifier>ref</modifier> <expr><name>charBuffer</name></expr></argument>, <argument><modifier>ref</modifier> <expr><name>writeIndex</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                        <block>{
                            <expr_stmt><expr><name>i</name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
                            <continue>continue;</continue>
                        }</block></then></if>
                    }</block></then></if></elseif>
                    <elseif>else <if>if <condition>(<expr><call><name>IsTagName</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>closingTagArray</name></expr></argument>, <argument><expr><literal type="string">"&lt;/STYLE&gt;"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <block>{
                        <expr_stmt><expr><call><name>ReplaceClosingStyleTag</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>closingTagArray</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><modifier>ref</modifier> <expr><name>charBuffer</name></expr></argument>, <argument><modifier>ref</modifier> <expr><name>writeIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <comment type="line">// Strip &lt;/style&gt; even if style is invalid.</comment>
                        <expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">7</literal></expr>;</expr_stmt>
                        <continue>continue;</continue>
                    }</block></then></if></elseif></if>
                }</block></then></if>

                <if>if <condition>(<expr><name>writeIndex</name> <operator>==</operator> <name><name>charBuffer</name><operator>.</operator><name>Length</name></name></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><call><name>ResizeInternalArray</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>charBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block></then></if>

                <expr_stmt><expr><name><name>charBuffer</name><index>[<expr><name>writeIndex</name></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>writeIndex</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            }</block></for>

            <return>return <expr><literal type="boolean">true</literal></expr>;</return>
        }</block></function>

        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Method to handle inline replacement of style tag by closing style definition.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;param name="sourceText"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="srcIndex"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="charBuffer"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="writeIndex"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;returns&gt;&lt;/returns&gt;</comment>
        <function><type><name>bool</name></type> <name>ReplaceClosingStyleTag</name><parameter_list>(<parameter><decl><type><modifier>ref</modifier> <name>StringBuilder</name></type> <name>sourceText</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>srcIndex</name></decl></parameter>, <parameter><decl><type><name><modifier>ref</modifier> <name>int</name><index>[]</index></name></type> <name>charBuffer</name></decl></parameter>, <parameter><decl><type><modifier>ref</modifier> <name>int</name></type> <name>writeIndex</name></decl></parameter>)</parameter_list>
        <block>{
            <comment type="line">// Get style from the Style Stack</comment>
            <decl_stmt><decl><type><name>int</name></type> <name>hashCode</name> <init>= <expr><call><name><name>m_styleStack</name><operator>.</operator><name>CurrentItem</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>TMP_Style</name></type> <name>style</name> <init>= <expr><call><name><name>TMP_StyleSheet</name><operator>.</operator><name>GetStyle</name></name><argument_list>(<argument><expr><name>hashCode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name><name>m_styleStack</name><operator>.</operator><name>Remove</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// Return if we don't have a valid style.</comment>
            <if>if <condition>(<expr><name>style</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block type="pseudo"><return>return <expr><literal type="boolean">false</literal></expr>;</return></block></then></if>

            <decl_stmt><decl><type><name>int</name></type> <name>styleLength</name> <init>= <expr><name><name>style</name><operator>.</operator><name>styleClosingTagArray</name><operator>.</operator><name>Length</name></name></expr></init></decl>;</decl_stmt>

            <comment type="line">// Replace &lt;style&gt; tag with opening definition</comment>
            <decl_stmt><decl><type><name><name>int</name><index>[]</index></name></type> <name>closingTagArray</name> <init>= <expr><name><name>style</name><operator>.</operator><name>styleClosingTagArray</name></name></expr></init></decl>;</decl_stmt>

            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>styleLength</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{
                <decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><name><name>closingTagArray</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

                <if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="number">60</literal></expr>)</condition><then>
                <block>{
                    <if>if <condition>(<expr><call><name>IsTagName</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>closingTagArray</name></expr></argument>, <argument><expr><literal type="string">"&lt;BR&gt;"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <block>{
                        <if>if <condition>(<expr><name>writeIndex</name> <operator>==</operator> <name><name>charBuffer</name><operator>.</operator><name>Length</name></name></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><call><name>ResizeInternalArray</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>charBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block></then></if>

                        <expr_stmt><expr><name><name>charBuffer</name><index>[<expr><name>writeIndex</name></expr>]</index></name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
                        <expr_stmt><expr><name>writeIndex</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                        <expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>

                        <continue>continue;</continue>
                    }</block></then>
                    <elseif>else <if>if <condition>(<expr><call><name>IsTagName</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>closingTagArray</name></expr></argument>, <argument><expr><literal type="string">"&lt;STYLE="</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <block>{
                        <decl_stmt><decl><type><name>int</name></type> <name>offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                        <if>if <condition>(<expr><call><name>ReplaceOpeningStyleTag</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>closingTagArray</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><modifier>out</modifier> <expr><name>offset</name></expr></argument>, <argument><modifier>ref</modifier> <expr><name>charBuffer</name></expr></argument>, <argument><modifier>ref</modifier> <expr><name>writeIndex</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                        <block>{
                            <expr_stmt><expr><name>i</name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
                            <continue>continue;</continue>
                        }</block></then></if>
                    }</block></then></if></elseif>
                    <elseif>else <if>if <condition>(<expr><call><name>IsTagName</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>closingTagArray</name></expr></argument>, <argument><expr><literal type="string">"&lt;/STYLE&gt;"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <block>{
                        <expr_stmt><expr><call><name>ReplaceClosingStyleTag</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>closingTagArray</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><modifier>ref</modifier> <expr><name>charBuffer</name></expr></argument>, <argument><modifier>ref</modifier> <expr><name>writeIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <comment type="line">// Strip &lt;/style&gt; even if style is invalid.</comment>
                        <expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">7</literal></expr>;</expr_stmt>
                        <continue>continue;</continue>
                    }</block></then></if></elseif></if>
                }</block></then></if>

                <if>if <condition>(<expr><name>writeIndex</name> <operator>==</operator> <name><name>charBuffer</name><operator>.</operator><name>Length</name></name></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><call><name>ResizeInternalArray</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>charBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block></then></if>

                <expr_stmt><expr><name><name>charBuffer</name><index>[<expr><name>writeIndex</name></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>writeIndex</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            }</block></for>

            <return>return <expr><literal type="boolean">true</literal></expr>;</return>
        }</block></function>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Method to check for a matching rich text tag.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;param name="text"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="tag"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="index"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;returns&gt;&lt;/returns&gt;</comment>
        <function><type><name>bool</name></type> <name>IsTagName</name> <parameter_list>(<parameter><decl><type><modifier>ref</modifier> <name>string</name></type> <name>text</name></decl></parameter>, <parameter><decl><type><name>string</name></type> <name>tag</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>index</name></decl></parameter>)</parameter_list>
        <block>{
            <if>if <condition>(<expr><name><name>text</name><operator>.</operator><name>Length</name></name> <operator>&lt;</operator> <name>index</name> <operator>+</operator> <name><name>tag</name><operator>.</operator><name>Length</name></name></expr>)</condition><then> <block type="pseudo"><return>return <expr><literal type="boolean">false</literal></expr>;</return></block></then></if>
            
            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tag</name><operator>.</operator><name>Length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{
                <if>if <condition>(<expr><call><name><name>TMP_TextUtilities</name><operator>.</operator><name>ToUpperFast</name></name><argument_list>(<argument><expr><name><name>text</name><index>[<expr><name>index</name> <operator>+</operator> <name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name><name>tag</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then> <block type="pseudo"><return>return <expr><literal type="boolean">false</literal></expr>;</return></block></then></if>
            }</block></for>

            <return>return <expr><literal type="boolean">true</literal></expr>;</return>
        }</block></function>

        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Method to check for a matching rich text tag.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;param name="text"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="tag"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="index"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;returns&gt;&lt;/returns&gt;</comment>
        <function><type><name>bool</name></type> <name>IsTagName</name><parameter_list>(<parameter><decl><type><name><modifier>ref</modifier> <name>char</name><index>[]</index></name></type> <name>text</name></decl></parameter>, <parameter><decl><type><name>string</name></type> <name>tag</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>index</name></decl></parameter>)</parameter_list>
        <block>{
            <if>if <condition>(<expr><name><name>text</name><operator>.</operator><name>Length</name></name> <operator>&lt;</operator> <name>index</name> <operator>+</operator> <name><name>tag</name><operator>.</operator><name>Length</name></name></expr>)</condition><then> <block type="pseudo"><return>return <expr><literal type="boolean">false</literal></expr>;</return></block></then></if>

            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tag</name><operator>.</operator><name>Length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{
                <if>if <condition>(<expr><call><name><name>TMP_TextUtilities</name><operator>.</operator><name>ToUpperFast</name></name><argument_list>(<argument><expr><name><name>text</name><index>[<expr><name>index</name> <operator>+</operator> <name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name><name>tag</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then> <block type="pseudo"><return>return <expr><literal type="boolean">false</literal></expr>;</return></block></then></if>
            }</block></for>

            <return>return <expr><literal type="boolean">true</literal></expr>;</return>
        }</block></function>

        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Method to check for a matching rich text tag.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;param name="text"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="tag"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="index"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;returns&gt;&lt;/returns&gt;</comment>
        <function><type><name>bool</name></type> <name>IsTagName</name><parameter_list>(<parameter><decl><type><name><modifier>ref</modifier> <name>int</name><index>[]</index></name></type> <name>text</name></decl></parameter>, <parameter><decl><type><name>string</name></type> <name>tag</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>index</name></decl></parameter>)</parameter_list>
        <block>{
            <if>if <condition>(<expr><name><name>text</name><operator>.</operator><name>Length</name></name> <operator>&lt;</operator> <name>index</name> <operator>+</operator> <name><name>tag</name><operator>.</operator><name>Length</name></name></expr>)</condition><then> <block type="pseudo"><return>return <expr><literal type="boolean">false</literal></expr>;</return></block></then></if>

            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tag</name><operator>.</operator><name>Length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{
                <if>if <condition>(<expr><call><name><name>TMP_TextUtilities</name><operator>.</operator><name>ToUpperFast</name></name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>)</operator><name><name>text</name><index>[<expr><name>index</name> <operator>+</operator> <name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name><name>tag</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then> <block type="pseudo"><return>return <expr><literal type="boolean">false</literal></expr>;</return></block></then></if>
            }</block></for>

            <return>return <expr><literal type="boolean">true</literal></expr>;</return>
        }</block></function>

        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Method to check for a matching rich text tag.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;param name="text"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="tag"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="index"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;returns&gt;&lt;/returns&gt;</comment>
        <function><type><name>bool</name></type> <name>IsTagName</name><parameter_list>(<parameter><decl><type><modifier>ref</modifier> <name>StringBuilder</name></type> <name>text</name></decl></parameter>, <parameter><decl><type><name>string</name></type> <name>tag</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>index</name></decl></parameter>)</parameter_list>
        <block>{
            <if>if <condition>(<expr><name><name>text</name><operator>.</operator><name>Length</name></name> <operator>&lt;</operator> <name>index</name> <operator>+</operator> <name><name>tag</name><operator>.</operator><name>Length</name></name></expr>)</condition><then> <block type="pseudo"><return>return <expr><literal type="boolean">false</literal></expr>;</return></block></then></if>

            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tag</name><operator>.</operator><name>Length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{
                <if>if <condition>(<expr><call><name><name>TMP_TextUtilities</name><operator>.</operator><name>ToUpperFast</name></name><argument_list>(<argument><expr><name><name>text</name><index>[<expr><name>index</name> <operator>+</operator> <name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name><name>tag</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then> <block type="pseudo"><return>return <expr><literal type="boolean">false</literal></expr>;</return></block></then></if>
            }</block></for>

            <return>return <expr><literal type="boolean">true</literal></expr>;</return>
        }</block></function>

        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Get Hashcode for a given tag.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;param name="text"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="index"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="closeIndex"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;returns&gt;&lt;/returns&gt;</comment>
        <function><type><name>int</name></type> <name>GetTagHashCode</name><parameter_list>(<parameter><decl><type><modifier>ref</modifier> <name>string</name></type> <name>text</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><modifier>out</modifier> <name>int</name></type> <name>closeIndex</name></decl></parameter>)</parameter_list>
        <block>{
            <decl_stmt><decl><type><name>int</name></type> <name>hashCode</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>closeIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>index</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>text</name><operator>.</operator><name>Length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{
                <comment type="line">// Skip quote '"' character</comment>
                <if>if <condition>(<expr><name><name>text</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="number">34</literal></expr>)</condition><then> <block type="pseudo"><continue>continue;</continue></block></then></if>

                <comment type="line">// Break at '&gt;'</comment>
                <if>if <condition>(<expr><name><name>text</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="number">62</literal></expr>)</condition><then> <block>{ <expr_stmt><expr><name>closeIndex</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt> <break>break;</break> }</block></then></if>

                <expr_stmt><expr><name>hashCode</name> <operator>=</operator> <operator>(</operator><name>hashCode</name> <operator>&lt;&lt;</operator> <literal type="number">5</literal><operator>)</operator> <operator>+</operator> <name>hashCode</name> <operator>^</operator> <name><name>text</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
            }</block></for>

            <return>return <expr><name>hashCode</name></expr>;</return>
        }</block></function>

        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Get Hashcode for a given tag.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;param name="text"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="index"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="closeIndex"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;returns&gt;&lt;/returns&gt;</comment>
        <function><type><name>int</name></type> <name>GetTagHashCode</name><parameter_list>(<parameter><decl><type><name><modifier>ref</modifier> <name>char</name><index>[]</index></name></type> <name>text</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><modifier>out</modifier> <name>int</name></type> <name>closeIndex</name></decl></parameter>)</parameter_list>
        <block>{
            <decl_stmt><decl><type><name>int</name></type> <name>hashCode</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>closeIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>index</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>text</name><operator>.</operator><name>Length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{
                <comment type="line">// Skip quote '"' character</comment>
                <if>if <condition>(<expr><name><name>text</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="number">34</literal></expr>)</condition><then> <block type="pseudo"><continue>continue;</continue></block></then></if>

                <comment type="line">// Break at '&gt;'</comment>
                <if>if <condition>(<expr><name><name>text</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="number">62</literal></expr>)</condition><then> <block>{ <expr_stmt><expr><name>closeIndex</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt> <break>break;</break> }</block></then></if>

                <expr_stmt><expr><name>hashCode</name> <operator>=</operator> <operator>(</operator><name>hashCode</name> <operator>&lt;&lt;</operator> <literal type="number">5</literal><operator>)</operator> <operator>+</operator> <name>hashCode</name> <operator>^</operator> <name><name>text</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
            }</block></for>

            <return>return <expr><name>hashCode</name></expr>;</return>
        }</block></function>

        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Get Hashcode for a given tag.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;param name="text"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="index"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="closeIndex"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;returns&gt;&lt;/returns&gt;</comment>
        <function><type><name>int</name></type> <name>GetTagHashCode</name><parameter_list>(<parameter><decl><type><name><modifier>ref</modifier> <name>int</name><index>[]</index></name></type> <name>text</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><modifier>out</modifier> <name>int</name></type> <name>closeIndex</name></decl></parameter>)</parameter_list>
        <block>{
            <decl_stmt><decl><type><name>int</name></type> <name>hashCode</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>closeIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>index</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>text</name><operator>.</operator><name>Length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{
                <comment type="line">// Skip quote '"' character</comment>
                <if>if <condition>(<expr><name><name>text</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="number">34</literal></expr>)</condition><then> <block type="pseudo"><continue>continue;</continue></block></then></if>

                <comment type="line">// Break at '&gt;'</comment>
                <if>if <condition>(<expr><name><name>text</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="number">62</literal></expr>)</condition><then> <block>{ <expr_stmt><expr><name>closeIndex</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt> <break>break;</break> }</block></then></if>

                <expr_stmt><expr><name>hashCode</name> <operator>=</operator> <operator>(</operator><name>hashCode</name> <operator>&lt;&lt;</operator> <literal type="number">5</literal><operator>)</operator> <operator>+</operator> <name>hashCode</name> <operator>^</operator> <name><name>text</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
            }</block></for>

            <return>return <expr><name>hashCode</name></expr>;</return>
        }</block></function>

        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">///  Get Hashcode for a given tag.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;param name="text"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="index"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="closeIndex"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;returns&gt;&lt;/returns&gt;</comment>
        <function><type><name>int</name></type> <name>GetTagHashCode</name><parameter_list>(<parameter><decl><type><modifier>ref</modifier> <name>StringBuilder</name></type> <name>text</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><modifier>out</modifier> <name>int</name></type> <name>closeIndex</name></decl></parameter>)</parameter_list>
        <block>{
            <decl_stmt><decl><type><name>int</name></type> <name>hashCode</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>closeIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>index</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>text</name><operator>.</operator><name>Length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{
                <comment type="line">// Skip quote '"' character</comment>
                <if>if <condition>(<expr><name><name>text</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="number">34</literal></expr>)</condition><then> <block type="pseudo"><continue>continue;</continue></block></then></if>

                <comment type="line">// Break at '&gt;'</comment>
                <if>if <condition>(<expr><name><name>text</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="number">62</literal></expr>)</condition><then> <block>{ <expr_stmt><expr><name>closeIndex</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt> <break>break;</break> }</block></then></if>

                <expr_stmt><expr><name>hashCode</name> <operator>=</operator> <operator>(</operator><name>hashCode</name> <operator>&lt;&lt;</operator> <literal type="number">5</literal><operator>)</operator> <operator>+</operator> <name>hashCode</name> <operator>^</operator> <name><name>text</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
            }</block></for>

            <return>return <expr><name>hashCode</name></expr>;</return>
        }</block></function>

        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// </comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <function><type><name>void</name></type> <name><name>ResizeInternalArray</name> <argument_list type="generic">&lt;<argument><name>T</name></argument>&gt;</argument_list></name><parameter_list>(<parameter><decl><type><name><modifier>ref</modifier> <name>T</name><index>[]</index></name></type> <name>array</name></decl></parameter>)</parameter_list>
        <block>{
            <decl_stmt><decl><type><name>int</name></type> <name>size</name> <init>= <expr><call><name><name>Mathf</name><operator>.</operator><name>NextPowerOfTwo</name></name><argument_list>(<argument><expr><name><name>array</name><operator>.</operator><name>Length</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name><name>System</name><operator>.</operator><name>Array</name><operator>.</operator><name>Resize</name></name><argument_list>(<argument><modifier>ref</modifier> <expr><name>array</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></function>


        <decl_stmt><decl><specifier>private</specifier> <type><specifier>readonly</specifier> <name><name>float</name><index>[]</index></name></type> <name>k_Power</name> <init>= <expr><block>{ <expr><literal type="number">5e-1f</literal></expr>, <expr><literal type="number">5e-2f</literal></expr>, <expr><literal type="number">5e-3f</literal></expr>, <expr><literal type="number">5e-4f</literal></expr>, <expr><literal type="number">5e-5f</literal></expr>, <expr><literal type="number">5e-6f</literal></expr>, <expr><literal type="number">5e-7f</literal></expr>, <expr><literal type="number">5e-8f</literal></expr>, <expr><literal type="number">5e-9f</literal></expr>, <expr><literal type="number">5e-10f</literal></expr> }</block></expr></init></decl>;</decl_stmt> <comment type="line">// Used by FormatText to enable rounding and avoid using Mathf.Pow.</comment>

        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Function used in conjunction with SetText()</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;param name="number"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="index"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="precision"&gt;&lt;/param&gt;</comment>
        <function><specifier>protected</specifier> <type><name>void</name></type> <name>AddFloatToCharArray</name><parameter_list>(<parameter><decl><type><name>float</name></type> <name>number</name></decl></parameter>, <parameter><decl><type><modifier>ref</modifier> <name>int</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>precision</name></decl></parameter>)</parameter_list>
        <block>{
            <if>if <condition>(<expr><name>number</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then>
            <block>{
                <expr_stmt><expr><name><name>m_input_CharArray</name><index>[<expr><name>index</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'-'</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>number</name> <operator>=</operator> <operator>-</operator><name>number</name></expr>;</expr_stmt>
            }</block></then></if>

            <expr_stmt><expr><name>number</name> <operator>+=</operator> <name><name>k_Power</name><index>[<expr><call><name><name>Mathf</name><operator>.</operator><name>Min</name></name><argument_list>(<argument><expr><literal type="number">9</literal></expr></argument>, <argument><expr><name>precision</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt>

            <decl_stmt><decl><type><name>int</name></type> <name>integer</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><name>number</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>AddIntToCharArray</name><argument_list>(<argument><expr><name>integer</name></expr></argument>, <argument><modifier>ref</modifier> <expr><name>index</name></expr></argument>, <argument><expr><name>precision</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if>if <condition>(<expr><name>precision</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><then>
            <block>{
                <comment type="line">// Add the decimal point</comment>
                <expr_stmt><expr><name><name>m_input_CharArray</name><index>[<expr><name>index</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'.'</literal></expr>;</expr_stmt>

                <expr_stmt><expr><name>number</name> <operator>-=</operator> <name>integer</name></expr>;</expr_stmt>
                <for>for <control>(<init><decl><type><name>int</name></type> <name>p</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>p</name> <operator>&lt;</operator> <name>precision</name></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control>
                <block>{
                    <expr_stmt><expr><name>number</name> <operator>*=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
                    <decl_stmt><decl><type><name>int</name></type> <name>d</name> <init>= <expr><call>(<name>int</name>)<argument_list>(<argument><expr><name>number</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><name><name>m_input_CharArray</name><index>[<expr><name>index</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call>(<name>char</name>)<argument_list>(<argument><expr><name>d</name> <operator>+</operator> <literal type="number">48</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>number</name> <operator>-=</operator> <name>d</name></expr>;</expr_stmt>
                }</block></for>
            }</block></then></if>
        }</block></function>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// // Function used in conjunction with SetText()</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;param name="number"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="index"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="precision"&gt;&lt;/param&gt;</comment>
        <function><specifier>protected</specifier> <type><name>void</name></type> <name>AddIntToCharArray</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>number</name></decl></parameter>, <parameter><decl><type><modifier>ref</modifier> <name>int</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>precision</name></decl></parameter>)</parameter_list>
        <block>{
            <if>if <condition>(<expr><name>number</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><then>
            <block>{
                <expr_stmt><expr><name><name>m_input_CharArray</name><index>[<expr><name>index</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'-'</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>number</name> <operator>=</operator> <operator>-</operator><name>number</name></expr>;</expr_stmt>
            }</block></then></if>

            <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>index</name></expr></init></decl>;</decl_stmt>
            <do>do
            <block>{
                <expr_stmt><expr><name><name>m_input_CharArray</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call>(<name>char</name>)<argument_list>(<argument><expr><name>number</name> <operator>%</operator> <literal type="number">10</literal> <operator>+</operator> <literal type="number">48</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>number</name> <operator>/=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
            }</block> while <condition>(<expr><name>number</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>;</do>

            <decl_stmt><decl><type><name>int</name></type> <name>lastIndex</name> <init>= <expr><name>i</name></expr></init></decl>;</decl_stmt>

            <comment type="line">// Reverse string</comment>
            <while>while <condition>(<expr><name>index</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name>i</name></expr>)</condition>
            <block>{
                <expr_stmt><expr><name>i</name> <operator>-=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                <decl_stmt><decl><type><name>char</name></type> <name>t</name> <init>= <expr><name><name>m_input_CharArray</name><index>[<expr><name>index</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name><name>m_input_CharArray</name><index>[<expr><name>index</name></expr>]</index></name> <operator>=</operator> <name><name>m_input_CharArray</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>m_input_CharArray</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>t</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>index</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            }</block></while>
            <expr_stmt><expr><name>index</name> <operator>=</operator> <name>lastIndex</name></expr>;</expr_stmt>
        }</block></function>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Method used to determine the number of visible characters and required buffer allocations.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;param name="chars"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;returns&gt;&lt;/returns&gt;</comment>
        <function><specifier>protected</specifier> <specifier>virtual</specifier> <type><name>int</name></type> <name>SetArraySizes</name><parameter_list>(<parameter><decl><type><name><name>int</name><index>[]</index></name></type> <name>chars</name></decl></parameter>)</parameter_list> <block>{ <return>return <expr><literal type="number">0</literal></expr>;</return> }</block></function>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Method which parses the text input, does the layout of the text as well as generating the geometry.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <function><specifier>protected</specifier> <specifier>virtual</specifier> <type><name>void</name></type> <name>GenerateTextMesh</name><parameter_list>()</parameter_list> <block>{ }</block></function>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Function to Calculate the Preferred Width and Height of the text object.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;returns&gt;&lt;/returns&gt;</comment>
        <function><specifier>public</specifier> <type><name>Vector2</name></type> <name>GetPreferredValues</name><parameter_list>()</parameter_list>
        <block>{
            <if>if <condition>(<expr><name>m_isInputParsingRequired</name> <operator>||</operator> <name>m_isTextTruncated</name></expr>)</condition><then>
            <block>{
                <expr_stmt><expr><name>m_isCalculatingPreferredValues</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ParseInputText</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>

            <comment type="line">// CALCULATE PREFERRED WIDTH</comment>
            <decl_stmt><decl><type><name>float</name></type> <name>preferredWidth</name> <init>= <expr><call><name>GetPreferredWidth</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// CALCULATE PREFERRED HEIGHT</comment>
            <decl_stmt><decl><type><name>float</name></type> <name>preferredHeight</name> <init>= <expr><call><name>GetPreferredHeight</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

            <return>return <expr><operator>new</operator> <call><name>Vector2</name><argument_list>(<argument><expr><name>preferredWidth</name></expr></argument>, <argument><expr><name>preferredHeight</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></function>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Function to Calculate the Preferred Width and Height of the text object given the provided width and height.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;returns&gt;&lt;/returns&gt;</comment>
        <function><specifier>public</specifier> <type><name>Vector2</name></type> <name>GetPreferredValues</name><parameter_list>(<parameter><decl><type><name>float</name></type> <name>width</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>height</name></decl></parameter>)</parameter_list>
        <block>{
            <if>if <condition>(<expr><name>m_isInputParsingRequired</name> <operator>||</operator> <name>m_isTextTruncated</name></expr>)</condition><then>
            <block>{
                <expr_stmt><expr><name>m_isCalculatingPreferredValues</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ParseInputText</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>

            <decl_stmt><decl><type><name>Vector2</name></type> <name>margin</name> <init>= <expr><operator>new</operator> <call><name>Vector2</name><argument_list>(<argument><expr><name>width</name></expr></argument>, <argument><expr><name>height</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// CALCULATE PREFERRED WIDTH</comment>
            <decl_stmt><decl><type><name>float</name></type> <name>preferredWidth</name> <init>= <expr><call><name>GetPreferredWidth</name><argument_list>(<argument><expr><name>margin</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// CALCULATE PREFERRED HEIGHT</comment>
            <decl_stmt><decl><type><name>float</name></type> <name>preferredHeight</name> <init>= <expr><call><name>GetPreferredHeight</name><argument_list>(<argument><expr><name>margin</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <return>return <expr><operator>new</operator> <call><name>Vector2</name><argument_list>(<argument><expr><name>preferredWidth</name></expr></argument>, <argument><expr><name>preferredHeight</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></function>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Function to Calculate the Preferred Width and Height of the text object given a certain string.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;param name="text"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;returns&gt;&lt;/returns&gt;</comment>
        <function><specifier>public</specifier> <type><name>Vector2</name></type> <name>GetPreferredValues</name><parameter_list>(<parameter><decl><type><name>string</name></type> <name>text</name></decl></parameter>)</parameter_list>
        <block>{
            <expr_stmt><expr><name>m_isCalculatingPreferredValues</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>StringToCharArray</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><modifier>ref</modifier> <expr><name>m_char_buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SetArraySizes</name><argument_list>(<argument><expr><name>m_char_buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <decl_stmt><decl><type><name>Vector2</name></type> <name>margin</name> <init>= <expr><name>k_LargePositiveVector2</name></expr></init></decl>;</decl_stmt>

            <comment type="line">// CALCULATE PREFERRED WIDTH</comment>
            <decl_stmt><decl><type><name>float</name></type> <name>preferredWidth</name> <init>= <expr><call><name>GetPreferredWidth</name><argument_list>(<argument><expr><name>margin</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// CALCULATE PREFERRED HEIGHT</comment>
            <decl_stmt><decl><type><name>float</name></type> <name>preferredHeight</name> <init>= <expr><call><name>GetPreferredHeight</name><argument_list>(<argument><expr><name>margin</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <return>return <expr><operator>new</operator> <call><name>Vector2</name><argument_list>(<argument><expr><name>preferredWidth</name></expr></argument>, <argument><expr><name>preferredHeight</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></function>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">///  Function to Calculate the Preferred Width and Height of the text object given a certain string and size of text container.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;param name="text"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;returns&gt;&lt;/returns&gt;</comment>
        <function><specifier>public</specifier> <type><name>Vector2</name></type> <name>GetPreferredValues</name><parameter_list>(<parameter><decl><type><name>string</name></type> <name>text</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>width</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>height</name></decl></parameter>)</parameter_list>
        <block>{
            <expr_stmt><expr><name>m_isCalculatingPreferredValues</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>StringToCharArray</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><modifier>ref</modifier> <expr><name>m_char_buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SetArraySizes</name><argument_list>(<argument><expr><name>m_char_buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <decl_stmt><decl><type><name>Vector2</name></type> <name>margin</name> <init>= <expr><operator>new</operator> <call><name>Vector2</name><argument_list>(<argument><expr><name>width</name></expr></argument>, <argument><expr><name>height</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// CALCULATE PREFERRED WIDTH</comment>
            <decl_stmt><decl><type><name>float</name></type> <name>preferredWidth</name> <init>= <expr><call><name>GetPreferredWidth</name><argument_list>(<argument><expr><name>margin</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// CALCULATE PREFERRED HEIGHT</comment>
            <decl_stmt><decl><type><name>float</name></type> <name>preferredHeight</name> <init>= <expr><call><name>GetPreferredHeight</name><argument_list>(<argument><expr><name>margin</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <return>return <expr><operator>new</operator> <call><name>Vector2</name><argument_list>(<argument><expr><name>preferredWidth</name></expr></argument>, <argument><expr><name>preferredHeight</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></function>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Method to calculate the preferred width of a text object.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;returns&gt;&lt;/returns&gt;</comment>
        <function><specifier>protected</specifier> <type><name>float</name></type> <name>GetPreferredWidth</name><parameter_list>()</parameter_list>
        <block>{
            <if>if <condition>(<expr><name><name>TMP_Settings</name><operator>.</operator><name>instance</name></name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block type="pseudo"><return>return <expr><literal type="number">0</literal></expr>;</return></block></then></if>

            <decl_stmt><decl><type><name>float</name></type> <name>fontSize</name> <init>= <expr><ternary><condition><expr><name>m_enableAutoSizing</name></expr> ?</condition><then> <expr><name>m_fontSizeMax</name></expr> </then><else>: <expr><name>m_fontSize</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

            <comment type="line">// Reset auto sizing point size bounds</comment>
            <expr_stmt><expr><name>m_minFontSize</name> <operator>=</operator> <name>m_fontSizeMin</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>m_maxFontSize</name> <operator>=</operator> <name>m_fontSizeMax</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>m_charWidthAdjDelta</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

            <comment type="line">// Set Margins to Infinity</comment>
            <decl_stmt><decl><type><name>Vector2</name></type> <name>margin</name> <init>= <expr><name>k_LargePositiveVector2</name></expr></init></decl>;</decl_stmt>

            <if>if <condition>(<expr><name>m_isInputParsingRequired</name> <operator>||</operator> <name>m_isTextTruncated</name></expr>)</condition><then>
            <block>{
                <expr_stmt><expr><name>m_isCalculatingPreferredValues</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ParseInputText</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>

            <expr_stmt><expr><name>m_recursiveCount</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>float</name></type> <name>preferredWidth</name> <init>= <expr><call><name>CalculatePreferredValues</name><argument_list>(<argument><expr><name>fontSize</name></expr></argument>, <argument><expr><name>margin</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call><operator>.</operator><name>x</name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name>m_isPreferredWidthDirty</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>

            <comment type="line">//Debug.Log("GetPreferredWidth() Called at frame " + Time.frameCount + ". Returning width of " + preferredWidth);</comment>

            <return>return <expr><name>preferredWidth</name></expr>;</return>
        }</block></function>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Method to calculate the preferred width of a text object.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;param name="margin"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;returns&gt;&lt;/returns&gt;</comment>
        <function><specifier>protected</specifier> <type><name>float</name></type> <name>GetPreferredWidth</name><parameter_list>(<parameter><decl><type><name>Vector2</name></type> <name>margin</name></decl></parameter>)</parameter_list>
        <block>{
            <decl_stmt><decl><type><name>float</name></type> <name>fontSize</name> <init>= <expr><ternary><condition><expr><name>m_enableAutoSizing</name></expr> ?</condition><then> <expr><name>m_fontSizeMax</name></expr> </then><else>: <expr><name>m_fontSize</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

            <comment type="line">// Reset auto sizing point size bounds</comment>
            <expr_stmt><expr><name>m_minFontSize</name> <operator>=</operator> <name>m_fontSizeMin</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>m_maxFontSize</name> <operator>=</operator> <name>m_fontSizeMax</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>m_charWidthAdjDelta</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

            <expr_stmt><expr><name>m_recursiveCount</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>float</name></type> <name>preferredWidth</name> <init>= <expr><call><name>CalculatePreferredValues</name><argument_list>(<argument><expr><name>fontSize</name></expr></argument>, <argument><expr><name>margin</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call><operator>.</operator><name>x</name></expr></init></decl>;</decl_stmt>

            <comment type="line">//Debug.Log("GetPreferredWidth() Called. Returning width of " + preferredWidth);</comment>

            <return>return <expr><name>preferredWidth</name></expr>;</return>
        }</block></function>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Method to calculate the preferred height of a text object.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;returns&gt;&lt;/returns&gt;</comment>
        <function><specifier>protected</specifier> <type><name>float</name></type> <name>GetPreferredHeight</name><parameter_list>()</parameter_list>
        <block>{
            <if>if <condition>(<expr><name><name>TMP_Settings</name><operator>.</operator><name>instance</name></name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block type="pseudo"><return>return <expr><literal type="number">0</literal></expr>;</return></block></then></if>

            <decl_stmt><decl><type><name>float</name></type> <name>fontSize</name> <init>= <expr><ternary><condition><expr><name>m_enableAutoSizing</name></expr> ?</condition><then> <expr><name>m_fontSizeMax</name></expr> </then><else>: <expr><name>m_fontSize</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

            <comment type="line">// Reset auto sizing point size bounds</comment>
            <expr_stmt><expr><name>m_minFontSize</name> <operator>=</operator> <name>m_fontSizeMin</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>m_maxFontSize</name> <operator>=</operator> <name>m_fontSizeMax</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>m_charWidthAdjDelta</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

            <decl_stmt><decl><type><name>Vector2</name></type> <name>margin</name> <init>= <expr><operator>new</operator> <call><name>Vector2</name><argument_list>(<argument><expr><ternary><condition><expr><name>m_marginWidth</name> <operator>!=</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>m_marginWidth</name></expr> </then><else>: <expr><name>k_LargePositiveFloat</name></expr></else></ternary></expr></argument>, <argument><expr><name>k_LargePositiveFloat</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if>if <condition>(<expr><name>m_isInputParsingRequired</name> <operator>||</operator> <name>m_isTextTruncated</name></expr>)</condition><then>
            <block>{
                <expr_stmt><expr><name>m_isCalculatingPreferredValues</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ParseInputText</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>

            <expr_stmt><expr><name>m_recursiveCount</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>float</name></type> <name>preferredHeight</name> <init>= <expr><call><name>CalculatePreferredValues</name><argument_list>(<argument><expr><name>fontSize</name></expr></argument>, <argument><expr><name>margin</name></expr></argument>, <argument><expr><operator>!</operator><name>m_enableAutoSizing</name></expr></argument>)</argument_list></call><operator>.</operator><name>y</name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name>m_isPreferredHeightDirty</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>

            <comment type="line">//Debug.Log("GetPreferredHeight() Called. Returning height of " + preferredHeight);</comment>

            <return>return <expr><name>preferredHeight</name></expr>;</return>
        }</block></function>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Method to calculate the preferred height of a text object.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;param name="margin"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;returns&gt;&lt;/returns&gt;</comment>
        <function><specifier>protected</specifier> <type><name>float</name></type> <name>GetPreferredHeight</name><parameter_list>(<parameter><decl><type><name>Vector2</name></type> <name>margin</name></decl></parameter>)</parameter_list>
        <block>{
            <decl_stmt><decl><type><name>float</name></type> <name>fontSize</name> <init>= <expr><ternary><condition><expr><name>m_enableAutoSizing</name></expr> ?</condition><then> <expr><name>m_fontSizeMax</name></expr> </then><else>: <expr><name>m_fontSize</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

            <comment type="line">// Reset auto sizing point size bounds</comment>
            <expr_stmt><expr><name>m_minFontSize</name> <operator>=</operator> <name>m_fontSizeMin</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>m_maxFontSize</name> <operator>=</operator> <name>m_fontSizeMax</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>m_charWidthAdjDelta</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

            <expr_stmt><expr><name>m_recursiveCount</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>float</name></type> <name>preferredHeight</name> <init>= <expr><call><name>CalculatePreferredValues</name><argument_list>(<argument><expr><name>fontSize</name></expr></argument>, <argument><expr><name>margin</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call><operator>.</operator><name>y</name></expr></init></decl>;</decl_stmt>

            <comment type="line">//Debug.Log("GetPreferredHeight() Called. Returning height of " + preferredHeight);</comment>

            <return>return <expr><name>preferredHeight</name></expr>;</return>
        }</block></function>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Method returning the rendered width and height of the text object.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;returns&gt;&lt;/returns&gt;</comment>
        <function><specifier>public</specifier> <type><name>Vector2</name></type> <name>GetRenderedValues</name><parameter_list>()</parameter_list>
        <block>{
            <return>return <expr><call><name>GetTextBounds</name><argument_list>()</argument_list></call><operator>.</operator><name>size</name></expr>;</return>
        }</block></function>

        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// </comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;param name="onlyVisibleCharacters"&gt;Should returned value only factor in visible characters and exclude those greater than maxVisibleCharacters for instance.&lt;/param&gt;</comment>
        <comment type="line">/// &lt;returns&gt;&lt;/returns&gt;</comment>
        <function><specifier>public</specifier> <type><name>Vector2</name></type> <name>GetRenderedValues</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>onlyVisibleCharacters</name></decl></parameter>)</parameter_list>
        <block>{
            <return>return <expr><call><name>GetTextBounds</name><argument_list>(<argument><expr><name>onlyVisibleCharacters</name></expr></argument>)</argument_list></call><operator>.</operator><name>size</name></expr>;</return>
        }</block></function>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Method returning the rendered width of the text object.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;returns&gt;&lt;/returns&gt;</comment>
        <function><specifier>protected</specifier> <type><name>float</name></type> <name>GetRenderedWidth</name><parameter_list>()</parameter_list>
        <block>{
            <return>return <expr><call><name>GetRenderedValues</name><argument_list>()</argument_list></call><operator>.</operator><name>x</name></expr>;</return>
        }</block></function>

        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Method returning the rendered width of the text object.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;returns&gt;&lt;/returns&gt;</comment>
        <function><specifier>protected</specifier> <type><name>float</name></type> <name>GetRenderedWidth</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>onlyVisibleCharacters</name></decl></parameter>)</parameter_list>
        <block>{
            <return>return <expr><call><name>GetRenderedValues</name><argument_list>(<argument><expr><name>onlyVisibleCharacters</name></expr></argument>)</argument_list></call><operator>.</operator><name>x</name></expr>;</return>
        }</block></function>

        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Method returning the rendered height of the text object.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;returns&gt;&lt;/returns&gt;</comment>
        <function><specifier>protected</specifier> <type><name>float</name></type> <name>GetRenderedHeight</name><parameter_list>()</parameter_list>
        <block>{
            <return>return <expr><call><name>GetRenderedValues</name><argument_list>()</argument_list></call><operator>.</operator><name>y</name></expr>;</return>
        }</block></function>

        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Method returning the rendered height of the text object.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;returns&gt;&lt;/returns&gt;</comment>
        <function><specifier>protected</specifier> <type><name>float</name></type> <name>GetRenderedHeight</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>onlyVisibleCharacters</name></decl></parameter>)</parameter_list>
        <block>{
            <return>return <expr><call><name>GetRenderedValues</name><argument_list>(<argument><expr><name>onlyVisibleCharacters</name></expr></argument>)</argument_list></call><operator>.</operator><name>y</name></expr>;</return>
        }</block></function>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Method to calculate the preferred width and height of the text object.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;returns&gt;&lt;/returns&gt;</comment>
        <function><specifier>protected</specifier> <specifier>virtual</specifier> <type><name>Vector2</name></type> <name>CalculatePreferredValues</name><parameter_list>(<parameter><decl><type><name>float</name></type> <name>defaultFontSize</name></decl></parameter>, <parameter><decl><type><name>Vector2</name></type> <name>marginSize</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>ignoreTextAutoSizing</name></decl></parameter>)</parameter_list>
        <block>{
            <comment type="line">//Debug.Log("*** CalculatePreferredValues() ***"); // ***** Frame: " + Time.frameCount);</comment>

            <comment type="line">////Profiler.BeginSample("TMP Generate Text - Phase I");</comment>

            <comment type="line">// Early exit if no font asset was assigned. This should not be needed since LiberationSans SDF will be assigned by default.</comment>
            <if>if <condition>(<expr><name>m_fontAsset</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name><name>m_fontAsset</name><operator>.</operator><name>characterDictionary</name></name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then>
            <block>{
                <expr_stmt><expr><call><name><name>Debug</name><operator>.</operator><name>LogWarning</name></name><argument_list>(<argument><expr><literal type="string">"Can't Generate Mesh! No Font Asset has been assigned to Object ID: "</literal> <operator>+</operator> <call><name><name>this</name><operator>.</operator><name>GetInstanceID</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <return>return <expr><name><name>Vector2</name><operator>.</operator><name>zero</name></name></expr>;</return>
            }</block></then></if>

            <comment type="line">// Early exit if we don't have any Text to generate.</comment>
            <if>if <condition>(<expr><name>m_char_buffer</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name><name>m_char_buffer</name><operator>.</operator><name>Length</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>m_char_buffer</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <operator>(</operator><name>char</name><operator>)</operator><literal type="number">0</literal></expr>)</condition><then>
            <block>{
                <return>return <expr><name><name>Vector2</name><operator>.</operator><name>zero</name></name></expr>;</return>
            }</block></then></if>

            <expr_stmt><expr><name>m_currentFontAsset</name> <operator>=</operator> <name>m_fontAsset</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>m_currentMaterial</name> <operator>=</operator> <name>m_sharedMaterial</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>m_currentMaterialIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>m_materialReferenceStack</name><operator>.</operator><name>SetDefault</name></name><argument_list>(<argument><expr><operator>new</operator> <call><name>MaterialReference</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>m_currentFontAsset</name></expr></argument>, <argument><expr><literal type="null">null</literal></expr></argument>, <argument><expr><name>m_currentMaterial</name></expr></argument>, <argument><expr><name>m_padding</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// Total character count is computed when the text is parsed.</comment>
            <decl_stmt><decl><type><name>int</name></type> <name>totalCharacterCount</name> <init>= <expr><name>m_totalCharacterCount</name></expr></init></decl>;</decl_stmt> <comment type="line">// m_VisibleCharacters.Count;</comment>

            <if>if <condition>(<expr><name>m_internalCharacterInfo</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name>totalCharacterCount</name> <operator>&gt;</operator> <name><name>m_internalCharacterInfo</name><operator>.</operator><name>Length</name></name></expr>)</condition><then>
            <block>{
                <expr_stmt><expr><name>m_internalCharacterInfo</name> <operator>=</operator> <operator>new</operator> <name><name>TMP_CharacterInfo</name><index>[<expr><ternary><condition><expr><name>totalCharacterCount</name> <operator>&gt;</operator> <literal type="number">1024</literal></expr> ?</condition><then> <expr><name>totalCharacterCount</name> <operator>+</operator> <literal type="number">256</literal></expr> </then><else>: <expr><call><name><name>Mathf</name><operator>.</operator><name>NextPowerOfTwo</name></name><argument_list>(<argument><expr><name>totalCharacterCount</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>]</index></name></expr>;</expr_stmt>
            }</block></then></if>

            <comment type="line">// Calculate the scale of the font based on selected font size and sampling point size.</comment>
            <comment type="line">// baseScale is calculated using the font asset assigned to the text object.</comment>
            <decl_stmt><decl><type><name>float</name></type> <name>baseScale</name> <init>= <expr><name>m_fontScale</name> <operator>=</operator> <operator>(</operator><name>defaultFontSize</name> <operator>/</operator> <name><name>m_fontAsset</name><operator>.</operator><name>fontInfo</name><operator>.</operator><name>PointSize</name></name> <operator>*</operator> <name><name>m_fontAsset</name><operator>.</operator><name>fontInfo</name><operator>.</operator><name>Scale</name></name> <operator>*</operator> <operator>(</operator><ternary><condition><expr><name>m_isOrthographic</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0.1f</literal></expr></else></ternary><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>float</name></type> <name>currentElementScale</name> <init>= <expr><name>baseScale</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>m_fontScaleMultiplier</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

            <expr_stmt><expr><name>m_currentFontSize</name> <operator>=</operator> <name>defaultFontSize</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>m_sizeStack</name><operator>.</operator><name>SetDefault</name></name><argument_list>(<argument><expr><name>m_currentFontSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>float</name></type> <name>fontSizeDelta</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

            <decl_stmt><decl><type><name>int</name></type> <name>charCode</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="line">// Holds the character code of the currently being processed character.</comment>

            <expr_stmt><expr><name>m_style</name> <operator>=</operator> <name>m_fontStyle</name></expr>;</expr_stmt> <comment type="line">// Set the default style.</comment>

            <expr_stmt><expr><name>m_lineJustification</name> <operator>=</operator> <name>m_textAlignment</name></expr>;</expr_stmt> <comment type="line">// Sets the line justification mode to match editor alignment.</comment>
            <expr_stmt><expr><call><name><name>m_lineJustificationStack</name><operator>.</operator><name>SetDefault</name></name><argument_list>(<argument><expr><name>m_lineJustification</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <decl_stmt><decl><type><name>float</name></type> <name>bold_xAdvance_multiplier</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt> <comment type="line">// Used to increase spacing between character when style is bold.</comment>

            <expr_stmt><expr><name>m_baselineOffset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <comment type="line">// Used by subscript characters.</comment>
            <expr_stmt><expr><call><name><name>m_baselineOffsetStack</name><operator>.</operator><name>Clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>m_lineOffset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <comment type="line">// Amount of space between lines (font line spacing + m_linespacing).</comment>
            <expr_stmt><expr><name>m_lineHeight</name> <operator>=</operator> <name><name>TMP_Math</name><operator>.</operator><name>FLOAT_UNSET</name></name></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>float</name></type> <name>lineGap</name> <init>= <expr><name><name>m_currentFontAsset</name><operator>.</operator><name>fontInfo</name><operator>.</operator><name>LineHeight</name></name> <operator>-</operator> <operator>(</operator><name><name>m_currentFontAsset</name><operator>.</operator><name>fontInfo</name><operator>.</operator><name>Ascender</name></name> <operator>-</operator> <name><name>m_currentFontAsset</name><operator>.</operator><name>fontInfo</name><operator>.</operator><name>Descender</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name>m_cSpacing</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <comment type="line">// Amount of space added between characters as a result of the use of the &lt;cspace&gt; tag.</comment>
            <expr_stmt><expr><name>m_monoSpacing</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>float</name></type> <name>lineOffsetDelta</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>m_xAdvance</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <comment type="line">// Used to track the position of each character.</comment>
            <decl_stmt><decl><type><name>float</name></type> <name>maxXAdvance</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="line">// Used to determine Preferred Width.</comment>

            <expr_stmt><expr><name>tag_LineIndent</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <comment type="line">// Used for indentation of text.</comment>
            <expr_stmt><expr><name>tag_Indent</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>m_indentStack</name><operator>.</operator><name>SetDefault</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>tag_NoParsing</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
            <comment type="line">//m_isIgnoringAlignment = false;</comment>

            <expr_stmt><expr><name>m_characterCount</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <comment type="line">// Total characters in the char[]</comment>


            <comment type="line">// Tracking of line information</comment>
            <expr_stmt><expr><name>m_firstCharacterOfLine</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>m_maxLineAscender</name> <operator>=</operator> <name>k_LargeNegativeFloat</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>m_maxLineDescender</name> <operator>=</operator> <name>k_LargePositiveFloat</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>m_lineNumber</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

            <decl_stmt><decl><type><name>float</name></type> <name>marginWidth</name> <init>= <expr><name><name>marginSize</name><operator>.</operator><name>x</name></name></expr></init></decl>;</decl_stmt>
            <comment type="line">//float marginHeight = marginSize.y;</comment>
            <expr_stmt><expr><name>m_marginLeft</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>m_marginRight</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>m_width</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

            <comment type="line">// Used by Unity's Auto Layout system.</comment>
            <decl_stmt><decl><type><name>float</name></type> <name>renderedWidth</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>float</name></type> <name>renderedHeight</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>float</name></type> <name>linebreakingWidth</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>m_isCalculatingPreferredValues</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>

            <comment type="line">// Tracking of the highest Ascender</comment>
            <expr_stmt><expr><name>m_maxAscender</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>m_maxDescender</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>


            <comment type="line">// Initialize struct to track states of word wrapping</comment>
            <decl_stmt><decl><type><name>bool</name></type> <name>isFirstWord</name> <init>= <expr><literal type="boolean">true</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bool</name></type> <name>isLastBreakingChar</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>WordWrapState</name></type> <name>savedLineState</name> <init>= <expr><operator>new</operator> <call><name>WordWrapState</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>SaveWordWrappingState</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>savedLineState</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>WordWrapState</name></type> <name>savedWordWrapState</name> <init>= <expr><operator>new</operator> <call><name>WordWrapState</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>wrappingIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

            <comment type="line">// Counter to prevent recursive lockup when computing preferred values.</comment>
            <expr_stmt><expr><name>m_recursiveCount</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

            <decl_stmt><decl><type><name>int</name></type> <name>endTagIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <comment type="line">// Parse through Character buffer to read HTML tags and begin creating mesh.</comment>
            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name><name>m_char_buffer</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{
                <expr_stmt><expr><name>charCode</name> <operator>=</operator> <name><name>m_char_buffer</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

                <comment type="line">// Parse Rich Text Tag</comment>
                <cpp:region>#<cpp:directive>region</cpp:directive> <name>Parse</name> <name>Rich</name> <name>Text</name> <name>Tag</name></cpp:region>
                <if>if <condition>(<expr><name>m_isRichText</name> <operator>&amp;&amp;</operator> <name>charCode</name> <operator>==</operator> <literal type="number">60</literal></expr>)</condition><then>  <comment type="line">// '&lt;'</comment>
                <block>{
                    <expr_stmt><expr><name>m_isParsingText</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><name>m_textElementType</name> <operator>=</operator> <name><name>TMP_TextElementType</name><operator>.</operator><name>Character</name></name></expr>;</expr_stmt>

                    <comment type="line">// Check if Tag is valid. If valid, skip to the end of the validated tag.</comment>
                    <if>if <condition>(<expr><call><name>ValidateHtmlTag</name><argument_list>(<argument><expr><name>m_char_buffer</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><modifier>out</modifier> <expr><name>endTagIndex</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <block>{
                        <expr_stmt><expr><name>i</name> <operator>=</operator> <name>endTagIndex</name></expr>;</expr_stmt>

                        <comment type="line">// Continue to next character or handle the sprite element</comment>
                        <if>if <condition>(<expr><name>m_textElementType</name> <operator>==</operator> <name><name>TMP_TextElementType</name><operator>.</operator><name>Character</name></name></expr>)</condition><then>
                            <block type="pseudo"><continue>continue;</continue></block></then></if>
                    }</block></then></if>
                }</block></then>
                <else>else
                <block>{
                    <expr_stmt><expr><name>m_textElementType</name> <operator>=</operator> <name><name>m_textInfo</name><operator>.</operator><name>characterInfo</name><index>[<expr><name>m_characterCount</name></expr>]</index></name><operator>.</operator><name>elementType</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>m_currentMaterialIndex</name> <operator>=</operator> <name><name>m_textInfo</name><operator>.</operator><name>characterInfo</name><index>[<expr><name>m_characterCount</name></expr>]</index></name><operator>.</operator><name>materialReferenceIndex</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>m_currentFontAsset</name> <operator>=</operator> <name><name>m_textInfo</name><operator>.</operator><name>characterInfo</name><index>[<expr><name>m_characterCount</name></expr>]</index></name><operator>.</operator><name>fontAsset</name></expr>;</expr_stmt>
                }</block></else></if>
                <cpp:endregion>#<cpp:directive>endregion</cpp:directive> End Parse Rich Text Tag</cpp:endregion>

                <decl_stmt><decl><type><name>int</name></type> <name>prev_MaterialIndex</name> <init>= <expr><name>m_currentMaterialIndex</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>bool</name></type> <name>isUsingAltTypeface</name> <init>= <expr><name><name>m_textInfo</name><operator>.</operator><name>characterInfo</name><index>[<expr><name>m_characterCount</name></expr>]</index></name><operator>.</operator><name>isUsingAlternateTypeface</name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><name>m_isParsingText</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>

                <comment type="line">// Handle Font Styles like LowerCase, UpperCase and SmallCaps.</comment>
                <cpp:region>#<cpp:directive>region</cpp:directive> <name>Handling</name> <name>of</name> <name>LowerCase</name><name>,</name> <name>UpperCase</name> <name>and</name> <name>SmallCaps</name> <name>Font</name> <name>Styles</name></cpp:region>

                <decl_stmt><decl><type><name>float</name></type> <name>smallCapsMultiplier</name> <init>= <expr><literal type="number">1.0f</literal></expr></init></decl>;</decl_stmt>

                <if>if <condition>(<expr><name>m_textElementType</name> <operator>==</operator> <name><name>TMP_TextElementType</name><operator>.</operator><name>Character</name></name></expr>)</condition><then>
                <block>{
                    <if>if <condition>(<expr><operator>(</operator><name>m_style</name> <operator>&amp;</operator> <name><name>FontStyles</name><operator>.</operator><name>UpperCase</name></name><operator>)</operator> <operator>==</operator> <name><name>FontStyles</name><operator>.</operator><name>UpperCase</name></name></expr>)</condition><then>
                    <block>{
                        <comment type="line">// If this character is lowercase, switch to uppercase.</comment>
                        <if>if <condition>(<expr><call><name><name>char</name><operator>.</operator><name>IsLower</name></name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>)</operator><name>charCode</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                            <block type="pseudo"><expr_stmt><expr><name>charCode</name> <operator>=</operator> <call><name><name>char</name><operator>.</operator><name>ToUpper</name></name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>)</operator><name>charCode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block></then></if>

                    }</block></then>
                    <elseif>else <if>if <condition>(<expr><operator>(</operator><name>m_style</name> <operator>&amp;</operator> <name><name>FontStyles</name><operator>.</operator><name>LowerCase</name></name><operator>)</operator> <operator>==</operator> <name><name>FontStyles</name><operator>.</operator><name>LowerCase</name></name></expr>)</condition><then>
                    <block>{
                        <comment type="line">// If this character is uppercase, switch to lowercase.</comment>
                        <if>if <condition>(<expr><call><name><name>char</name><operator>.</operator><name>IsUpper</name></name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>)</operator><name>charCode</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                            <block type="pseudo"><expr_stmt><expr><name>charCode</name> <operator>=</operator> <call><name><name>char</name><operator>.</operator><name>ToLower</name></name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>)</operator><name>charCode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block></then></if>
                    }</block></then></if></elseif>
                    <elseif>else <if>if <condition>(<expr><operator>(</operator><name>m_fontStyle</name> <operator>&amp;</operator> <name><name>FontStyles</name><operator>.</operator><name>SmallCaps</name></name><operator>)</operator> <operator>==</operator> <name><name>FontStyles</name><operator>.</operator><name>SmallCaps</name></name> <operator>||</operator> <operator>(</operator><name>m_style</name> <operator>&amp;</operator> <name><name>FontStyles</name><operator>.</operator><name>SmallCaps</name></name><operator>)</operator> <operator>==</operator> <name><name>FontStyles</name><operator>.</operator><name>SmallCaps</name></name></expr>)</condition><then>
                    <block>{
                        <if>if <condition>(<expr><call><name><name>char</name><operator>.</operator><name>IsLower</name></name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>)</operator><name>charCode</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                        <block>{
                            <expr_stmt><expr><name>smallCapsMultiplier</name> <operator>=</operator> <literal type="number">0.8f</literal></expr>;</expr_stmt>
                            <expr_stmt><expr><name>charCode</name> <operator>=</operator> <call><name><name>char</name><operator>.</operator><name>ToUpper</name></name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>)</operator><name>charCode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        }</block></then></if>
                    }</block></then></if></elseif></if>
                }</block></then></if>
                <cpp:endregion>#<cpp:directive>endregion</cpp:directive></cpp:endregion>


                <comment type="line">// Look up Character Data from Dictionary and cache it.</comment>
                <cpp:region>#<cpp:directive>region</cpp:directive> <name>Look</name> <name>up</name> <name>Character</name> <name>Data</name></cpp:region>
                <if>if <condition>(<expr><name>m_textElementType</name> <operator>==</operator> <name><name>TMP_TextElementType</name><operator>.</operator><name>Sprite</name></name></expr>)</condition><then>
                <block>{
                    <comment type="line">// If a sprite is used as a fallback then get a reference to it and set the color to white.</comment>
                    <expr_stmt><expr><name>m_currentSpriteAsset</name> <operator>=</operator> <name><name>m_textInfo</name><operator>.</operator><name>characterInfo</name><index>[<expr><name>m_characterCount</name></expr>]</index></name><operator>.</operator><name>spriteAsset</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>m_spriteIndex</name> <operator>=</operator> <name><name>m_textInfo</name><operator>.</operator><name>characterInfo</name><index>[<expr><name>m_characterCount</name></expr>]</index></name><operator>.</operator><name>spriteIndex</name></expr>;</expr_stmt>

                    <decl_stmt><decl><type><name>TMP_Sprite</name></type> <name>sprite</name> <init>= <expr><name><name>m_currentSpriteAsset</name><operator>.</operator><name>spriteInfoList</name><index>[<expr><name>m_spriteIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                    <if>if <condition>(<expr><name>sprite</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block type="pseudo"><continue>continue;</continue></block></then></if>

                    <comment type="line">// Sprites are assigned in the E000 Private Area + sprite Index</comment>
                    <if>if <condition>(<expr><name>charCode</name> <operator>==</operator> <literal type="number">60</literal></expr>)</condition><then>
                        <block type="pseudo"><expr_stmt><expr><name>charCode</name> <operator>=</operator> <literal type="number">57344</literal> <operator>+</operator> <name>m_spriteIndex</name></expr>;</expr_stmt></block></then></if>

                    <expr_stmt><expr><name>m_currentFontAsset</name> <operator>=</operator> <name>m_fontAsset</name></expr>;</expr_stmt>

                    <comment type="line">// The sprite scale calculations are based on the font asset assigned to the text object.</comment>
                    <comment type="line">// Sprite scale is used to determine line height</comment>
                    <comment type="line">// Current element scale represents a modified scale to normalize the sprite based on the font baseline to ascender.</comment>
                    <decl_stmt><decl><type><name>float</name></type> <name>spriteScale</name> <init>= <expr><operator>(</operator><name>m_currentFontSize</name> <operator>/</operator> <name><name>m_fontAsset</name><operator>.</operator><name>fontInfo</name><operator>.</operator><name>PointSize</name></name> <operator>*</operator> <name><name>m_fontAsset</name><operator>.</operator><name>fontInfo</name><operator>.</operator><name>Scale</name></name> <operator>*</operator> <operator>(</operator><ternary><condition><expr><name>m_isOrthographic</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0.1f</literal></expr></else></ternary><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><name>currentElementScale</name> <operator>=</operator> <name><name>m_fontAsset</name><operator>.</operator><name>fontInfo</name><operator>.</operator><name>Ascender</name></name> <operator>/</operator> <name><name>sprite</name><operator>.</operator><name>height</name></name> <operator>*</operator> <name><name>sprite</name><operator>.</operator><name>scale</name></name> <operator>*</operator> <name>spriteScale</name></expr>;</expr_stmt>

                    <expr_stmt><expr><name>m_cached_TextElement</name> <operator>=</operator> <name>sprite</name></expr>;</expr_stmt>

                    <expr_stmt><expr><name><name>m_internalCharacterInfo</name><index>[<expr><name>m_characterCount</name></expr>]</index></name><operator>.</operator><name>elementType</name> <operator>=</operator> <name><name>TMP_TextElementType</name><operator>.</operator><name>Sprite</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>m_internalCharacterInfo</name><index>[<expr><name>m_characterCount</name></expr>]</index></name><operator>.</operator><name>scale</name> <operator>=</operator> <name>spriteScale</name></expr>;</expr_stmt>
                    <comment type="line">//m_internalCharacterInfo[m_characterCount].spriteAsset = m_currentSpriteAsset;</comment>
                    <comment type="line">//m_internalCharacterInfo[m_characterCount].fontAsset = m_currentFontAsset;</comment>
                    <comment type="line">//m_internalCharacterInfo[m_characterCount].materialReferenceIndex = m_currentMaterialIndex;</comment>

                    <expr_stmt><expr><name>m_currentMaterialIndex</name> <operator>=</operator> <name>prev_MaterialIndex</name></expr>;</expr_stmt>
                }</block></then>
                <elseif>else <if>if <condition>(<expr><name>m_textElementType</name> <operator>==</operator> <name><name>TMP_TextElementType</name><operator>.</operator><name>Character</name></name></expr>)</condition><then>
                <block>{
                    <expr_stmt><expr><name>m_cached_TextElement</name> <operator>=</operator> <name><name>m_textInfo</name><operator>.</operator><name>characterInfo</name><index>[<expr><name>m_characterCount</name></expr>]</index></name><operator>.</operator><name>textElement</name></expr>;</expr_stmt>
                    <if>if <condition>(<expr><name>m_cached_TextElement</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block type="pseudo"><continue>continue;</continue></block></then></if>

                    <comment type="line">//m_currentFontAsset = m_textInfo.characterInfo[m_characterCount].fontAsset;</comment>
                    <comment type="line">//m_currentMaterial = m_textInfo.characterInfo[m_characterCount].material;</comment>
                    <expr_stmt><expr><name>m_currentMaterialIndex</name> <operator>=</operator> <name><name>m_textInfo</name><operator>.</operator><name>characterInfo</name><index>[<expr><name>m_characterCount</name></expr>]</index></name><operator>.</operator><name>materialReferenceIndex</name></expr>;</expr_stmt>

                    <comment type="line">// Re-calculate font scale as the font asset may have changed.</comment>
                    <expr_stmt><expr><name>m_fontScale</name> <operator>=</operator> <name>m_currentFontSize</name> <operator>*</operator> <name>smallCapsMultiplier</name> <operator>/</operator> <name><name>m_currentFontAsset</name><operator>.</operator><name>fontInfo</name><operator>.</operator><name>PointSize</name></name> <operator>*</operator> <name><name>m_currentFontAsset</name><operator>.</operator><name>fontInfo</name><operator>.</operator><name>Scale</name></name> <operator>*</operator> <operator>(</operator><ternary><condition><expr><name>m_isOrthographic</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0.1f</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

                    <expr_stmt><expr><name>currentElementScale</name> <operator>=</operator> <name>m_fontScale</name> <operator>*</operator> <name>m_fontScaleMultiplier</name> <operator>*</operator> <name><name>m_cached_TextElement</name><operator>.</operator><name>scale</name></name></expr>;</expr_stmt>

                    <expr_stmt><expr><name><name>m_internalCharacterInfo</name><index>[<expr><name>m_characterCount</name></expr>]</index></name><operator>.</operator><name>elementType</name> <operator>=</operator> <name><name>TMP_TextElementType</name><operator>.</operator><name>Character</name></name></expr>;</expr_stmt>

                }</block></then></if></elseif></if>
                <cpp:endregion>#<cpp:directive>endregion</cpp:directive></cpp:endregion>


                <comment type="line">// Handle Soft Hyphen</comment>
                <cpp:region>#<cpp:directive>region</cpp:directive> <name>Handle</name> <name>Soft</name> <name>Hyphen</name></cpp:region>
                <decl_stmt><decl><type><name>float</name></type> <name>old_scale</name> <init>= <expr><name>currentElementScale</name></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><name>charCode</name> <operator>==</operator> <literal type="number">0xAD</literal></expr>)</condition><then>
                <block>{
                    <expr_stmt><expr><name>currentElementScale</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                }</block></then></if>
                <cpp:endregion>#<cpp:directive>endregion</cpp:directive></cpp:endregion>


                <comment type="line">// Store some of the text object's information</comment>
                <expr_stmt><expr><name><name>m_internalCharacterInfo</name><index>[<expr><name>m_characterCount</name></expr>]</index></name><operator>.</operator><name>character</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><name>charCode</name></expr>;</expr_stmt>


                <comment type="line">// Handle Kerning if Enabled.</comment>
                <cpp:region>#<cpp:directive>region</cpp:directive> <name>Handle</name> <name>Kerning</name></cpp:region>
                <decl_stmt><decl><type><name>GlyphValueRecord</name></type> <name>glyphAdjustments</name> <init>= <expr><operator>new</operator> <call><name>GlyphValueRecord</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><name>m_enableKerning</name></expr>)</condition><then>
                <block>{
                    <decl_stmt><decl><type><name>KerningPair</name></type> <name>adjustmentPair</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>

                    <if>if <condition>(<expr><name>m_characterCount</name> <operator>&lt;</operator> <name>totalCharacterCount</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><then>
                    <block>{
                        <decl_stmt><decl><type><name>uint</name></type> <name>nextGlyph</name> <init>= <expr><name><name>m_textInfo</name><operator>.</operator><name>characterInfo</name><index>[<expr><name>m_characterCount</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>character</name></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>KerningPairKey</name></type> <name>keyValue</name> <init>= <expr><operator>new</operator> <call><name>KerningPairKey</name><argument_list>(<argument><expr><operator>(</operator><name>uint</name><operator>)</operator><name>charCode</name></expr></argument>, <argument><expr><name>nextGlyph</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                        <expr_stmt><expr><call><name><name>m_currentFontAsset</name><operator>.</operator><name>kerningDictionary</name><operator>.</operator><name>TryGetValue</name></name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>keyValue</name><operator>.</operator><name>key</name></name></expr></argument>, <argument><modifier>out</modifier> <expr><name>adjustmentPair</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if>if <condition>(<expr><name>adjustmentPair</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><then>
                            <block type="pseudo"><expr_stmt><expr><name>glyphAdjustments</name> <operator>=</operator> <name><name>adjustmentPair</name><operator>.</operator><name>firstGlyphAdjustments</name></name></expr>;</expr_stmt></block></then></if>
                    }</block></then></if>

                    <if>if <condition>(<expr><name>m_characterCount</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr>)</condition><then>
                    <block>{
                        <decl_stmt><decl><type><name>uint</name></type> <name>previousGlyph</name> <init>= <expr><name><name>m_textInfo</name><operator>.</operator><name>characterInfo</name><index>[<expr><name>m_characterCount</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>character</name></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>KerningPairKey</name></type> <name>keyValue</name> <init>= <expr><operator>new</operator> <call><name>KerningPairKey</name><argument_list>(<argument><expr><name>previousGlyph</name></expr></argument>, <argument><expr><operator>(</operator><name>uint</name><operator>)</operator><name>charCode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                        <expr_stmt><expr><call><name><name>m_currentFontAsset</name><operator>.</operator><name>kerningDictionary</name><operator>.</operator><name>TryGetValue</name></name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>keyValue</name><operator>.</operator><name>key</name></name></expr></argument>, <argument><modifier>out</modifier> <expr><name>adjustmentPair</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if>if <condition>(<expr><name>adjustmentPair</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><then>
                            <block type="pseudo"><expr_stmt><expr><name>glyphAdjustments</name> <operator>+=</operator> <name><name>adjustmentPair</name><operator>.</operator><name>secondGlyphAdjustments</name></name></expr>;</expr_stmt></block></then></if>
                    }</block></then></if>
                }</block></then></if>
                <cpp:endregion>#<cpp:directive>endregion</cpp:directive></cpp:endregion>


                <comment type="line">// Initial Implementation for RTL support.</comment>
                <cpp:region>#<cpp:directive>region</cpp:directive> <name>Handle</name> <name>Right</name><name>-</name><name>to</name><name>-</name><name>Left</name></cpp:region>
                <comment type="line">//if (m_isRightToLeft)</comment>
                <comment type="line">//{</comment>
                <comment type="line">//    m_xAdvance -= ((m_cached_TextElement.xAdvance * bold_xAdvance_multiplier + m_characterSpacing + m_wordSpacing + m_currentFontAsset.normalSpacingOffset) * currentElementScale + m_cSpacing) * (1 - m_charWidthAdjDelta);</comment>

                <comment type="line">//    if (char.IsWhiteSpace((char)charCode) || charCode == 0x200B)</comment>
                <comment type="line">//        m_xAdvance -= m_wordSpacing * currentElementScale;</comment>
                <comment type="line">//}</comment>
                <cpp:endregion>#<cpp:directive>endregion</cpp:directive></cpp:endregion>


                <comment type="line">// Handle Mono Spacing</comment>
                <cpp:region>#<cpp:directive>region</cpp:directive> <name>Handle</name> <name>Mono</name> <name>Spacing</name></cpp:region>
                <decl_stmt><decl><type><name>float</name></type> <name>monoAdvance</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><name>m_monoSpacing</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><then>
                <block>{
                    <expr_stmt><expr><name>monoAdvance</name> <operator>=</operator> <operator>(</operator><name>m_monoSpacing</name> <operator>/</operator> <literal type="number">2</literal> <operator>-</operator> <operator>(</operator><name><name>m_cached_TextElement</name><operator>.</operator><name>width</name></name> <operator>/</operator> <literal type="number">2</literal> <operator>+</operator> <name><name>m_cached_TextElement</name><operator>.</operator><name>xOffset</name></name><operator>)</operator> <operator>*</operator> <name>currentElementScale</name><operator>)</operator></expr>;</expr_stmt>
                    <expr_stmt><expr><name>m_xAdvance</name> <operator>+=</operator> <name>monoAdvance</name></expr>;</expr_stmt>
                }</block></then></if>
                <cpp:endregion>#<cpp:directive>endregion</cpp:directive></cpp:endregion>


                <comment type="line">// Set Padding based on selected font style</comment>
                <cpp:region>#<cpp:directive>region</cpp:directive> <name>Handle</name> <name>Style</name> <name>Padding</name></cpp:region>
                <if>if <condition>(<expr><name>m_textElementType</name> <operator>==</operator> <name><name>TMP_TextElementType</name><operator>.</operator><name>Character</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>isUsingAltTypeface</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>m_style</name> <operator>&amp;</operator> <name><name>FontStyles</name><operator>.</operator><name>Bold</name></name><operator>)</operator> <operator>==</operator> <name><name>FontStyles</name><operator>.</operator><name>Bold</name></name> <operator>||</operator> <operator>(</operator><name>m_fontStyle</name> <operator>&amp;</operator> <name><name>FontStyles</name><operator>.</operator><name>Bold</name></name><operator>)</operator> <operator>==</operator> <name><name>FontStyles</name><operator>.</operator><name>Bold</name></name><operator>)</operator></expr>)</condition><then> <comment type="line">// Checks for any combination of Bold Style.</comment>
                <block>{
                    <comment type="line">//style_padding = m_currentFontAsset.boldStyle * 2;</comment>
                    <expr_stmt><expr><name>bold_xAdvance_multiplier</name> <operator>=</operator> <literal type="number">1</literal> <operator>+</operator> <name><name>m_currentFontAsset</name><operator>.</operator><name>boldSpacing</name></name> <operator>*</operator> <literal type="number">0.01f</literal></expr>;</expr_stmt>
                }</block></then>
                <else>else
                <block>{
                    <comment type="line">//style_padding = m_currentFontAsset.normalStyle * 2;</comment>
                    <expr_stmt><expr><name>bold_xAdvance_multiplier</name> <operator>=</operator> <literal type="number">1.0f</literal></expr>;</expr_stmt>
                }</block></else></if>
                <cpp:endregion>#<cpp:directive>endregion</cpp:directive> Handle Style Padding</cpp:endregion>

                <expr_stmt><expr><name><name>m_internalCharacterInfo</name><index>[<expr><name>m_characterCount</name></expr>]</index></name><operator>.</operator><name>baseLine</name> <operator>=</operator> <literal type="number">0</literal> <operator>-</operator> <name>m_lineOffset</name> <operator>+</operator> <name>m_baselineOffset</name></expr>;</expr_stmt>


                <comment type="line">// Compute and save text element Ascender and maximum line Ascender.</comment>
                <decl_stmt><decl><type><name>float</name></type> <name>elementAscender</name> <init>= <expr><name><name>m_currentFontAsset</name><operator>.</operator><name>fontInfo</name><operator>.</operator><name>Ascender</name></name> <operator>*</operator> <operator>(</operator><ternary><condition><expr><name>m_textElementType</name> <operator>==</operator> <name><name>TMP_TextElementType</name><operator>.</operator><name>Character</name></name></expr> ?</condition><then> <expr><name>currentElementScale</name> <operator>/</operator> <name>smallCapsMultiplier</name></expr> </then><else>: <expr><name><name>m_internalCharacterInfo</name><index>[<expr><name>m_characterCount</name></expr>]</index></name><operator>.</operator><name>scale</name></expr></else></ternary><operator>)</operator> <operator>+</operator> <name>m_baselineOffset</name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name><name>m_internalCharacterInfo</name><index>[<expr><name>m_characterCount</name></expr>]</index></name><operator>.</operator><name>ascender</name> <operator>=</operator> <name>elementAscender</name> <operator>-</operator> <name>m_lineOffset</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>m_maxLineAscender</name> <operator>=</operator> <ternary><condition><expr><name>elementAscender</name> <operator>&gt;</operator> <name>m_maxLineAscender</name></expr> ?</condition><then> <expr><name>elementAscender</name></expr> </then><else>: <expr><name>m_maxLineAscender</name></expr></else></ternary></expr>;</expr_stmt>

                <comment type="line">// Compute and save text element Descender and maximum line Descender.</comment>
                <decl_stmt><decl><type><name>float</name></type> <name>elementDescender</name> <init>= <expr><name><name>m_currentFontAsset</name><operator>.</operator><name>fontInfo</name><operator>.</operator><name>Descender</name></name> <operator>*</operator> <operator>(</operator><ternary><condition><expr><name>m_textElementType</name> <operator>==</operator> <name><name>TMP_TextElementType</name><operator>.</operator><name>Character</name></name></expr> ?</condition><then> <expr><name>currentElementScale</name> <operator>/</operator> <name>smallCapsMultiplier</name></expr></then><else>: <expr><name><name>m_internalCharacterInfo</name><index>[<expr><name>m_characterCount</name></expr>]</index></name><operator>.</operator><name>scale</name></expr></else></ternary><operator>)</operator> <operator>+</operator> <name>m_baselineOffset</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>float</name></type> <name>elementDescenderII</name> <init>= <expr><name><name>m_internalCharacterInfo</name><index>[<expr><name>m_characterCount</name></expr>]</index></name><operator>.</operator><name>descender</name> <operator>=</operator> <name>elementDescender</name> <operator>-</operator> <name>m_lineOffset</name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>m_maxLineDescender</name> <operator>=</operator> <ternary><condition><expr><name>elementDescender</name> <operator>&lt;</operator> <name>m_maxLineDescender</name></expr> ?</condition><then> <expr><name>elementDescender</name></expr> </then><else>: <expr><name>m_maxLineDescender</name></expr></else></ternary></expr>;</expr_stmt>

                <comment type="line">// Adjust maxLineAscender and maxLineDescender if style is superscript or subscript</comment>
                <if>if <condition>(<expr><operator>(</operator><name>m_style</name> <operator>&amp;</operator> <name><name>FontStyles</name><operator>.</operator><name>Subscript</name></name><operator>)</operator> <operator>==</operator> <name><name>FontStyles</name><operator>.</operator><name>Subscript</name></name> <operator>||</operator> <operator>(</operator><name>m_style</name> <operator>&amp;</operator> <name><name>FontStyles</name><operator>.</operator><name>Superscript</name></name><operator>)</operator> <operator>==</operator> <name><name>FontStyles</name><operator>.</operator><name>Superscript</name></name></expr>)</condition><then>
                <block>{
                    <decl_stmt><decl><type><name>float</name></type> <name>baseAscender</name> <init>= <expr><operator>(</operator><name>elementAscender</name> <operator>-</operator> <name>m_baselineOffset</name><operator>)</operator> <operator>/</operator> <name><name>m_currentFontAsset</name><operator>.</operator><name>fontInfo</name><operator>.</operator><name>SubSize</name></name></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><name>elementAscender</name> <operator>=</operator> <name>m_maxLineAscender</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>m_maxLineAscender</name> <operator>=</operator> <ternary><condition><expr><name>baseAscender</name> <operator>&gt;</operator> <name>m_maxLineAscender</name></expr> ?</condition><then> <expr><name>baseAscender</name></expr> </then><else>: <expr><name>m_maxLineAscender</name></expr></else></ternary></expr>;</expr_stmt>

                    <decl_stmt><decl><type><name>float</name></type> <name>baseDescender</name> <init>= <expr><operator>(</operator><name>elementDescender</name> <operator>-</operator> <name>m_baselineOffset</name><operator>)</operator> <operator>/</operator> <name><name>m_currentFontAsset</name><operator>.</operator><name>fontInfo</name><operator>.</operator><name>SubSize</name></name></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><name>elementDescender</name> <operator>=</operator> <name>m_maxLineDescender</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>m_maxLineDescender</name> <operator>=</operator> <ternary><condition><expr><name>baseDescender</name> <operator>&lt;</operator> <name>m_maxLineDescender</name></expr> ?</condition><then> <expr><name>baseDescender</name></expr> </then><else>: <expr><name>m_maxLineDescender</name></expr></else></ternary></expr>;</expr_stmt>
                }</block></then></if>

                <if>if <condition>(<expr><name>m_lineNumber</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><name>m_maxAscender</name> <operator>=</operator> <ternary><condition><expr><name>m_maxAscender</name> <operator>&gt;</operator> <name>elementAscender</name></expr> ?</condition><then> <expr><name>m_maxAscender</name></expr> </then><else>: <expr><name>elementAscender</name></expr></else></ternary></expr>;</expr_stmt></block></then></if>
                <comment type="line">//if (m_lineOffset == 0) pageAscender = pageAscender &gt; elementAscender ? pageAscender : elementAscender;</comment>

                <comment type="line">// Setup Mesh for visible text elements. ie. not a SPACE / LINEFEED / CARRIAGE RETURN.</comment>
                <cpp:region>#<cpp:directive>region</cpp:directive> <name>Handle</name> <name>Visible</name> <name>Characters</name></cpp:region>
                <if>if <condition>(<expr><name>charCode</name> <operator>==</operator> <literal type="number">9</literal> <operator>||</operator> <name>charCode</name> <operator>==</operator> <literal type="number">0xA0</literal> <operator>||</operator> <name>charCode</name> <operator>==</operator> <literal type="number">0x2007</literal> <operator>||</operator> <operator>(</operator><operator>!</operator><call><name><name>char</name><operator>.</operator><name>IsWhiteSpace</name></name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>)</operator><name>charCode</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>charCode</name> <operator>!=</operator> <literal type="number">0x200B</literal><operator>)</operator> <operator>||</operator> <name>m_textElementType</name> <operator>==</operator> <name><name>TMP_TextElementType</name><operator>.</operator><name>Sprite</name></name></expr>)</condition><then>
                <block>{
                    <comment type="line">// Check if Character exceeds the width of the Text Container</comment>
                    <cpp:region>#<cpp:directive>region</cpp:directive> <name>Handle</name> <name>Line</name> <name>Breaking</name><name>,</name> <name>Text</name> <name>Auto</name><name>-</name><name>Sizing</name> <name>and</name> <name>Horizontal</name> <name>Overflow</name></cpp:region>
                    <decl_stmt><decl><type><name>float</name></type> <name>width</name> <init>= <expr><ternary><condition><expr><name>m_width</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr> ?</condition><then> <expr><call><name><name>Mathf</name><operator>.</operator><name>Min</name></name><argument_list>(<argument><expr><name>marginWidth</name> <operator>+</operator> <literal type="number">0.0001f</literal> <operator>-</operator> <name>m_marginLeft</name> <operator>-</operator> <name>m_marginRight</name></expr></argument>, <argument><expr><name>m_width</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>marginWidth</name> <operator>+</operator> <literal type="number">0.0001f</literal> <operator>-</operator> <name>m_marginLeft</name> <operator>-</operator> <name>m_marginRight</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

                    <decl_stmt><decl><type><name>bool</name></type> <name>isJustifiedOrFlush</name> <init>= <expr><operator>(</operator><operator>(</operator><name>_HorizontalAlignmentOptions</name><operator>)</operator><name>m_lineJustification</name> <operator>&amp;</operator> <name><name>_HorizontalAlignmentOptions</name><operator>.</operator><name>Flush</name></name><operator>)</operator> <operator>==</operator> <name><name>_HorizontalAlignmentOptions</name><operator>.</operator><name>Flush</name></name> <operator>||</operator> <operator>(</operator><operator>(</operator><name>_HorizontalAlignmentOptions</name><operator>)</operator><name>m_lineJustification</name> <operator>&amp;</operator> <name><name>_HorizontalAlignmentOptions</name><operator>.</operator><name>Justified</name></name><operator>)</operator> <operator>==</operator> <name><name>_HorizontalAlignmentOptions</name><operator>.</operator><name>Justified</name></name></expr></init></decl>;</decl_stmt>

                    <comment type="line">// Calculate the line breaking width of the text.</comment>
                    <expr_stmt><expr><name>linebreakingWidth</name> <operator>=</operator> <name>m_xAdvance</name> <operator>+</operator> <name><name>m_cached_TextElement</name><operator>.</operator><name>xAdvance</name></name> <operator>*</operator> <operator>(</operator><literal type="number">1</literal> <operator>-</operator> <name>m_charWidthAdjDelta</name><operator>)</operator> <operator>*</operator> <operator>(</operator><ternary><condition><expr><name>charCode</name> <operator>!=</operator> <literal type="number">0xAD</literal></expr> ?</condition><then> <expr><name>currentElementScale</name></expr> </then><else>: <expr><name>old_scale</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

                    <comment type="line">// Check if Character exceeds the width of the Text Container</comment>
                    <if>if <condition>(<expr><name>linebreakingWidth</name> <operator>&gt;</operator> <name>width</name> <operator>*</operator> <operator>(</operator><ternary><condition><expr><name>isJustifiedOrFlush</name></expr> ?</condition><then> <expr><literal type="number">1.05f</literal></expr> </then><else>: <expr><literal type="number">1.0f</literal></expr></else></ternary><operator>)</operator></expr>)</condition><then>
                    <block>{
                        <comment type="line">// Word Wrapping</comment>
                        <cpp:region>#<cpp:directive>region</cpp:directive> <name>Handle</name> <name>Word</name> <name>Wrapping</name></cpp:region>
                        <if>if <condition>(<expr><name>enableWordWrapping</name> <operator>&amp;&amp;</operator> <name>m_characterCount</name> <operator>!=</operator> <name>m_firstCharacterOfLine</name></expr>)</condition><then>
                        <block>{
                            <comment type="line">// Check if word wrapping is still possible</comment>
                            <cpp:region>#<cpp:directive>region</cpp:directive> <name>Line</name> <name>Breaking</name> <name>Check</name></cpp:region>
                            <if>if <condition>(<expr><name>wrappingIndex</name> <operator>==</operator> <name><name>savedWordWrapState</name><operator>.</operator><name>previous_WordBreak</name></name> <operator>||</operator> <name>isFirstWord</name></expr>)</condition><then>
                            <block>{
                                <comment type="line">// Word wrapping is no longer possible. Shrink size of text if auto-sizing is enabled.</comment>
                                <cpp:region>#<cpp:directive>region</cpp:directive> <name>Text</name> <name>Auto</name><name>-</name><name>Sizing</name></cpp:region>
                                <if>if <condition>(<expr><name>ignoreTextAutoSizing</name> <operator>==</operator> <literal type="boolean">false</literal> <operator>&amp;&amp;</operator> <name>m_currentFontSize</name> <operator>&gt;</operator> <name>m_fontSizeMin</name></expr>)</condition><then>
                                <block>{
                                    <comment type="line">// Handle Character Width Adjustments</comment>
                                    <cpp:region>#<cpp:directive>region</cpp:directive> <name>Character</name> <name>Width</name> <name>Adjustments</name></cpp:region>
                                    <if>if <condition>(<expr><name>m_charWidthAdjDelta</name> <operator>&lt;</operator> <name>m_charWidthMaxAdj</name> <operator>/</operator> <literal type="number">100</literal></expr>)</condition><then>
                                    <block>{
                                        <expr_stmt><expr><name>m_recursiveCount</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                                        <expr_stmt><expr><name>m_charWidthAdjDelta</name> <operator>+=</operator> <literal type="number">0.01f</literal></expr>;</expr_stmt>
                                        <return>return <expr><call><name>CalculatePreferredValues</name><argument_list>(<argument><expr><name>defaultFontSize</name></expr></argument>, <argument><expr><name>marginSize</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</return>
                                    }</block></then></if>
                                    <cpp:endregion>#<cpp:directive>endregion</cpp:directive></cpp:endregion>

                                    <comment type="line">// Adjust Point Size</comment>
                                    <expr_stmt><expr><name>m_maxFontSize</name> <operator>=</operator> <name>defaultFontSize</name></expr>;</expr_stmt>

                                    <expr_stmt><expr><name>defaultFontSize</name> <operator>-=</operator> <call><name><name>Mathf</name><operator>.</operator><name>Max</name></name><argument_list>(<argument><expr><operator>(</operator><name>defaultFontSize</name> <operator>-</operator> <name>m_minFontSize</name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">0.05f</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                    <expr_stmt><expr><name>defaultFontSize</name> <operator>=</operator> <call>(<name>int</name>)<argument_list>(<argument><expr><call><name><name>Mathf</name><operator>.</operator><name>Max</name></name><argument_list>(<argument><expr><name>defaultFontSize</name></expr></argument>, <argument><expr><name>m_fontSizeMin</name></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">20</literal> <operator>+</operator> <literal type="number">0.5f</literal></expr></argument>)</argument_list></call> <operator>/</operator> <literal type="number">20f</literal></expr>;</expr_stmt>

                                    <if>if <condition>(<expr><name>m_recursiveCount</name> <operator>&gt;</operator> <literal type="number">20</literal></expr>)</condition><then> <block type="pseudo"><return>return <expr><operator>new</operator> <call><name>Vector2</name><argument_list>(<argument><expr><name>renderedWidth</name></expr></argument>, <argument><expr><name>renderedHeight</name></expr></argument>)</argument_list></call></expr>;</return></block></then></if>
                                    <return>return <expr><call><name>CalculatePreferredValues</name><argument_list>(<argument><expr><name>defaultFontSize</name></expr></argument>, <argument><expr><name>marginSize</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</return>
                                }</block></then></if>
                                <cpp:endregion>#<cpp:directive>endregion</cpp:directive></cpp:endregion>

                                <comment type="line">// Word wrapping is no longer possible, now breaking up individual words.</comment>
                                <if>if <condition>(<expr><name>m_isCharacterWrappingEnabled</name> <operator>==</operator> <literal type="boolean">false</literal></expr>)</condition><then>
                                <block>{
                                    <expr_stmt><expr><name>m_isCharacterWrappingEnabled</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                                }</block></then>
                                <else>else
                                    <block type="pseudo"><expr_stmt><expr><name>isLastBreakingChar</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt></block></else></if>
                            }</block></then></if>
                            <cpp:endregion>#<cpp:directive>endregion</cpp:directive></cpp:endregion>

                            <comment type="line">// Restore to previously stored state of last valid (space character or linefeed)</comment>
                            <expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>RestoreWordWrappingState</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>savedWordWrapState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name>wrappingIndex</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>  <comment type="line">// Used to detect when line length can no longer be reduced.</comment>

                            <comment type="line">// Handling for Soft Hyphen</comment>
                            <if>if <condition>(<expr><name><name>m_char_buffer</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="number">0xAD</literal></expr>)</condition><then> <comment type="line">// &amp;&amp; !m_isCharacterWrappingEnabled) // &amp;&amp; ellipsisIndex != i &amp;&amp; !m_isCharacterWrappingEnabled)</comment>
                            <block>{
                                <expr_stmt><expr><name>m_isTextTruncated</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                                <expr_stmt><expr><name><name>m_char_buffer</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0x2D</literal></expr>;</expr_stmt>
                                <return>return <expr><call><name>CalculatePreferredValues</name><argument_list>(<argument><expr><name>defaultFontSize</name></expr></argument>, <argument><expr><name>marginSize</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</return>
                            }</block></then></if>

                            <comment type="line">// Check if Line Spacing of previous line needs to be adjusted.</comment>
                            <if>if <condition>(<expr><name>m_lineNumber</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>TMP_Math</name><operator>.</operator><name>Approximately</name></name><argument_list>(<argument><expr><name>m_maxLineAscender</name></expr></argument>, <argument><expr><name>m_startOfLineAscender</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>m_lineHeight</name> <operator>==</operator> <name><name>TMP_Math</name><operator>.</operator><name>FLOAT_UNSET</name></name></expr>)</condition><then>
                            <block>{
                                <comment type="line">//Debug.Log("(1) Adjusting Line Spacing on line #" + m_lineNumber);</comment>
                                <decl_stmt><decl><type><name>float</name></type> <name>offsetDelta</name> <init>= <expr><name>m_maxLineAscender</name> <operator>-</operator> <name>m_startOfLineAscender</name></expr></init></decl>;</decl_stmt>
                                <comment type="line">//AdjustLineOffset(m_firstCharacterOfLine, m_characterCount, offsetDelta);</comment>
                                <expr_stmt><expr><name>m_lineOffset</name> <operator>+=</operator> <name>offsetDelta</name></expr>;</expr_stmt>
                                <expr_stmt><expr><name><name>savedWordWrapState</name><operator>.</operator><name>lineOffset</name></name> <operator>=</operator> <name>m_lineOffset</name></expr>;</expr_stmt>
                                <expr_stmt><expr><name><name>savedWordWrapState</name><operator>.</operator><name>previousLineAscender</name></name> <operator>=</operator> <name>m_maxLineAscender</name></expr>;</expr_stmt>

                                <comment type="line">// TODO - Add check for character exceeding vertical bounds</comment>
                            }</block></then></if>
                            <comment type="line">//m_isNewPage = false;</comment>

                            <comment type="line">// Calculate lineAscender &amp; make sure if last character is superscript or subscript that we check that as well.</comment>
                            <decl_stmt><decl><type><name>float</name></type> <name>lineAscender</name> <init>= <expr><name>m_maxLineAscender</name> <operator>-</operator> <name>m_lineOffset</name></expr></init></decl>;</decl_stmt>
                            <decl_stmt><decl><type><name>float</name></type> <name>lineDescender</name> <init>= <expr><name>m_maxLineDescender</name> <operator>-</operator> <name>m_lineOffset</name></expr></init></decl>;</decl_stmt>


                            <comment type="line">// Update maxDescender and maxVisibleDescender</comment>
                            <expr_stmt><expr><name>m_maxDescender</name> <operator>=</operator> <ternary><condition><expr><name>m_maxDescender</name> <operator>&lt;</operator> <name>lineDescender</name></expr> ?</condition><then> <expr><name>m_maxDescender</name></expr> </then><else>: <expr><name>lineDescender</name></expr></else></ternary></expr>;</expr_stmt>


                            <expr_stmt><expr><name>m_firstCharacterOfLine</name> <operator>=</operator> <name>m_characterCount</name></expr>;</expr_stmt> <comment type="line">// Store first character of the next line.</comment>

                            <comment type="line">// Compute Preferred Width &amp; Height</comment>
                            <expr_stmt><expr><name>renderedWidth</name> <operator>+=</operator> <name>m_xAdvance</name></expr>;</expr_stmt>

                            <if>if <condition>(<expr><name>m_enableWordWrapping</name></expr>)</condition><then>
                                <block type="pseudo"><expr_stmt><expr><name>renderedHeight</name> <operator>=</operator> <name>m_maxAscender</name> <operator>-</operator> <name>m_maxDescender</name></expr>;</expr_stmt></block></then>
                            <else>else
                                <block type="pseudo"><expr_stmt><expr><name>renderedHeight</name> <operator>=</operator> <call><name><name>Mathf</name><operator>.</operator><name>Max</name></name><argument_list>(<argument><expr><name>renderedHeight</name></expr></argument>, <argument><expr><name>lineAscender</name> <operator>-</operator> <name>lineDescender</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block></else></if>


                            <comment type="line">// Store the state of the line before starting on the new line.</comment>
                            <expr_stmt><expr><call><name>SaveWordWrappingState</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>savedLineState</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>m_characterCount</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                            <expr_stmt><expr><name>m_lineNumber</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                            <comment type="line">//isStartOfNewLine = true;</comment>

                            <comment type="line">// Check to make sure Array is large enough to hold a new line.</comment>
                            <comment type="line">//if (m_lineNumber &gt;= m_internalTextInfo.lineInfo.Length)</comment>
                            <comment type="line">//    ResizeLineExtents(m_lineNumber);</comment>

                            <comment type="line">// Apply Line Spacing based on scale of the last character of the line.</comment>
                            <if>if <condition>(<expr><name>m_lineHeight</name> <operator>==</operator> <name><name>TMP_Math</name><operator>.</operator><name>FLOAT_UNSET</name></name></expr>)</condition><then>
                            <block>{
                                <decl_stmt><decl><type><name>float</name></type> <name>ascender</name> <init>= <expr><name><name>m_internalCharacterInfo</name><index>[<expr><name>m_characterCount</name></expr>]</index></name><operator>.</operator><name>ascender</name> <operator>-</operator> <name><name>m_internalCharacterInfo</name><index>[<expr><name>m_characterCount</name></expr>]</index></name><operator>.</operator><name>baseLine</name></expr></init></decl>;</decl_stmt>
                                <expr_stmt><expr><name>lineOffsetDelta</name> <operator>=</operator> <literal type="number">0</literal> <operator>-</operator> <name>m_maxLineDescender</name> <operator>+</operator> <name>ascender</name> <operator>+</operator> <operator>(</operator><name>lineGap</name> <operator>+</operator> <name>m_lineSpacing</name> <operator>+</operator> <name>m_lineSpacingDelta</name><operator>)</operator> <operator>*</operator> <name>baseScale</name></expr>;</expr_stmt>
                                <expr_stmt><expr><name>m_lineOffset</name> <operator>+=</operator> <name>lineOffsetDelta</name></expr>;</expr_stmt>

                                <expr_stmt><expr><name>m_startOfLineAscender</name> <operator>=</operator> <name>ascender</name></expr>;</expr_stmt>
                            }</block></then>
                            <else>else
                                <block type="pseudo"><expr_stmt><expr><name>m_lineOffset</name> <operator>+=</operator> <name>m_lineHeight</name> <operator>+</operator> <name>m_lineSpacing</name> <operator>*</operator> <name>baseScale</name></expr>;</expr_stmt></block></else></if>

                            <expr_stmt><expr><name>m_maxLineAscender</name> <operator>=</operator> <name>k_LargeNegativeFloat</name></expr>;</expr_stmt>
                            <expr_stmt><expr><name>m_maxLineDescender</name> <operator>=</operator> <name>k_LargePositiveFloat</name></expr>;</expr_stmt>

                            <expr_stmt><expr><name>m_xAdvance</name> <operator>=</operator> <literal type="number">0</literal> <operator>+</operator> <name>tag_Indent</name></expr>;</expr_stmt>

                            <continue>continue;</continue>
                        }</block></then></if>
                        <cpp:endregion>#<cpp:directive>endregion</cpp:directive> End Word Wrapping</cpp:endregion>

                        <comment type="line">// Text Auto-Sizing (text exceeding Width of container. </comment>
                        <cpp:region>#<cpp:directive>region</cpp:directive> <name>Handle</name> <name>Text</name> <name>Auto</name><name>-</name><name>Sizing</name></cpp:region>
                        <if>if <condition>(<expr><name>ignoreTextAutoSizing</name> <operator>==</operator> <literal type="boolean">false</literal> <operator>&amp;&amp;</operator> <name>defaultFontSize</name> <operator>&gt;</operator> <name>m_fontSizeMin</name></expr>)</condition><then>
                        <block>{
                            <comment type="line">// Handle Character Width Adjustments</comment>
                            <cpp:region>#<cpp:directive>region</cpp:directive> <name>Character</name> <name>Width</name> <name>Adjustments</name></cpp:region>
                            <if>if <condition>(<expr><name>m_charWidthAdjDelta</name> <operator>&lt;</operator> <name>m_charWidthMaxAdj</name> <operator>/</operator> <literal type="number">100</literal></expr>)</condition><then>
                            <block>{
                                <expr_stmt><expr><name>m_recursiveCount</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                                <expr_stmt><expr><name>m_charWidthAdjDelta</name> <operator>+=</operator> <literal type="number">0.01f</literal></expr>;</expr_stmt>
                                <return>return <expr><call><name>CalculatePreferredValues</name><argument_list>(<argument><expr><name>defaultFontSize</name></expr></argument>, <argument><expr><name>marginSize</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</return>
                            }</block></then></if>
                            <cpp:endregion>#<cpp:directive>endregion</cpp:directive></cpp:endregion>

                            <comment type="line">// Adjust Point Size</comment>
                            <expr_stmt><expr><name>m_maxFontSize</name> <operator>=</operator> <name>defaultFontSize</name></expr>;</expr_stmt>

                            <expr_stmt><expr><name>defaultFontSize</name> <operator>-=</operator> <call><name><name>Mathf</name><operator>.</operator><name>Max</name></name><argument_list>(<argument><expr><operator>(</operator><name>defaultFontSize</name> <operator>-</operator> <name>m_minFontSize</name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">0.05f</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name>defaultFontSize</name> <operator>=</operator> <call>(<name>int</name>)<argument_list>(<argument><expr><call><name><name>Mathf</name><operator>.</operator><name>Max</name></name><argument_list>(<argument><expr><name>defaultFontSize</name></expr></argument>, <argument><expr><name>m_fontSizeMin</name></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">20</literal> <operator>+</operator> <literal type="number">0.5f</literal></expr></argument>)</argument_list></call> <operator>/</operator> <literal type="number">20f</literal></expr>;</expr_stmt>

                            <if>if <condition>(<expr><name>m_recursiveCount</name> <operator>&gt;</operator> <literal type="number">20</literal></expr>)</condition><then> <block type="pseudo"><return>return <expr><operator>new</operator> <call><name>Vector2</name><argument_list>(<argument><expr><name>renderedWidth</name></expr></argument>, <argument><expr><name>renderedHeight</name></expr></argument>)</argument_list></call></expr>;</return></block></then></if>
                            <return>return <expr><call><name>CalculatePreferredValues</name><argument_list>(<argument><expr><name>defaultFontSize</name></expr></argument>, <argument><expr><name>marginSize</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</return>
                        }</block></then></if>
                        <cpp:endregion>#<cpp:directive>endregion</cpp:directive> End Text Auto-Sizing</cpp:endregion>
                    }</block></then></if>
                    <cpp:endregion>#<cpp:directive>endregion</cpp:directive> End Check for Characters Exceeding Width of Text Container</cpp:endregion>

                }</block></then></if>
                <cpp:endregion>#<cpp:directive>endregion</cpp:directive> Handle Visible Characters</cpp:endregion>


                <comment type="line">// Check if Line Spacing of previous line needs to be adjusted.</comment>
                <cpp:region>#<cpp:directive>region</cpp:directive> <name>Adjust</name> <name>Line</name> <name>Spacing</name></cpp:region>
                <if>if <condition>(<expr><name>m_lineNumber</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>TMP_Math</name><operator>.</operator><name>Approximately</name></name><argument_list>(<argument><expr><name>m_maxLineAscender</name></expr></argument>, <argument><expr><name>m_startOfLineAscender</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>m_lineHeight</name> <operator>==</operator> <name><name>TMP_Math</name><operator>.</operator><name>FLOAT_UNSET</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>m_isNewPage</name></expr>)</condition><then>
                <block>{
                    <comment type="line">//Debug.Log("Inline - Adjusting Line Spacing on line #" + m_lineNumber);</comment>
                    <comment type="line">//float gap = 0; // Compute gap.</comment>

                    <decl_stmt><decl><type><name>float</name></type> <name>offsetDelta</name> <init>= <expr><name>m_maxLineAscender</name> <operator>-</operator> <name>m_startOfLineAscender</name></expr></init></decl>;</decl_stmt>
                    <comment type="line">//AdjustLineOffset(m_firstCharacterOfLine, m_characterCount, offsetDelta);</comment>
                    <expr_stmt><expr><name>elementDescenderII</name> <operator>-=</operator> <name>offsetDelta</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>m_lineOffset</name> <operator>+=</operator> <name>offsetDelta</name></expr>;</expr_stmt>

                    <expr_stmt><expr><name>m_startOfLineAscender</name> <operator>+=</operator> <name>offsetDelta</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>savedWordWrapState</name><operator>.</operator><name>lineOffset</name></name> <operator>=</operator> <name>m_lineOffset</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>savedWordWrapState</name><operator>.</operator><name>previousLineAscender</name></name> <operator>=</operator> <name>m_startOfLineAscender</name></expr>;</expr_stmt>
                }</block></then></if>
                <cpp:endregion>#<cpp:directive>endregion</cpp:directive></cpp:endregion>


                <comment type="line">// Check if text Exceeds the vertical bounds of the margin area.</comment>
                <cpp:region>#<cpp:directive>region</cpp:directive> <name>Check</name> <name>Vertical</name> <name>Bounds</name> <name>&amp;</name> <name>Auto</name><name>-</name><name>Sizing</name></cpp:region>
                <comment type="block">/*
                if (m_maxAscender - elementDescenderII &gt; marginHeight + 0.0001f)
                {
                    // Handle Line spacing adjustments
                    #region Line Spacing Adjustments
                    if (m_enableAutoSizing &amp;&amp; m_lineSpacingDelta &gt; m_lineSpacingMax &amp;&amp; m_lineNumber &gt; 0)
                    {
                        //loopCountA = 0;

                        //m_lineSpacingDelta -= 1;
                        //GenerateTextMesh();
                        //return;
                    }
                    #endregion


                    // Handle Text Auto-sizing resulting from text exceeding vertical bounds.
                    #region Text Auto-Sizing (Text greater than vertical bounds)
                    if (m_enableAutoSizing &amp;&amp; m_fontSize &gt; m_fontSizeMin)
                    {
                        m_maxFontSize = m_fontSize;

                        m_fontSize -= Mathf.Max((m_fontSize - m_minFontSize) / 2, 0.05f);
                        m_fontSize = (int)(Mathf.Max(m_fontSize, m_fontSizeMin) * 20 + 0.5f) / 20f;

                        //m_recursiveCount = 0;
                        //if (loopCountA &gt; 20) return; // Added to debug 
                        CalculatePreferredValues(m_fontSize, marginSize, false);
                        return Vector2.zero;
                    }
                    #endregion Text Auto-Sizing
                }
                */</comment>
                <cpp:endregion>#<cpp:directive>endregion</cpp:directive> Check Vertical Bounds</cpp:endregion>


                <comment type="line">// Handle xAdvance &amp; Tabulation Stops. Tab stops at every 25% of Font Size.</comment>
                <cpp:region>#<cpp:directive>region</cpp:directive> <name>XAdvance</name><name>,</name> <name>Tabulation</name> <name>&amp;</name> <name>Stops</name></cpp:region>
                <if>if <condition>(<expr><name>charCode</name> <operator>==</operator> <literal type="number">9</literal></expr>)</condition><then>
                <block>{
                    <decl_stmt><decl><type><name>float</name></type> <name>tabSize</name> <init>= <expr><name><name>m_currentFontAsset</name><operator>.</operator><name>fontInfo</name><operator>.</operator><name>TabWidth</name></name> <operator>*</operator> <name>currentElementScale</name></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>float</name></type> <name>tabs</name> <init>= <expr><call><name><name>Mathf</name><operator>.</operator><name>Ceil</name></name><argument_list>(<argument><expr><name>m_xAdvance</name> <operator>/</operator> <name>tabSize</name></expr></argument>)</argument_list></call> <operator>*</operator> <name>tabSize</name></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><name>m_xAdvance</name> <operator>=</operator> <ternary><condition><expr><name>tabs</name> <operator>&gt;</operator> <name>m_xAdvance</name></expr> ?</condition><then> <expr><name>tabs</name></expr> </then><else>: <expr><name>m_xAdvance</name> <operator>+</operator> <name>tabSize</name></expr></else></ternary></expr>;</expr_stmt>
                }</block></then>
                <elseif>else <if>if <condition>(<expr><name>m_monoSpacing</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><then>
                <block>{
                    <expr_stmt><expr><name>m_xAdvance</name> <operator>+=</operator> <operator>(</operator><name>m_monoSpacing</name> <operator>-</operator> <name>monoAdvance</name> <operator>+</operator> <operator>(</operator><operator>(</operator><name>m_characterSpacing</name> <operator>+</operator> <name><name>m_currentFontAsset</name><operator>.</operator><name>normalSpacingOffset</name></name><operator>)</operator> <operator>*</operator> <name>currentElementScale</name><operator>)</operator> <operator>+</operator> <name>m_cSpacing</name><operator>)</operator> <operator>*</operator> <operator>(</operator><literal type="number">1</literal> <operator>-</operator> <name>m_charWidthAdjDelta</name><operator>)</operator></expr>;</expr_stmt>

                    <if>if <condition>(<expr><call><name><name>char</name><operator>.</operator><name>IsWhiteSpace</name></name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>)</operator><name>charCode</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>charCode</name> <operator>==</operator> <literal type="number">0x200B</literal></expr>)</condition><then>
                        <block type="pseudo"><expr_stmt><expr><name>m_xAdvance</name> <operator>+=</operator> <name>m_wordSpacing</name> <operator>*</operator> <name>currentElementScale</name></expr>;</expr_stmt></block></then></if>
                }</block></then></if></elseif>
                <else>else
                <block>{
                    <expr_stmt><expr><name>m_xAdvance</name> <operator>+=</operator> <operator>(</operator><operator>(</operator><name><name>m_cached_TextElement</name><operator>.</operator><name>xAdvance</name></name> <operator>*</operator> <name>bold_xAdvance_multiplier</name> <operator>+</operator> <name>m_characterSpacing</name> <operator>+</operator> <name><name>m_currentFontAsset</name><operator>.</operator><name>normalSpacingOffset</name></name> <operator>+</operator> <name><name>glyphAdjustments</name><operator>.</operator><name>xAdvance</name></name><operator>)</operator> <operator>*</operator> <name>currentElementScale</name> <operator>+</operator> <name>m_cSpacing</name><operator>)</operator> <operator>*</operator> <operator>(</operator><literal type="number">1</literal> <operator>-</operator> <name>m_charWidthAdjDelta</name><operator>)</operator></expr>;</expr_stmt>

                    <if>if <condition>(<expr><call><name><name>char</name><operator>.</operator><name>IsWhiteSpace</name></name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>)</operator><name>charCode</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>charCode</name> <operator>==</operator> <literal type="number">0x200B</literal></expr>)</condition><then>
                        <block type="pseudo"><expr_stmt><expr><name>m_xAdvance</name> <operator>+=</operator> <name>m_wordSpacing</name> <operator>*</operator> <name>currentElementScale</name></expr>;</expr_stmt></block></then></if>
                }</block></else></if>


                <cpp:endregion>#<cpp:directive>endregion</cpp:directive> Tabulation &amp; Stops</cpp:endregion>


                <comment type="line">// Handle Carriage Return</comment>
                <cpp:region>#<cpp:directive>region</cpp:directive> <name>Carriage</name> <name>Return</name></cpp:region>
                <if>if <condition>(<expr><name>charCode</name> <operator>==</operator> <literal type="number">13</literal></expr>)</condition><then>
                <block>{
                    <expr_stmt><expr><name>maxXAdvance</name> <operator>=</operator> <call><name><name>Mathf</name><operator>.</operator><name>Max</name></name><argument_list>(<argument><expr><name>maxXAdvance</name></expr></argument>, <argument><expr><name>renderedWidth</name> <operator>+</operator> <name>m_xAdvance</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>renderedWidth</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><name>m_xAdvance</name> <operator>=</operator> <literal type="number">0</literal> <operator>+</operator> <name>tag_Indent</name></expr>;</expr_stmt>
                }</block></then></if>
                <cpp:endregion>#<cpp:directive>endregion</cpp:directive> Carriage Return</cpp:endregion>


                <comment type="line">// Handle Line Spacing Adjustments + Word Wrapping &amp; special case for last line.</comment>
                <cpp:region>#<cpp:directive>region</cpp:directive> <name>Check</name> <name>for</name> <name>Line</name> <name>Feed</name> <name>and</name> <name>Last</name> <name>Character</name></cpp:region>
                <if>if <condition>(<expr><name>charCode</name> <operator>==</operator> <literal type="number">10</literal> <operator>||</operator> <name>m_characterCount</name> <operator>==</operator> <name>totalCharacterCount</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><then>
                <block>{
                    <comment type="line">// Check if Line Spacing of previous line needs to be adjusted.</comment>
                    <if>if <condition>(<expr><name>m_lineNumber</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>TMP_Math</name><operator>.</operator><name>Approximately</name></name><argument_list>(<argument><expr><name>m_maxLineAscender</name></expr></argument>, <argument><expr><name>m_startOfLineAscender</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>m_lineHeight</name> <operator>==</operator> <name><name>TMP_Math</name><operator>.</operator><name>FLOAT_UNSET</name></name></expr>)</condition><then>
                    <block>{
                        <comment type="line">//Debug.Log("(2) Adjusting Line Spacing on line #" + m_lineNumber);</comment>
                        <decl_stmt><decl><type><name>float</name></type> <name>offsetDelta</name> <init>= <expr><name>m_maxLineAscender</name> <operator>-</operator> <name>m_startOfLineAscender</name></expr></init></decl>;</decl_stmt>
                        <comment type="line">//AdjustLineOffset(m_firstCharacterOfLine, m_characterCount, offsetDelta);</comment>
                        <expr_stmt><expr><name>elementDescenderII</name> <operator>-=</operator> <name>offsetDelta</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>m_lineOffset</name> <operator>+=</operator> <name>offsetDelta</name></expr>;</expr_stmt>
                    }</block></then></if>

                    <comment type="line">// Calculate lineAscender &amp; make sure if last character is superscript or subscript that we check that as well.</comment>
                    <comment type="line">//float lineAscender = m_maxLineAscender - m_lineOffset;</comment>
                    <decl_stmt><decl><type><name>float</name></type> <name>lineDescender</name> <init>= <expr><name>m_maxLineDescender</name> <operator>-</operator> <name>m_lineOffset</name></expr></init></decl>;</decl_stmt>

                    <comment type="line">// Update maxDescender and maxVisibleDescender</comment>
                    <expr_stmt><expr><name>m_maxDescender</name> <operator>=</operator> <ternary><condition><expr><name>m_maxDescender</name> <operator>&lt;</operator> <name>lineDescender</name></expr> ?</condition><then> <expr><name>m_maxDescender</name></expr> </then><else>: <expr><name>lineDescender</name></expr></else></ternary></expr>;</expr_stmt>

                    <expr_stmt><expr><name>m_firstCharacterOfLine</name> <operator>=</operator> <name>m_characterCount</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

                    <comment type="line">// Store PreferredWidth paying attention to linefeed and last character of text.</comment>
                    <if>if <condition>(<expr><name>charCode</name> <operator>==</operator> <literal type="number">10</literal> <operator>&amp;&amp;</operator> <name>m_characterCount</name> <operator>!=</operator> <name>totalCharacterCount</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><then>
                    <block>{
                        <expr_stmt><expr><name>maxXAdvance</name> <operator>=</operator> <call><name><name>Mathf</name><operator>.</operator><name>Max</name></name><argument_list>(<argument><expr><name>maxXAdvance</name></expr></argument>, <argument><expr><name>renderedWidth</name> <operator>+</operator> <name>linebreakingWidth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>renderedWidth</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                    }</block></then>
                    <else>else
                        <block type="pseudo"><expr_stmt><expr><name>renderedWidth</name> <operator>=</operator> <call><name><name>Mathf</name><operator>.</operator><name>Max</name></name><argument_list>(<argument><expr><name>maxXAdvance</name></expr></argument>, <argument><expr><name>renderedWidth</name> <operator>+</operator> <name>linebreakingWidth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block></else></if>


                    <expr_stmt><expr><name>renderedHeight</name> <operator>=</operator> <name>m_maxAscender</name> <operator>-</operator> <name>m_maxDescender</name></expr>;</expr_stmt>


                    <comment type="line">// Add new line if not last lines or character.</comment>
                    <if>if <condition>(<expr><name>charCode</name> <operator>==</operator> <literal type="number">10</literal></expr>)</condition><then>
                    <block>{
                        <comment type="line">// Store the state of the line before starting on the new line.</comment>
                        <expr_stmt><expr><call><name>SaveWordWrappingState</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>savedLineState</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>m_characterCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <comment type="line">// Store the state of the last Character before the new line.</comment>
                        <expr_stmt><expr><call><name>SaveWordWrappingState</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>savedWordWrapState</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>m_characterCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <expr_stmt><expr><name>m_lineNumber</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

                        <comment type="line">// Apply Line Spacing</comment>
                        <if>if <condition>(<expr><name>m_lineHeight</name> <operator>==</operator> <name><name>TMP_Math</name><operator>.</operator><name>FLOAT_UNSET</name></name></expr>)</condition><then>
                        <block>{
                            <expr_stmt><expr><name>lineOffsetDelta</name> <operator>=</operator> <literal type="number">0</literal> <operator>-</operator> <name>m_maxLineDescender</name> <operator>+</operator> <name>elementAscender</name> <operator>+</operator> <operator>(</operator><name>lineGap</name> <operator>+</operator> <name>m_lineSpacing</name> <operator>+</operator> <name>m_paragraphSpacing</name> <operator>+</operator> <name>m_lineSpacingDelta</name><operator>)</operator> <operator>*</operator> <name>baseScale</name></expr>;</expr_stmt>
                            <expr_stmt><expr><name>m_lineOffset</name> <operator>+=</operator> <name>lineOffsetDelta</name></expr>;</expr_stmt>
                        }</block></then>
                        <else>else
                            <block type="pseudo"><expr_stmt><expr><name>m_lineOffset</name> <operator>+=</operator> <name>m_lineHeight</name> <operator>+</operator> <operator>(</operator><name>m_lineSpacing</name> <operator>+</operator> <name>m_paragraphSpacing</name><operator>)</operator> <operator>*</operator> <name>baseScale</name></expr>;</expr_stmt></block></else></if>

                        <expr_stmt><expr><name>m_maxLineAscender</name> <operator>=</operator> <name>k_LargeNegativeFloat</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>m_maxLineDescender</name> <operator>=</operator> <name>k_LargePositiveFloat</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>m_startOfLineAscender</name> <operator>=</operator> <name>elementAscender</name></expr>;</expr_stmt>

                        <expr_stmt><expr><name>m_xAdvance</name> <operator>=</operator> <literal type="number">0</literal> <operator>+</operator> <name>tag_LineIndent</name> <operator>+</operator> <name>tag_Indent</name></expr>;</expr_stmt>

                        <expr_stmt><expr><name>m_characterCount</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                        <continue>continue;</continue>
                    }</block></then></if>
                }</block></then></if>
                <cpp:endregion>#<cpp:directive>endregion</cpp:directive> Check for Linefeed or Last Character</cpp:endregion>


                <comment type="line">// Save State of Mesh Creation for handling of Word Wrapping</comment>
                <cpp:region>#<cpp:directive>region</cpp:directive> <name>Save</name> <name>Word</name> <name>Wrapping</name> <name>State</name></cpp:region>
                <if>if <condition>(<expr><name>m_enableWordWrapping</name> <operator>||</operator> <name>m_overflowMode</name> <operator>==</operator> <name><name>TextOverflowModes</name><operator>.</operator><name>Truncate</name></name> <operator>||</operator> <name>m_overflowMode</name> <operator>==</operator> <name><name>TextOverflowModes</name><operator>.</operator><name>Ellipsis</name></name></expr>)</condition><then>
                <block>{
                    <if>if <condition>(<expr><operator>(</operator><call><name><name>char</name><operator>.</operator><name>IsWhiteSpace</name></name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>)</operator><name>charCode</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>charCode</name> <operator>==</operator> <literal type="number">0x200B</literal> <operator>||</operator> <name>charCode</name> <operator>==</operator> <literal type="number">0x2D</literal> <operator>||</operator> <name>charCode</name> <operator>==</operator> <literal type="number">0xAD</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><name>m_isNonBreakingSpace</name> <operator>&amp;&amp;</operator> <name>charCode</name> <operator>!=</operator> <literal type="number">0xA0</literal> <operator>&amp;&amp;</operator> <name>charCode</name> <operator>!=</operator> <literal type="number">0x2011</literal> <operator>&amp;&amp;</operator> <name>charCode</name> <operator>!=</operator> <literal type="number">0x202F</literal> <operator>&amp;&amp;</operator> <name>charCode</name> <operator>!=</operator> <literal type="number">0x2060</literal></expr>)</condition><then>
                    <block>{
                        <comment type="line">// We store the state of numerous variables for the most recent Space, LineFeed or Carriage Return to enable them to be restored </comment>
                        <comment type="line">// for Word Wrapping.</comment>
                        <expr_stmt><expr><call><name>SaveWordWrappingState</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>savedWordWrapState</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>m_characterCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>m_isCharacterWrappingEnabled</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
                        <expr_stmt><expr><name>isFirstWord</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
                    }</block></then>
                    <comment type="line">// Handling for East Asian languages</comment>
                    <elseif>else <if>if <condition>(<expr><operator>(</operator><name>charCode</name> <operator>&gt;</operator> <literal type="number">0x1100</literal> <operator>&amp;&amp;</operator> <name><name>charCode</name> <argument_list type="generic">&lt; <argument><literal type="number">0x11ff</literal> <operator>||</operator> <comment type="block">/* Hangul Jamo */</comment>
                                <name>charCode</name></argument> &gt;</argument_list></name> <literal type="number">0x2E80</literal> <operator>&amp;&amp;</operator> <name><name>charCode</name> <argument_list type="generic">&lt; <argument><literal type="number">0x9FFF</literal> <operator>||</operator> <comment type="block">/* CJK */</comment>
                                <name>charCode</name></argument> &gt;</argument_list></name> <literal type="number">0xA960</literal> <operator>&amp;&amp;</operator> <name><name>charCode</name> <argument_list type="generic">&lt; <argument><literal type="number">0xA97F</literal> <operator>||</operator> <comment type="block">/* Hangul Jame Extended-A */</comment>
                                <name>charCode</name></argument> &gt;</argument_list></name> <literal type="number">0xAC00</literal> <operator>&amp;&amp;</operator> <name><name>charCode</name> <argument_list type="generic">&lt; <argument><literal type="number">0xD7FF</literal> <operator>||</operator> <comment type="block">/* Hangul Syllables */</comment>
                                <name>charCode</name></argument> &gt;</argument_list></name> <literal type="number">0xF900</literal> <operator>&amp;&amp;</operator> <name><name>charCode</name> <argument_list type="generic">&lt; <argument><literal type="number">0xFAFF</literal> <operator>||</operator> <comment type="block">/* CJK Compatibility Ideographs */</comment>
                                <name>charCode</name></argument> &gt;</argument_list></name> <literal type="number">0xFE30</literal> <operator>&amp;&amp;</operator> <name><name>charCode</name> <argument_list type="generic">&lt; <argument><literal type="number">0xFE4F</literal> <operator>||</operator> <comment type="block">/* CJK Compatibility Forms */</comment>
                                <name>charCode</name></argument> &gt;</argument_list></name> <literal type="number">0xFF00</literal> <operator>&amp;&amp;</operator> <name>charCode</name> <operator>&lt;</operator> <literal type="number">0xFFEF</literal><operator>)</operator>   <comment type="block">/* CJK Halfwidth */</comment>
                                <operator>&amp;&amp;</operator> <operator>!</operator><name>m_isNonBreakingSpace</name></expr>)</condition><then>
                    <block>{
                        <if>if <condition>(<expr><name>isFirstWord</name> <operator>||</operator> <name>isLastBreakingChar</name> <operator>||</operator> <call><name><name>TMP_Settings</name><operator>.</operator><name>linebreakingRules</name><operator>.</operator><name>leadingCharacters</name><operator>.</operator><name>ContainsKey</name></name><argument_list>(<argument><expr><name>charCode</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="boolean">false</literal> <operator>&amp;&amp;</operator>
                            <operator>(</operator><name>m_characterCount</name> <operator>&lt;</operator> <name>totalCharacterCount</name> <operator>-</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
                            <call><name><name>TMP_Settings</name><operator>.</operator><name>linebreakingRules</name><operator>.</operator><name>followingCharacters</name><operator>.</operator><name>ContainsKey</name></name><argument_list>(<argument><expr><name><name>m_internalCharacterInfo</name><index>[<expr><name>m_characterCount</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>character</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="boolean">false</literal><operator>)</operator></expr>)</condition><then>
                        <block>{
                            <expr_stmt><expr><call><name>SaveWordWrappingState</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>savedWordWrapState</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>m_characterCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name>m_isCharacterWrappingEnabled</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
                            <expr_stmt><expr><name>isFirstWord</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
                        }</block></then></if>
                    }</block></then></if></elseif>
                    <elseif>else <if>if <condition>(<expr><operator>(</operator><name>isFirstWord</name> <operator>||</operator> <name>m_isCharacterWrappingEnabled</name> <operator>==</operator> <literal type="boolean">true</literal> <operator>||</operator> <name>isLastBreakingChar</name><operator>)</operator></expr>)</condition><then>
                        <block type="pseudo"><expr_stmt><expr><call><name>SaveWordWrappingState</name><argument_list>(<argument><modifier>ref</modifier> <expr><name>savedWordWrapState</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>m_characterCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block></then></if></elseif></if>
                }</block></then></if>
                <cpp:endregion>#<cpp:directive>endregion</cpp:directive> Save Word Wrapping State</cpp:endregion>

                <expr_stmt><expr><name>m_characterCount</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            }</block></for>

            <comment type="line">// Check Auto Sizing and increase font size to fill text container.</comment>
            <cpp:region>#<cpp:directive>region</cpp:directive> <name>Check</name> <name>Auto</name><name>-</name><name>Sizing</name> <name>(</name><name>Upper</name> <name>Font</name> <name>Size</name> <name>Bounds</name><name>)</name></cpp:region>
            <expr_stmt><expr><name>fontSizeDelta</name> <operator>=</operator> <name>m_maxFontSize</name> <operator>-</operator> <name>m_minFontSize</name></expr>;</expr_stmt>
            <if>if <condition>(<expr><operator>!</operator><name>m_isCharacterWrappingEnabled</name> <operator>&amp;&amp;</operator> <name>ignoreTextAutoSizing</name> <operator>==</operator> <literal type="boolean">false</literal> <operator>&amp;&amp;</operator> <name>fontSizeDelta</name> <operator>&gt;</operator> <literal type="number">0.051f</literal> <operator>&amp;&amp;</operator> <name>defaultFontSize</name> <operator>&lt;</operator> <name>m_fontSizeMax</name></expr>)</condition><then>
            <block>{
                <expr_stmt><expr><name>m_minFontSize</name> <operator>=</operator> <name>defaultFontSize</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>defaultFontSize</name> <operator>+=</operator> <call><name><name>Mathf</name><operator>.</operator><name>Max</name></name><argument_list>(<argument><expr><operator>(</operator><name>m_maxFontSize</name> <operator>-</operator> <name>defaultFontSize</name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">0.05f</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>defaultFontSize</name> <operator>=</operator> <call>(<name>int</name>)<argument_list>(<argument><expr><call><name><name>Mathf</name><operator>.</operator><name>Min</name></name><argument_list>(<argument><expr><name>defaultFontSize</name></expr></argument>, <argument><expr><name>m_fontSizeMax</name></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">20</literal> <operator>+</operator> <literal type="number">0.5f</literal></expr></argument>)</argument_list></call> <operator>/</operator> <literal type="number">20f</literal></expr>;</expr_stmt>

                <if>if <condition>(<expr><name>m_recursiveCount</name> <operator>&gt;</operator> <literal type="number">20</literal></expr>)</condition><then> <block type="pseudo"><return>return <expr><operator>new</operator> <call><name>Vector2</name><argument_list>(<argument><expr><name>renderedWidth</name></expr></argument>, <argument><expr><name>renderedHeight</name></expr></argument>)</argument_list></call></expr>;</return></block></then></if>
                <return>return <expr><call><name>CalculatePreferredValues</name><argument_list>(<argument><expr><name>defaultFontSize</name></expr></argument>, <argument><expr><name>marginSize</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</return>
            }</block></then></if>
            <cpp:endregion>#<cpp:directive>endregion</cpp:directive> End Auto-sizing Check</cpp:endregion>


            <expr_stmt><expr><name>m_isCharacterWrappingEnabled</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>m_isCalculatingPreferredValues</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>

            <comment type="line">// Adjust Preferred Width and Height to account for Margins.</comment>
            <expr_stmt><expr><name>renderedWidth</name> <operator>+=</operator> <ternary><condition><expr><name><name>m_margin</name><operator>.</operator><name>x</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name><name>m_margin</name><operator>.</operator><name>x</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
            <expr_stmt><expr><name>renderedWidth</name> <operator>+=</operator> <ternary><condition><expr><name><name>m_margin</name><operator>.</operator><name>z</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name><name>m_margin</name><operator>.</operator><name>z</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>

            <expr_stmt><expr><name>renderedHeight</name> <operator>+=</operator> <ternary><condition><expr><name><name>m_margin</name><operator>.</operator><name>y</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name><name>m_margin</name><operator>.</operator><name>y</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
            <expr_stmt><expr><name>renderedHeight</name> <operator>+=</operator> <ternary><condition><expr><name><name>m_margin</name><operator>.</operator><name>w</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name><name>m_margin</name><operator>.</operator><name>w</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>

            <comment type="line">// Round Preferred Values to nearest 5/100.</comment>
            <expr_stmt><expr><name>renderedWidth</name> <operator>=</operator> <call>(<name>int</name>)<argument_list>(<argument><expr><name>renderedWidth</name> <operator>*</operator> <literal type="number">100</literal> <operator>+</operator> <literal type="number">1f</literal></expr></argument>)</argument_list></call> <operator>/</operator> <literal type="number">100f</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>renderedHeight</name> <operator>=</operator> <call>(<name>int</name>)<argument_list>(<argument><expr><name>renderedHeight</name> <operator>*</operator> <literal type="number">100</literal> <operator>+</operator> <literal type="number">1f</literal></expr></argument>)</argument_list></call> <operator>/</operator> <literal type="number">100f</literal></expr>;</expr_stmt>

            <comment type="line">//Debug.Log("Preferred Values: (" + renderedWidth + ", " + renderedHeight + ") with Recursive count of " + m_recursiveCount);</comment>

            <comment type="line">////Profiler.EndSample();</comment>
            <return>return <expr><operator>new</operator> <call><name>Vector2</name><argument_list>(<argument><expr><name>renderedWidth</name></expr></argument>, <argument><expr><name>renderedHeight</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></function>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Method returning the compound bounds of the text object and child sub objects.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;returns&gt;&lt;/returns&gt;</comment>
        <function><specifier>protected</specifier> <specifier>virtual</specifier> <type><name>Bounds</name></type> <name>GetCompoundBounds</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><operator>new</operator> <call><name>Bounds</name><argument_list>()</argument_list></call></expr>;</return> }</block></function>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Method which returns the bounds of the text object;</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;returns&gt;&lt;/returns&gt;</comment>
        <function><specifier>protected</specifier> <type><name>Bounds</name></type> <name>GetTextBounds</name><parameter_list>()</parameter_list>
        <block>{
            <if>if <condition>(<expr><name>m_textInfo</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name><name>m_textInfo</name><operator>.</operator><name>characterCount</name></name> <operator>&gt;</operator> <name><name>m_textInfo</name><operator>.</operator><name>characterInfo</name><operator>.</operator><name>Length</name></name></expr>)</condition><then> <block type="pseudo"><return>return <expr><operator>new</operator> <call><name>Bounds</name><argument_list>()</argument_list></call></expr>;</return></block></then></if>

            <decl_stmt><decl><type><name>Extents</name></type> <name>extent</name> <init>= <expr><operator>new</operator> <call><name>Extents</name><argument_list>(<argument><expr><name>k_LargePositiveVector2</name></expr></argument>, <argument><expr><name>k_LargeNegativeVector2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>m_textInfo</name><operator>.</operator><name>characterCount</name></name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name><name>m_textInfo</name><operator>.</operator><name>characterInfo</name><operator>.</operator><name>Length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{
                <if>if <condition>(<expr><operator>!</operator><name><name>m_textInfo</name><operator>.</operator><name>characterInfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>isVisible</name></expr>)</condition><then> <block type="pseudo"><continue>continue;</continue></block></then></if>

                <expr_stmt><expr><name><name>extent</name><operator>.</operator><name>min</name><operator>.</operator><name>x</name></name> <operator>=</operator> <call><name><name>Mathf</name><operator>.</operator><name>Min</name></name><argument_list>(<argument><expr><name><name>extent</name><operator>.</operator><name>min</name><operator>.</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>m_textInfo</name><operator>.</operator><name>characterInfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>bottomLeft</name><operator>.</operator><name>x</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>extent</name><operator>.</operator><name>min</name><operator>.</operator><name>y</name></name> <operator>=</operator> <call><name><name>Mathf</name><operator>.</operator><name>Min</name></name><argument_list>(<argument><expr><name><name>extent</name><operator>.</operator><name>min</name><operator>.</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>m_textInfo</name><operator>.</operator><name>characterInfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>descender</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>extent</name><operator>.</operator><name>max</name><operator>.</operator><name>x</name></name> <operator>=</operator> <call><name><name>Mathf</name><operator>.</operator><name>Max</name></name><argument_list>(<argument><expr><name><name>extent</name><operator>.</operator><name>max</name><operator>.</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>m_textInfo</name><operator>.</operator><name>characterInfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>xAdvance</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>extent</name><operator>.</operator><name>max</name><operator>.</operator><name>y</name></name> <operator>=</operator> <call><name><name>Mathf</name><operator>.</operator><name>Max</name></name><argument_list>(<argument><expr><name><name>extent</name><operator>.</operator><name>max</name><operator>.</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>m_textInfo</name><operator>.</operator><name>characterInfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ascender</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>

            <decl_stmt><decl><type><name>Vector2</name></type> <name>size</name></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>size</name><operator>.</operator><name>x</name></name> <operator>=</operator> <name><name>extent</name><operator>.</operator><name>max</name><operator>.</operator><name>x</name></name> <operator>-</operator> <name><name>extent</name><operator>.</operator><name>min</name><operator>.</operator><name>x</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>size</name><operator>.</operator><name>y</name></name> <operator>=</operator> <name><name>extent</name><operator>.</operator><name>max</name><operator>.</operator><name>y</name></name> <operator>-</operator> <name><name>extent</name><operator>.</operator><name>min</name><operator>.</operator><name>y</name></name></expr>;</expr_stmt>

            <decl_stmt><decl><type><name>Vector3</name></type> <name>center</name> <init>= <expr><operator>(</operator><name><name>extent</name><operator>.</operator><name>min</name></name> <operator>+</operator> <name><name>extent</name><operator>.</operator><name>max</name></name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>

            <return>return <expr><operator>new</operator> <call><name>Bounds</name><argument_list>(<argument><expr><name>center</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></function>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Method which returns the bounds of the text object;</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;param name="onlyVisibleCharacters"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;returns&gt;&lt;/returns&gt;</comment>
        <function><specifier>protected</specifier> <type><name>Bounds</name></type> <name>GetTextBounds</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>onlyVisibleCharacters</name></decl></parameter>)</parameter_list>
        <block>{
            <if>if <condition>(<expr><name>m_textInfo</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then> <block type="pseudo"><return>return <expr><operator>new</operator> <call><name>Bounds</name><argument_list>()</argument_list></call></expr>;</return></block></then></if>

            <decl_stmt><decl><type><name>Extents</name></type> <name>extent</name> <init>= <expr><operator>new</operator> <call><name>Extents</name><argument_list>(<argument><expr><name>k_LargePositiveVector2</name></expr></argument>, <argument><expr><name>k_LargeNegativeVector2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>m_textInfo</name><operator>.</operator><name>characterCount</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{
                <if>if <condition>(<expr><operator>(</operator><name>i</name> <operator>&gt;</operator> <name>maxVisibleCharacters</name> <operator>||</operator> <name><name>m_textInfo</name><operator>.</operator><name>characterInfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>lineNumber</name> <operator>&gt;</operator> <name>m_maxVisibleLines</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>onlyVisibleCharacters</name></expr>)</condition><then> <block type="pseudo"><break>break;</break></block></then></if>

                <if>if <condition>(<expr><name>onlyVisibleCharacters</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>m_textInfo</name><operator>.</operator><name>characterInfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>isVisible</name></expr>)</condition><then> <block type="pseudo"><continue>continue;</continue></block></then></if>

                <expr_stmt><expr><name><name>extent</name><operator>.</operator><name>min</name><operator>.</operator><name>x</name></name> <operator>=</operator> <call><name><name>Mathf</name><operator>.</operator><name>Min</name></name><argument_list>(<argument><expr><name><name>extent</name><operator>.</operator><name>min</name><operator>.</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>m_textInfo</name><operator>.</operator><name>characterInfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>origin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>extent</name><operator>.</operator><name>min</name><operator>.</operator><name>y</name></name> <operator>=</operator> <call><name><name>Mathf</name><operator>.</operator><name>Min</name></name><argument_list>(<argument><expr><name><name>extent</name><operator>.</operator><name>min</name><operator>.</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>m_textInfo</name><operator>.</operator><name>characterInfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>descender</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>extent</name><operator>.</operator><name>max</name><operator>.</operator><name>x</name></name> <operator>=</operator> <call><name><name>Mathf</name><operator>.</operator><name>Max</name></name><argument_list>(<argument><expr><name><name>extent</name><operator>.</operator><name>max</name><operator>.</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>m_textInfo</name><operator>.</operator><name>characterInfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>xAdvance</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>extent</name><operator>.</operator><name>max</name><operator>.</operator><name>y</name></name> <operator>=</operator> <call><name><name>Mathf</name><operator>.</operator><name>Max</name></name><argument_list>(<argument><expr><name><name>extent</name><operator>.</operator><name>max</name><operator>.</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>m_textInfo</name><operator>.</operator><name>characterInfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ascender</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>

            <decl_stmt><decl><type><name>Vector2</name></type> <name>size</name></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>size</name><operator>.</operator><name>x</name></name> <operator>=</operator> <name><name>extent</name><operator>.</operator><name>max</name><operator>.</operator><name>x</name></name> <operator>-</operator> <name><name>extent</name><operator>.</operator><name>min</name><operator>.</operator><name>x</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>size</name><operator>.</operator><name>y</name></name> <operator>=</operator> <name><name>extent</name><operator>.</operator><name>max</name><operator>.</operator><name>y</name></name> <operator>-</operator> <name><name>extent</name><operator>.</operator><name>min</name><operator>.</operator><name>y</name></name></expr>;</expr_stmt>

            <decl_stmt><decl><type><name>Vector2</name></type> <name>center</name> <init>= <expr><operator>(</operator><name><name>extent</name><operator>.</operator><name>min</name></name> <operator>+</operator> <name><name>extent</name><operator>.</operator><name>max</name></name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>

            <return>return <expr><operator>new</operator> <call><name>Bounds</name><argument_list>(<argument><expr><name>center</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></function>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Method to adjust line spacing as a result of using different fonts or font point size.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;param name="startIndex"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="endIndex"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="offset"&gt;&lt;/param&gt;</comment>
        <function><specifier>protected</specifier> <specifier>virtual</specifier> <type><name>void</name></type> <name>AdjustLineOffset</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>startIndex</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>endIndex</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>offset</name></decl></parameter>)</parameter_list> <block>{ }</block></function>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Function to increase the size of the Line Extents Array.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;param name="size"&gt;&lt;/param&gt;</comment>
        <function><specifier>protected</specifier> <type><name>void</name></type> <name>ResizeLineExtents</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>)</parameter_list>
        <block>{
            <expr_stmt><expr><name>size</name> <operator>=</operator> <ternary><condition><expr><name>size</name> <operator>&gt;</operator> <literal type="number">1024</literal></expr> ?</condition><then> <expr><name>size</name> <operator>+</operator> <literal type="number">256</literal></expr> </then><else>: <expr><call><name><name>Mathf</name><operator>.</operator><name>NextPowerOfTwo</name></name><argument_list>(<argument><expr><name>size</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

            <decl_stmt><decl><type><name><name>TMP_LineInfo</name><index>[]</index></name></type> <name>temp_lineInfo</name> <init>= <expr><operator>new</operator> <name><name>TMP_LineInfo</name><index>[<expr><name>size</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{
                <if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name><name>m_textInfo</name><operator>.</operator><name>lineInfo</name><operator>.</operator><name>Length</name></name></expr>)</condition><then>
                    <block type="pseudo"><expr_stmt><expr><name><name>temp_lineInfo</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>m_textInfo</name><operator>.</operator><name>lineInfo</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block></then>
                <else>else
                <block>{
                    <expr_stmt><expr><name><name>temp_lineInfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>lineExtents</name><operator>.</operator><name>min</name></name> <operator>=</operator> <name>k_LargePositiveVector2</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>temp_lineInfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>lineExtents</name><operator>.</operator><name>max</name></name> <operator>=</operator> <name>k_LargeNegativeVector2</name></expr>;</expr_stmt>

                    <expr_stmt><expr><name><name>temp_lineInfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ascender</name> <operator>=</operator> <name>k_LargeNegativeFloat</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>temp_lineInfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>descender</name> <operator>=</operator> <name>k_LargePositiveFloat</name></expr>;</expr_stmt>
                }</block></else></if>
            }</block></for>

            <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>lineInfo</name></name> <operator>=</operator> <name>temp_lineInfo</name></expr>;</expr_stmt>
        }</block></function>
        <decl_stmt><decl><specifier>protected</specifier> <specifier>static</specifier> <type><name>Vector2</name></type> <name>k_LargePositiveVector2</name> <init>= <expr><operator>new</operator> <call><name>Vector2</name><argument_list>(<argument><expr><name><name>TMP_Math</name><operator>.</operator><name>INT_MAX</name></name></expr></argument>, <argument><expr><name><name>TMP_Math</name><operator>.</operator><name>INT_MAX</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><specifier>protected</specifier> <specifier>static</specifier> <type><name>Vector2</name></type> <name>k_LargeNegativeVector2</name> <init>= <expr><operator>new</operator> <call><name>Vector2</name><argument_list>(<argument><expr><name><name>TMP_Math</name><operator>.</operator><name>INT_MIN</name></name></expr></argument>, <argument><expr><name><name>TMP_Math</name><operator>.</operator><name>INT_MIN</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><specifier>protected</specifier> <specifier>static</specifier> <type><name>float</name></type> <name>k_LargePositiveFloat</name> <init>= <expr><name><name>TMP_Math</name><operator>.</operator><name>FLOAT_MAX</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><specifier>protected</specifier> <specifier>static</specifier> <type><name>float</name></type> <name>k_LargeNegativeFloat</name> <init>= <expr><name><name>TMP_Math</name><operator>.</operator><name>FLOAT_MIN</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><specifier>protected</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>k_LargePositiveInt</name> <init>= <expr><name><name>TMP_Math</name><operator>.</operator><name>INT_MAX</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><specifier>protected</specifier> <specifier>static</specifier> <type><name>int</name></type> <name>k_LargeNegativeInt</name> <init>= <expr><name><name>TMP_Math</name><operator>.</operator><name>INT_MIN</name></name></expr></init></decl>;</decl_stmt>

        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Function used to evaluate the length of a text string.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;param name="text"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;returns&gt;&lt;/returns&gt;</comment>
        <function><specifier>public</specifier> <specifier>virtual</specifier> <type><name>TMP_TextInfo</name></type> <name>GetTextInfo</name><parameter_list>(<parameter><decl><type><name>string</name></type> <name>text</name></decl></parameter>)</parameter_list> <block>{ <return>return <expr><literal type="null">null</literal></expr>;</return> }</block></function>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Function to force an update of the margin size.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <function><specifier>public</specifier> <specifier>virtual</specifier> <type><name>void</name></type> <name>ComputeMarginSize</name><parameter_list>()</parameter_list> <block>{ }</block></function>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Function used in conjunction with GetTextInfo to figure out Array allocations.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;param name="chars"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;returns&gt;&lt;/returns&gt;</comment>
        <comment type="line">//protected int GetArraySizes(int[] chars)</comment>
        <comment type="line">//{</comment>
        <comment type="line">//    //Debug.Log("Set Array Size called.");</comment>

        <comment type="line">//    //int visibleCount = 0;</comment>
        <comment type="line">//    //int totalCount = 0;</comment>
        <comment type="line">//    int tagEnd = 0;</comment>

        <comment type="line">//    m_totalCharacterCount = 0;</comment>
        <comment type="line">//    m_isUsingBold = false;</comment>
        <comment type="line">//    m_isParsingText = false;</comment>


        <comment type="line">//    //m_VisibleCharacters.Clear();</comment>

        <comment type="line">//    for (int i = 0; chars[i] != 0; i++)</comment>
        <comment type="line">//    {</comment>
        <comment type="line">//        int c = chars[i];</comment>

        <comment type="line">//        if (m_isRichText &amp;&amp; c == 60) // if Char '&lt;'</comment>
        <comment type="line">//        {</comment>
        <comment type="line">//            // Check if Tag is Valid</comment>
        <comment type="line">//            if (ValidateHtmlTag(chars, i + 1, out tagEnd))</comment>
        <comment type="line">//            {</comment>
        <comment type="line">//                i = tagEnd;</comment>
        <comment type="line">//                //if ((m_style &amp; FontStyles.Underline) == FontStyles.Underline) visibleCount += 3;</comment>

        <comment type="line">//                if ((m_style &amp; FontStyles.Bold) == FontStyles.Bold) m_isUsingBold = true;</comment>

        <comment type="line">//                continue;</comment>
        <comment type="line">//            }</comment>
        <comment type="line">//        }</comment>

        <comment type="line">//        //if (!char.IsWhiteSpace((char)c) &amp;&amp; c != 0x200B)</comment>
        <comment type="line">//        //{</comment>
        <comment type="line">//            //visibleCount += 1;</comment>
        <comment type="line">//        //}</comment>

        <comment type="line">//        //m_VisibleCharacters.Add((char)c);</comment>
        <comment type="line">//        m_totalCharacterCount += 1;</comment>
        <comment type="line">//    }</comment>

        <comment type="line">//    return m_totalCharacterCount;</comment>
        <comment type="line">//}</comment>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Save the State of various variables used in the mesh creation loop in conjunction with Word Wrapping</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;param name="state"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="index"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="count"&gt;&lt;/param&gt;</comment>
        <function><specifier>protected</specifier> <type><name>void</name></type> <name>SaveWordWrappingState</name><parameter_list>(<parameter><decl><type><modifier>ref</modifier> <name>WordWrapState</name></type> <name>state</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>count</name></decl></parameter>)</parameter_list>
        <block>{
            <comment type="line">// Multi Font &amp; Material support related</comment>
            <expr_stmt><expr><name><name>state</name><operator>.</operator><name>currentFontAsset</name></name> <operator>=</operator> <name>m_currentFontAsset</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>.</operator><name>currentSpriteAsset</name></name> <operator>=</operator> <name>m_currentSpriteAsset</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>.</operator><name>currentMaterial</name></name> <operator>=</operator> <name>m_currentMaterial</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>.</operator><name>currentMaterialIndex</name></name> <operator>=</operator> <name>m_currentMaterialIndex</name></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>state</name><operator>.</operator><name>previous_WordBreak</name></name> <operator>=</operator> <name>index</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>.</operator><name>total_CharacterCount</name></name> <operator>=</operator> <name>count</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>.</operator><name>visible_CharacterCount</name></name> <operator>=</operator> <name>m_lineVisibleCharacterCount</name></expr>;</expr_stmt>
            <comment type="line">//state.visible_CharacterCount = m_visibleCharacterCount;</comment>
            <comment type="line">//state.visible_SpriteCount = m_visibleSpriteCount;</comment>
            <expr_stmt><expr><name><name>state</name><operator>.</operator><name>visible_LinkCount</name></name> <operator>=</operator> <name><name>m_textInfo</name><operator>.</operator><name>linkCount</name></name></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>state</name><operator>.</operator><name>firstCharacterIndex</name></name> <operator>=</operator> <name>m_firstCharacterOfLine</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>.</operator><name>firstVisibleCharacterIndex</name></name> <operator>=</operator> <name>m_firstVisibleCharacterOfLine</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>.</operator><name>lastVisibleCharIndex</name></name> <operator>=</operator> <name>m_lastVisibleCharacterOfLine</name></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>state</name><operator>.</operator><name>fontStyle</name></name> <operator>=</operator> <name>m_style</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>.</operator><name>fontScale</name></name> <operator>=</operator> <name>m_fontScale</name></expr>;</expr_stmt>
            <comment type="line">//state.maxFontScale = m_maxFontScale;</comment>
            <expr_stmt><expr><name><name>state</name><operator>.</operator><name>fontScaleMultiplier</name></name> <operator>=</operator> <name>m_fontScaleMultiplier</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>.</operator><name>currentFontSize</name></name> <operator>=</operator> <name>m_currentFontSize</name></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>state</name><operator>.</operator><name>xAdvance</name></name> <operator>=</operator> <name>m_xAdvance</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>.</operator><name>maxCapHeight</name></name> <operator>=</operator> <name>m_maxCapHeight</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>.</operator><name>maxAscender</name></name> <operator>=</operator> <name>m_maxAscender</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>.</operator><name>maxDescender</name></name> <operator>=</operator> <name>m_maxDescender</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>.</operator><name>maxLineAscender</name></name> <operator>=</operator> <name>m_maxLineAscender</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>.</operator><name>maxLineDescender</name></name> <operator>=</operator> <name>m_maxLineDescender</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>.</operator><name>previousLineAscender</name></name> <operator>=</operator> <name>m_startOfLineAscender</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>.</operator><name>preferredWidth</name></name> <operator>=</operator> <name>m_preferredWidth</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>.</operator><name>preferredHeight</name></name> <operator>=</operator> <name>m_preferredHeight</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>.</operator><name>meshExtents</name></name> <operator>=</operator> <name>m_meshExtents</name></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>state</name><operator>.</operator><name>lineNumber</name></name> <operator>=</operator> <name>m_lineNumber</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>.</operator><name>lineOffset</name></name> <operator>=</operator> <name>m_lineOffset</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>.</operator><name>baselineOffset</name></name> <operator>=</operator> <name>m_baselineOffset</name></expr>;</expr_stmt>

            <comment type="line">//state.alignment = m_lineJustification;</comment>
            <expr_stmt><expr><name><name>state</name><operator>.</operator><name>vertexColor</name></name> <operator>=</operator> <name>m_htmlColor</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>.</operator><name>underlineColor</name></name> <operator>=</operator> <name>m_underlineColor</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>.</operator><name>strikethroughColor</name></name> <operator>=</operator> <name>m_strikethroughColor</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>.</operator><name>highlightColor</name></name> <operator>=</operator> <name>m_highlightColor</name></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>state</name><operator>.</operator><name>isNonBreakingSpace</name></name> <operator>=</operator> <name>m_isNonBreakingSpace</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>.</operator><name>tagNoParsing</name></name> <operator>=</operator> <name>tag_NoParsing</name></expr>;</expr_stmt>

            <comment type="line">// XML Tag Stack</comment>
            <expr_stmt><expr><name><name>state</name><operator>.</operator><name>basicStyleStack</name></name> <operator>=</operator> <name>m_fontStyleStack</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>.</operator><name>colorStack</name></name> <operator>=</operator> <name>m_colorStack</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>.</operator><name>underlineColorStack</name></name> <operator>=</operator> <name>m_underlineColorStack</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>.</operator><name>strikethroughColorStack</name></name> <operator>=</operator> <name>m_strikethroughColorStack</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>.</operator><name>highlightColorStack</name></name> <operator>=</operator> <name>m_highlightColorStack</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>.</operator><name>colorGradientStack</name></name> <operator>=</operator> <name>m_colorGradientStack</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>.</operator><name>sizeStack</name></name> <operator>=</operator> <name>m_sizeStack</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>.</operator><name>indentStack</name></name> <operator>=</operator> <name>m_indentStack</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>.</operator><name>fontWeightStack</name></name> <operator>=</operator> <name>m_fontWeightStack</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>.</operator><name>styleStack</name></name> <operator>=</operator> <name>m_styleStack</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>.</operator><name>baselineStack</name></name> <operator>=</operator> <name>m_baselineOffsetStack</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>.</operator><name>actionStack</name></name> <operator>=</operator> <name>m_actionStack</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>.</operator><name>materialReferenceStack</name></name> <operator>=</operator> <name>m_materialReferenceStack</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>.</operator><name>lineJustificationStack</name></name> <operator>=</operator> <name>m_lineJustificationStack</name></expr>;</expr_stmt>
            <comment type="line">//state.spriteAnimationStack = m_spriteAnimationStack;</comment>

            <expr_stmt><expr><name><name>state</name><operator>.</operator><name>spriteAnimationID</name></name> <operator>=</operator> <name>m_spriteAnimationID</name></expr>;</expr_stmt>

            <if>if <condition>(<expr><name>m_lineNumber</name> <operator>&lt;</operator> <name><name>m_textInfo</name><operator>.</operator><name>lineInfo</name><operator>.</operator><name>Length</name></name></expr>)</condition><then>
                <block type="pseudo"><expr_stmt><expr><name><name>state</name><operator>.</operator><name>lineInfo</name></name> <operator>=</operator> <name><name>m_textInfo</name><operator>.</operator><name>lineInfo</name><index>[<expr><name>m_lineNumber</name></expr>]</index></name></expr>;</expr_stmt></block></then></if>
        }</block></function>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Restore the State of various variables used in the mesh creation loop.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;param name="state"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;returns&gt;&lt;/returns&gt;</comment>
        <function><specifier>protected</specifier> <type><name>int</name></type> <name>RestoreWordWrappingState</name><parameter_list>(<parameter><decl><type><modifier>ref</modifier> <name>WordWrapState</name></type> <name>state</name></decl></parameter>)</parameter_list>
        <block>{
            <decl_stmt><decl><type><name>int</name></type> <name>index</name> <init>= <expr><name><name>state</name><operator>.</operator><name>previous_WordBreak</name></name></expr></init></decl>;</decl_stmt>

            <comment type="line">// Multi Font &amp; Material support related</comment>
            <expr_stmt><expr><name>m_currentFontAsset</name> <operator>=</operator> <name><name>state</name><operator>.</operator><name>currentFontAsset</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>m_currentSpriteAsset</name> <operator>=</operator> <name><name>state</name><operator>.</operator><name>currentSpriteAsset</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>m_currentMaterial</name> <operator>=</operator> <name><name>state</name><operator>.</operator><name>currentMaterial</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>m_currentMaterialIndex</name> <operator>=</operator> <name><name>state</name><operator>.</operator><name>currentMaterialIndex</name></name></expr>;</expr_stmt>

            <expr_stmt><expr><name>m_characterCount</name> <operator>=</operator> <name><name>state</name><operator>.</operator><name>total_CharacterCount</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>m_lineVisibleCharacterCount</name> <operator>=</operator> <name><name>state</name><operator>.</operator><name>visible_CharacterCount</name></name></expr>;</expr_stmt>
            <comment type="line">//m_visibleCharacterCount = state.visible_CharacterCount;</comment>
            <comment type="line">//m_visibleSpriteCount = state.visible_SpriteCount;</comment>
            <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>linkCount</name></name> <operator>=</operator> <name><name>state</name><operator>.</operator><name>visible_LinkCount</name></name></expr>;</expr_stmt>

            <expr_stmt><expr><name>m_firstCharacterOfLine</name> <operator>=</operator> <name><name>state</name><operator>.</operator><name>firstCharacterIndex</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>m_firstVisibleCharacterOfLine</name> <operator>=</operator> <name><name>state</name><operator>.</operator><name>firstVisibleCharacterIndex</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>m_lastVisibleCharacterOfLine</name> <operator>=</operator> <name><name>state</name><operator>.</operator><name>lastVisibleCharIndex</name></name></expr>;</expr_stmt>

            <expr_stmt><expr><name>m_style</name> <operator>=</operator> <name><name>state</name><operator>.</operator><name>fontStyle</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>m_fontScale</name> <operator>=</operator> <name><name>state</name><operator>.</operator><name>fontScale</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>m_fontScaleMultiplier</name> <operator>=</operator> <name><name>state</name><operator>.</operator><name>fontScaleMultiplier</name></name></expr>;</expr_stmt>
            <comment type="line">//m_maxFontScale = state.maxFontScale;</comment>
            <expr_stmt><expr><name>m_currentFontSize</name> <operator>=</operator> <name><name>state</name><operator>.</operator><name>currentFontSize</name></name></expr>;</expr_stmt>

            <expr_stmt><expr><name>m_xAdvance</name> <operator>=</operator> <name><name>state</name><operator>.</operator><name>xAdvance</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>m_maxCapHeight</name> <operator>=</operator> <name><name>state</name><operator>.</operator><name>maxCapHeight</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>m_maxAscender</name> <operator>=</operator> <name><name>state</name><operator>.</operator><name>maxAscender</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>m_maxDescender</name> <operator>=</operator> <name><name>state</name><operator>.</operator><name>maxDescender</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>m_maxLineAscender</name> <operator>=</operator> <name><name>state</name><operator>.</operator><name>maxLineAscender</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>m_maxLineDescender</name> <operator>=</operator> <name><name>state</name><operator>.</operator><name>maxLineDescender</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>m_startOfLineAscender</name> <operator>=</operator> <name><name>state</name><operator>.</operator><name>previousLineAscender</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>m_preferredWidth</name> <operator>=</operator> <name><name>state</name><operator>.</operator><name>preferredWidth</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>m_preferredHeight</name> <operator>=</operator> <name><name>state</name><operator>.</operator><name>preferredHeight</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>m_meshExtents</name> <operator>=</operator> <name><name>state</name><operator>.</operator><name>meshExtents</name></name></expr>;</expr_stmt>

            <expr_stmt><expr><name>m_lineNumber</name> <operator>=</operator> <name><name>state</name><operator>.</operator><name>lineNumber</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>m_lineOffset</name> <operator>=</operator> <name><name>state</name><operator>.</operator><name>lineOffset</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>m_baselineOffset</name> <operator>=</operator> <name><name>state</name><operator>.</operator><name>baselineOffset</name></name></expr>;</expr_stmt>

            <comment type="line">//m_lineJustification = state.alignment;</comment>
            <expr_stmt><expr><name>m_htmlColor</name> <operator>=</operator> <name><name>state</name><operator>.</operator><name>vertexColor</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>m_underlineColor</name> <operator>=</operator> <name><name>state</name><operator>.</operator><name>underlineColor</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>m_strikethroughColor</name> <operator>=</operator> <name><name>state</name><operator>.</operator><name>strikethroughColor</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>m_highlightColor</name> <operator>=</operator> <name><name>state</name><operator>.</operator><name>highlightColor</name></name></expr>;</expr_stmt>

            <expr_stmt><expr><name>m_isNonBreakingSpace</name> <operator>=</operator> <name><name>state</name><operator>.</operator><name>isNonBreakingSpace</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>tag_NoParsing</name> <operator>=</operator> <name><name>state</name><operator>.</operator><name>tagNoParsing</name></name></expr>;</expr_stmt>

            <comment type="line">// XML Tag Stack</comment>
            <expr_stmt><expr><name>m_fontStyleStack</name> <operator>=</operator> <name><name>state</name><operator>.</operator><name>basicStyleStack</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>m_colorStack</name> <operator>=</operator> <name><name>state</name><operator>.</operator><name>colorStack</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>m_underlineColorStack</name> <operator>=</operator> <name><name>state</name><operator>.</operator><name>underlineColorStack</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>m_strikethroughColorStack</name> <operator>=</operator> <name><name>state</name><operator>.</operator><name>strikethroughColorStack</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>m_highlightColorStack</name> <operator>=</operator> <name><name>state</name><operator>.</operator><name>highlightColorStack</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>m_colorGradientStack</name> <operator>=</operator> <name><name>state</name><operator>.</operator><name>colorGradientStack</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>m_sizeStack</name> <operator>=</operator> <name><name>state</name><operator>.</operator><name>sizeStack</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>m_indentStack</name> <operator>=</operator> <name><name>state</name><operator>.</operator><name>indentStack</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>m_fontWeightStack</name> <operator>=</operator> <name><name>state</name><operator>.</operator><name>fontWeightStack</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>m_styleStack</name> <operator>=</operator> <name><name>state</name><operator>.</operator><name>styleStack</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>m_baselineOffsetStack</name> <operator>=</operator> <name><name>state</name><operator>.</operator><name>baselineStack</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>m_actionStack</name> <operator>=</operator> <name><name>state</name><operator>.</operator><name>actionStack</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>m_materialReferenceStack</name> <operator>=</operator> <name><name>state</name><operator>.</operator><name>materialReferenceStack</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>m_lineJustificationStack</name> <operator>=</operator> <name><name>state</name><operator>.</operator><name>lineJustificationStack</name></name></expr>;</expr_stmt>
            <comment type="line">//m_spriteAnimationStack = state.spriteAnimationStack;</comment>

            <expr_stmt><expr><name>m_spriteAnimationID</name> <operator>=</operator> <name><name>state</name><operator>.</operator><name>spriteAnimationID</name></name></expr>;</expr_stmt>

            <if>if <condition>(<expr><name>m_lineNumber</name> <operator>&lt;</operator> <name><name>m_textInfo</name><operator>.</operator><name>lineInfo</name><operator>.</operator><name>Length</name></name></expr>)</condition><then>
                <block type="pseudo"><expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>lineInfo</name><index>[<expr><name>m_lineNumber</name></expr>]</index></name> <operator>=</operator> <name><name>state</name><operator>.</operator><name>lineInfo</name></name></expr>;</expr_stmt></block></then></if>

            <return>return <expr><name>index</name></expr>;</return>
        }</block></function>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Store vertex information for each character.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;param name="style_padding"&gt;Style_padding.&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="vertexColor"&gt;Vertex color.&lt;/param&gt;</comment>
        <function><specifier>protected</specifier> <specifier>virtual</specifier> <type><name>void</name></type> <name>SaveGlyphVertexInfo</name><parameter_list>(<parameter><decl><type><name>float</name></type> <name>padding</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>style_padding</name></decl></parameter>, <parameter><decl><type><name>Color32</name></type> <name>vertexColor</name></decl></parameter>)</parameter_list>
        <block>{
            <comment type="line">// Save the Vertex Position for the Character</comment>
            <cpp:region>#<cpp:directive>region</cpp:directive> <name>Setup</name> <name>Mesh</name> <name>Vertices</name></cpp:region>
            <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>characterInfo</name><index>[<expr><name>m_characterCount</name></expr>]</index></name><operator>.</operator><name><name>vertex_BL</name><operator>.</operator><name>position</name></name> <operator>=</operator> <name><name>m_textInfo</name><operator>.</operator><name>characterInfo</name><index>[<expr><name>m_characterCount</name></expr>]</index></name><operator>.</operator><name>bottomLeft</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>characterInfo</name><index>[<expr><name>m_characterCount</name></expr>]</index></name><operator>.</operator><name><name>vertex_TL</name><operator>.</operator><name>position</name></name> <operator>=</operator> <name><name>m_textInfo</name><operator>.</operator><name>characterInfo</name><index>[<expr><name>m_characterCount</name></expr>]</index></name><operator>.</operator><name>topLeft</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>characterInfo</name><index>[<expr><name>m_characterCount</name></expr>]</index></name><operator>.</operator><name><name>vertex_TR</name><operator>.</operator><name>position</name></name> <operator>=</operator> <name><name>m_textInfo</name><operator>.</operator><name>characterInfo</name><index>[<expr><name>m_characterCount</name></expr>]</index></name><operator>.</operator><name>topRight</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>characterInfo</name><index>[<expr><name>m_characterCount</name></expr>]</index></name><operator>.</operator><name><name>vertex_BR</name><operator>.</operator><name>position</name></name> <operator>=</operator> <name><name>m_textInfo</name><operator>.</operator><name>characterInfo</name><index>[<expr><name>m_characterCount</name></expr>]</index></name><operator>.</operator><name>bottomRight</name></expr>;</expr_stmt>
            <cpp:endregion>#<cpp:directive>endregion</cpp:directive></cpp:endregion>


            <cpp:region>#<cpp:directive>region</cpp:directive> <name>Setup</name> <name>Vertex</name> <name>Colors</name></cpp:region>
            <comment type="line">// Alpha is the lower of the vertex color or tag color alpha used.</comment>
            <expr_stmt><expr><name><name>vertexColor</name><operator>.</operator><name>a</name></name> <operator>=</operator> <ternary><condition><expr><name><name>m_fontColor32</name><operator>.</operator><name>a</name></name> <operator>&lt;</operator> <name><name>vertexColor</name><operator>.</operator><name>a</name></name></expr> ?</condition><then> <expr><call>(<name>byte</name>)<argument_list>(<argument><expr><name><name>m_fontColor32</name><operator>.</operator><name>a</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call>(<name>byte</name>)<argument_list>(<argument><expr><name><name>vertexColor</name><operator>.</operator><name>a</name></name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

            <comment type="line">// Handle Vertex Colors &amp; Vertex Color Gradient</comment>
            <if>if <condition>(<expr><operator>!</operator><name>m_enableVertexGradient</name></expr>)</condition><then>
            <block>{
                <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>characterInfo</name><index>[<expr><name>m_characterCount</name></expr>]</index></name><operator>.</operator><name><name>vertex_BL</name><operator>.</operator><name>color</name></name> <operator>=</operator> <name>vertexColor</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>characterInfo</name><index>[<expr><name>m_characterCount</name></expr>]</index></name><operator>.</operator><name><name>vertex_TL</name><operator>.</operator><name>color</name></name> <operator>=</operator> <name>vertexColor</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>characterInfo</name><index>[<expr><name>m_characterCount</name></expr>]</index></name><operator>.</operator><name><name>vertex_TR</name><operator>.</operator><name>color</name></name> <operator>=</operator> <name>vertexColor</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>characterInfo</name><index>[<expr><name>m_characterCount</name></expr>]</index></name><operator>.</operator><name><name>vertex_BR</name><operator>.</operator><name>color</name></name> <operator>=</operator> <name>vertexColor</name></expr>;</expr_stmt>
            }</block></then>
            <else>else
            <block>{
                <if>if <condition>(<expr><operator>!</operator><name>m_overrideHtmlColors</name> <operator>&amp;&amp;</operator> <name><name>m_colorStack</name><operator>.</operator><name>index</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><then>
                <block>{
                    <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>characterInfo</name><index>[<expr><name>m_characterCount</name></expr>]</index></name><operator>.</operator><name><name>vertex_BL</name><operator>.</operator><name>color</name></name> <operator>=</operator> <name>vertexColor</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>characterInfo</name><index>[<expr><name>m_characterCount</name></expr>]</index></name><operator>.</operator><name><name>vertex_TL</name><operator>.</operator><name>color</name></name> <operator>=</operator> <name>vertexColor</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>characterInfo</name><index>[<expr><name>m_characterCount</name></expr>]</index></name><operator>.</operator><name><name>vertex_TR</name><operator>.</operator><name>color</name></name> <operator>=</operator> <name>vertexColor</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>characterInfo</name><index>[<expr><name>m_characterCount</name></expr>]</index></name><operator>.</operator><name><name>vertex_BR</name><operator>.</operator><name>color</name></name> <operator>=</operator> <name>vertexColor</name></expr>;</expr_stmt>
                }</block></then>
                <else>else <comment type="line">// Handle Vertex Color Gradient</comment>
                <block>{
                    <comment type="line">// Use Vertex Color Gradient Preset (if one is assigned)</comment>
                    <if>if <condition>(<expr><name>m_fontColorGradientPreset</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><then>
                    <block>{
                        <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>characterInfo</name><index>[<expr><name>m_characterCount</name></expr>]</index></name><operator>.</operator><name><name>vertex_BL</name><operator>.</operator><name>color</name></name> <operator>=</operator> <name><name>m_fontColorGradientPreset</name><operator>.</operator><name>bottomLeft</name></name> <operator>*</operator> <name>vertexColor</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>characterInfo</name><index>[<expr><name>m_characterCount</name></expr>]</index></name><operator>.</operator><name><name>vertex_TL</name><operator>.</operator><name>color</name></name> <operator>=</operator> <name><name>m_fontColorGradientPreset</name><operator>.</operator><name>topLeft</name></name> <operator>*</operator> <name>vertexColor</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>characterInfo</name><index>[<expr><name>m_characterCount</name></expr>]</index></name><operator>.</operator><name><name>vertex_TR</name><operator>.</operator><name>color</name></name> <operator>=</operator> <name><name>m_fontColorGradientPreset</name><operator>.</operator><name>topRight</name></name> <operator>*</operator> <name>vertexColor</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>characterInfo</name><index>[<expr><name>m_characterCount</name></expr>]</index></name><operator>.</operator><name><name>vertex_BR</name><operator>.</operator><name>color</name></name> <operator>=</operator> <name><name>m_fontColorGradientPreset</name><operator>.</operator><name>bottomRight</name></name> <operator>*</operator> <name>vertexColor</name></expr>;</expr_stmt>
                    }</block></then>
                    <else>else
                    <block>{
                        <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>characterInfo</name><index>[<expr><name>m_characterCount</name></expr>]</index></name><operator>.</operator><name><name>vertex_BL</name><operator>.</operator><name>color</name></name> <operator>=</operator> <name><name>m_fontColorGradient</name><operator>.</operator><name>bottomLeft</name></name> <operator>*</operator> <name>vertexColor</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>characterInfo</name><index>[<expr><name>m_characterCount</name></expr>]</index></name><operator>.</operator><name><name>vertex_TL</name><operator>.</operator><name>color</name></name> <operator>=</operator> <name><name>m_fontColorGradient</name><operator>.</operator><name>topLeft</name></name> <operator>*</operator> <name>vertexColor</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>characterInfo</name><index>[<expr><name>m_characterCount</name></expr>]</index></name><operator>.</operator><name><name>vertex_TR</name><operator>.</operator><name>color</name></name> <operator>=</operator> <name><name>m_fontColorGradient</name><operator>.</operator><name>topRight</name></name> <operator>*</operator> <name>vertexColor</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>characterInfo</name><index>[<expr><name>m_characterCount</name></expr>]</index></name><operator>.</operator><name><name>vertex_BR</name><operator>.</operator><name>color</name></name> <operator>=</operator> <name><name>m_fontColorGradient</name><operator>.</operator><name>bottomRight</name></name> <operator>*</operator> <name>vertexColor</name></expr>;</expr_stmt>
                    }</block></else></if>
                }</block></else></if>
            }</block></else></if>

            <if>if <condition>(<expr><name>m_colorGradientPreset</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><then>
            <block>{
                <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>characterInfo</name><index>[<expr><name>m_characterCount</name></expr>]</index></name><operator>.</operator><name><name>vertex_BL</name><operator>.</operator><name>color</name></name> <operator>*=</operator> <name><name>m_colorGradientPreset</name><operator>.</operator><name>bottomLeft</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>characterInfo</name><index>[<expr><name>m_characterCount</name></expr>]</index></name><operator>.</operator><name><name>vertex_TL</name><operator>.</operator><name>color</name></name> <operator>*=</operator> <name><name>m_colorGradientPreset</name><operator>.</operator><name>topLeft</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>characterInfo</name><index>[<expr><name>m_characterCount</name></expr>]</index></name><operator>.</operator><name><name>vertex_TR</name><operator>.</operator><name>color</name></name> <operator>*=</operator> <name><name>m_colorGradientPreset</name><operator>.</operator><name>topRight</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>characterInfo</name><index>[<expr><name>m_characterCount</name></expr>]</index></name><operator>.</operator><name><name>vertex_BR</name><operator>.</operator><name>color</name></name> <operator>*=</operator> <name><name>m_colorGradientPreset</name><operator>.</operator><name>bottomRight</name></name></expr>;</expr_stmt>
            }</block></then></if>
            <cpp:endregion>#<cpp:directive>endregion</cpp:directive></cpp:endregion>

            <comment type="line">// Apply style_padding only if this is a SDF Shader.</comment>
            <if>if <condition>(<expr><operator>!</operator><name>m_isSDFShader</name></expr>)</condition><then>
                <block type="pseudo"><expr_stmt><expr><name>style_padding</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block></then></if>


            <comment type="line">// Setup UVs for the Character</comment>
            <cpp:region>#<cpp:directive>region</cpp:directive> <name>Setup</name> <name>UVs</name></cpp:region>
            <decl_stmt><decl><type><name>FaceInfo</name></type> <name>faceInfo</name> <init>= <expr><name><name>m_currentFontAsset</name><operator>.</operator><name>fontInfo</name></name></expr></init></decl>;</decl_stmt>

            <decl_stmt><decl><type><name>Vector2</name></type> <name>uv0</name></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>uv0</name><operator>.</operator><name>x</name></name> <operator>=</operator> <operator>(</operator><name><name>m_cached_TextElement</name><operator>.</operator><name>x</name></name> <operator>-</operator> <name>padding</name> <operator>-</operator> <name>style_padding</name><operator>)</operator> <operator>/</operator> <name><name>faceInfo</name><operator>.</operator><name>AtlasWidth</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>uv0</name><operator>.</operator><name>y</name></name> <operator>=</operator> <literal type="number">1</literal> <operator>-</operator> <operator>(</operator><name><name>m_cached_TextElement</name><operator>.</operator><name>y</name></name> <operator>+</operator> <name>padding</name> <operator>+</operator> <name>style_padding</name> <operator>+</operator> <name><name>m_cached_TextElement</name><operator>.</operator><name>height</name></name><operator>)</operator> <operator>/</operator> <name><name>faceInfo</name><operator>.</operator><name>AtlasHeight</name></name></expr>;</expr_stmt>

            <decl_stmt><decl><type><name>Vector2</name></type> <name>uv1</name></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>uv1</name><operator>.</operator><name>x</name></name> <operator>=</operator> <name><name>uv0</name><operator>.</operator><name>x</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>uv1</name><operator>.</operator><name>y</name></name> <operator>=</operator> <literal type="number">1</literal> <operator>-</operator> <operator>(</operator><name><name>m_cached_TextElement</name><operator>.</operator><name>y</name></name> <operator>-</operator> <name>padding</name> <operator>-</operator> <name>style_padding</name><operator>)</operator> <operator>/</operator> <name><name>faceInfo</name><operator>.</operator><name>AtlasHeight</name></name></expr>;</expr_stmt>

            <decl_stmt><decl><type><name>Vector2</name></type> <name>uv2</name></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>uv2</name><operator>.</operator><name>x</name></name> <operator>=</operator> <operator>(</operator><name><name>m_cached_TextElement</name><operator>.</operator><name>x</name></name> <operator>+</operator> <name>padding</name> <operator>+</operator> <name>style_padding</name> <operator>+</operator> <name><name>m_cached_TextElement</name><operator>.</operator><name>width</name></name><operator>)</operator> <operator>/</operator> <name><name>faceInfo</name><operator>.</operator><name>AtlasWidth</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>uv2</name><operator>.</operator><name>y</name></name> <operator>=</operator> <name><name>uv1</name><operator>.</operator><name>y</name></name></expr>;</expr_stmt>

            <decl_stmt><decl><type><name>Vector2</name></type> <name>uv3</name></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>uv3</name><operator>.</operator><name>x</name></name> <operator>=</operator> <name><name>uv2</name><operator>.</operator><name>x</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>uv3</name><operator>.</operator><name>y</name></name> <operator>=</operator> <name><name>uv0</name><operator>.</operator><name>y</name></name></expr>;</expr_stmt>

            <comment type="line">//Vector2 uv0 = new Vector2((m_cached_TextElement.x - padding - style_padding) / faceInfo.AtlasWidth, 1 - (m_cached_TextElement.y + padding + style_padding + m_cached_TextElement.height) / faceInfo.AtlasHeight);  // bottom left</comment>
            <comment type="line">//Vector2 uv1 = new Vector2(uv0.x, 1 - (m_cached_TextElement.y - padding - style_padding) / faceInfo.AtlasHeight);  // top left</comment>
            <comment type="line">//Vector2 uv2 = new Vector2((m_cached_TextElement.x + padding + style_padding + m_cached_TextElement.width) / faceInfo.AtlasWidth, uv1.y); // top right</comment>
            <comment type="line">//Vector2 uv3 = new Vector2(uv2.x, uv0.y); // bottom right</comment>

            <comment type="line">// Store UV Information</comment>
            <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>characterInfo</name><index>[<expr><name>m_characterCount</name></expr>]</index></name><operator>.</operator><name><name>vertex_BL</name><operator>.</operator><name>uv</name></name> <operator>=</operator> <name>uv0</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>characterInfo</name><index>[<expr><name>m_characterCount</name></expr>]</index></name><operator>.</operator><name><name>vertex_TL</name><operator>.</operator><name>uv</name></name> <operator>=</operator> <name>uv1</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>characterInfo</name><index>[<expr><name>m_characterCount</name></expr>]</index></name><operator>.</operator><name><name>vertex_TR</name><operator>.</operator><name>uv</name></name> <operator>=</operator> <name>uv2</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>characterInfo</name><index>[<expr><name>m_characterCount</name></expr>]</index></name><operator>.</operator><name><name>vertex_BR</name><operator>.</operator><name>uv</name></name> <operator>=</operator> <name>uv3</name></expr>;</expr_stmt>
            <cpp:endregion>#<cpp:directive>endregion</cpp:directive> Setup UVs</cpp:endregion>


            <comment type="line">// Normal</comment>
            <cpp:region>#<cpp:directive>region</cpp:directive> <name>Setup</name> <name>Normals</name> <name>&amp;</name> <name>Tangents</name></cpp:region>
            <comment type="line">//Vector3 normal = new Vector3(0, 0, -1);</comment>
            <comment type="line">//m_textInfo.characterInfo[m_characterCount].vertex_BL.normal = normal;</comment>
            <comment type="line">//m_textInfo.characterInfo[m_characterCount].vertex_TL.normal = normal;</comment>
            <comment type="line">//m_textInfo.characterInfo[m_characterCount].vertex_TR.normal = normal;</comment>
            <comment type="line">//m_textInfo.characterInfo[m_characterCount].vertex_BR.normal = normal;</comment>

            <comment type="line">// Tangents</comment>
            <comment type="line">//Vector4 tangent = new Vector4(-1, 0, 0, 1);</comment>
            <comment type="line">//m_textInfo.characterInfo[m_characterCount].vertex_BL.tangent = tangent;</comment>
            <comment type="line">//m_textInfo.characterInfo[m_characterCount].vertex_TL.tangent = tangent;</comment>
            <comment type="line">//m_textInfo.characterInfo[m_characterCount].vertex_TR.tangent = tangent;</comment>
            <comment type="line">//m_textInfo.characterInfo[m_characterCount].vertex_BR.tangent = tangent;</comment>
            <cpp:endregion>#<cpp:directive>endregion</cpp:directive> end Normals &amp; Tangents</cpp:endregion>
        }</block></function>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Store vertex information for each sprite.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;param name="padding"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="style_padding"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="vertexColor"&gt;&lt;/param&gt;</comment>
        <function><specifier>protected</specifier> <specifier>virtual</specifier> <type><name>void</name></type> <name>SaveSpriteVertexInfo</name><parameter_list>(<parameter><decl><type><name>Color32</name></type> <name>vertexColor</name></decl></parameter>)</parameter_list>
        <block>{
            <comment type="line">// Save the Vertex Position for the Character</comment>
            <cpp:region>#<cpp:directive>region</cpp:directive> <name>Setup</name> <name>Mesh</name> <name>Vertices</name></cpp:region>
            <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>characterInfo</name><index>[<expr><name>m_characterCount</name></expr>]</index></name><operator>.</operator><name><name>vertex_BL</name><operator>.</operator><name>position</name></name> <operator>=</operator> <name><name>m_textInfo</name><operator>.</operator><name>characterInfo</name><index>[<expr><name>m_characterCount</name></expr>]</index></name><operator>.</operator><name>bottomLeft</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>characterInfo</name><index>[<expr><name>m_characterCount</name></expr>]</index></name><operator>.</operator><name><name>vertex_TL</name><operator>.</operator><name>position</name></name> <operator>=</operator> <name><name>m_textInfo</name><operator>.</operator><name>characterInfo</name><index>[<expr><name>m_characterCount</name></expr>]</index></name><operator>.</operator><name>topLeft</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>characterInfo</name><index>[<expr><name>m_characterCount</name></expr>]</index></name><operator>.</operator><name><name>vertex_TR</name><operator>.</operator><name>position</name></name> <operator>=</operator> <name><name>m_textInfo</name><operator>.</operator><name>characterInfo</name><index>[<expr><name>m_characterCount</name></expr>]</index></name><operator>.</operator><name>topRight</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>characterInfo</name><index>[<expr><name>m_characterCount</name></expr>]</index></name><operator>.</operator><name><name>vertex_BR</name><operator>.</operator><name>position</name></name> <operator>=</operator> <name><name>m_textInfo</name><operator>.</operator><name>characterInfo</name><index>[<expr><name>m_characterCount</name></expr>]</index></name><operator>.</operator><name>bottomRight</name></expr>;</expr_stmt>
            <cpp:endregion>#<cpp:directive>endregion</cpp:directive></cpp:endregion>

            <comment type="line">// Vertex Color Alpha</comment>
            <if>if <condition>(<expr><name>m_tintAllSprites</name></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><name>m_tintSprite</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt></block></then></if>
            <decl_stmt><decl><type><name>Color32</name></type> <name>spriteColor</name> <init>= <expr><ternary><condition><expr><name>m_tintSprite</name></expr> ?</condition><then> <expr><call><name><name>m_spriteColor</name><operator>.</operator><name>Multiply</name></name><argument_list>(<argument><expr><name>vertexColor</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>m_spriteColor</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>spriteColor</name><operator>.</operator><name>a</name></name> <operator>=</operator> <ternary><condition><expr><name><name>spriteColor</name><operator>.</operator><name>a</name></name> <operator>&lt;</operator> <name><name>m_fontColor32</name><operator>.</operator><name>a</name></name></expr> ?</condition><then> <expr><name><name>spriteColor</name><operator>.</operator><name>a</name></name> <operator>=</operator> <ternary><condition><expr><name><name>spriteColor</name><operator>.</operator><name>a</name></name> <operator>&lt;</operator> <name><name>vertexColor</name><operator>.</operator><name>a</name></name></expr> ?</condition><then> <expr><name><name>spriteColor</name><operator>.</operator><name>a</name></name></expr> </then><else>: <expr><name><name>vertexColor</name><operator>.</operator><name>a</name></name></expr></else></ternary></expr> </then><else>: <expr><name><name>m_fontColor32</name><operator>.</operator><name>a</name></name></expr></else></ternary></expr>;</expr_stmt>

            <decl_stmt><decl><type><name>Color32</name></type> <name>c0</name> <init>= <expr><name>spriteColor</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Color32</name></type> <name>c1</name> <init>= <expr><name>spriteColor</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Color32</name></type> <name>c2</name> <init>= <expr><name>spriteColor</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Color32</name></type> <name>c3</name> <init>= <expr><name>spriteColor</name></expr></init></decl>;</decl_stmt>

            <if>if <condition>(<expr><name>m_enableVertexGradient</name></expr>)</condition><then>
            <block>{
                <if>if <condition>(<expr><name>m_fontColorGradientPreset</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><then>
                <block>{
                    <expr_stmt><expr><name>c0</name> <operator>=</operator> <ternary><condition><expr><name>m_tintSprite</name></expr> ?</condition><then> <expr><call><name><name>c0</name><operator>.</operator><name>Multiply</name></name><argument_list>(<argument><expr><name><name>m_fontColorGradientPreset</name><operator>.</operator><name>bottomLeft</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>c0</name></expr></else></ternary></expr>;</expr_stmt>
                    <expr_stmt><expr><name>c1</name> <operator>=</operator> <ternary><condition><expr><name>m_tintSprite</name></expr> ?</condition><then> <expr><call><name><name>c1</name><operator>.</operator><name>Multiply</name></name><argument_list>(<argument><expr><name><name>m_fontColorGradientPreset</name><operator>.</operator><name>topLeft</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>c1</name></expr></else></ternary></expr>;</expr_stmt>
                    <expr_stmt><expr><name>c2</name> <operator>=</operator> <ternary><condition><expr><name>m_tintSprite</name></expr> ?</condition><then> <expr><call><name><name>c2</name><operator>.</operator><name>Multiply</name></name><argument_list>(<argument><expr><name><name>m_fontColorGradientPreset</name><operator>.</operator><name>topRight</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>c2</name></expr></else></ternary></expr>;</expr_stmt>
                    <expr_stmt><expr><name>c3</name> <operator>=</operator> <ternary><condition><expr><name>m_tintSprite</name></expr> ?</condition><then> <expr><call><name><name>c3</name><operator>.</operator><name>Multiply</name></name><argument_list>(<argument><expr><name><name>m_fontColorGradientPreset</name><operator>.</operator><name>bottomRight</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>c3</name></expr></else></ternary></expr>;</expr_stmt>
                }</block></then>
                <else>else
                <block>{
                    <expr_stmt><expr><name>c0</name> <operator>=</operator> <ternary><condition><expr><name>m_tintSprite</name></expr> ?</condition><then> <expr><call><name><name>c0</name><operator>.</operator><name>Multiply</name></name><argument_list>(<argument><expr><name><name>m_fontColorGradient</name><operator>.</operator><name>bottomLeft</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>c0</name></expr></else></ternary></expr>;</expr_stmt>
                    <expr_stmt><expr><name>c1</name> <operator>=</operator> <ternary><condition><expr><name>m_tintSprite</name></expr> ?</condition><then> <expr><call><name><name>c1</name><operator>.</operator><name>Multiply</name></name><argument_list>(<argument><expr><name><name>m_fontColorGradient</name><operator>.</operator><name>topLeft</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>c1</name></expr></else></ternary></expr>;</expr_stmt>
                    <expr_stmt><expr><name>c2</name> <operator>=</operator> <ternary><condition><expr><name>m_tintSprite</name></expr> ?</condition><then> <expr><call><name><name>c2</name><operator>.</operator><name>Multiply</name></name><argument_list>(<argument><expr><name><name>m_fontColorGradient</name><operator>.</operator><name>topRight</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>c2</name></expr></else></ternary></expr>;</expr_stmt>
                    <expr_stmt><expr><name>c3</name> <operator>=</operator> <ternary><condition><expr><name>m_tintSprite</name></expr> ?</condition><then> <expr><call><name><name>c3</name><operator>.</operator><name>Multiply</name></name><argument_list>(<argument><expr><name><name>m_fontColorGradient</name><operator>.</operator><name>bottomRight</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>c3</name></expr></else></ternary></expr>;</expr_stmt>
                }</block></else></if>
            }</block></then></if>

            <if>if <condition>(<expr><name>m_colorGradientPreset</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><then>
            <block>{
                <expr_stmt><expr><name>c0</name> <operator>=</operator> <ternary><condition><expr><name>m_tintSprite</name></expr> ?</condition><then> <expr><call><name><name>c0</name><operator>.</operator><name>Multiply</name></name><argument_list>(<argument><expr><name><name>m_colorGradientPreset</name><operator>.</operator><name>bottomLeft</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>c0</name></expr></else></ternary></expr>;</expr_stmt>
                <expr_stmt><expr><name>c1</name> <operator>=</operator> <ternary><condition><expr><name>m_tintSprite</name></expr> ?</condition><then> <expr><call><name><name>c1</name><operator>.</operator><name>Multiply</name></name><argument_list>(<argument><expr><name><name>m_colorGradientPreset</name><operator>.</operator><name>topLeft</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>c1</name></expr></else></ternary></expr>;</expr_stmt>
                <expr_stmt><expr><name>c2</name> <operator>=</operator> <ternary><condition><expr><name>m_tintSprite</name></expr> ?</condition><then> <expr><call><name><name>c2</name><operator>.</operator><name>Multiply</name></name><argument_list>(<argument><expr><name><name>m_colorGradientPreset</name><operator>.</operator><name>topRight</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>c2</name></expr></else></ternary></expr>;</expr_stmt>
                <expr_stmt><expr><name>c3</name> <operator>=</operator> <ternary><condition><expr><name>m_tintSprite</name></expr> ?</condition><then> <expr><call><name><name>c3</name><operator>.</operator><name>Multiply</name></name><argument_list>(<argument><expr><name><name>m_colorGradientPreset</name><operator>.</operator><name>bottomRight</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>c3</name></expr></else></ternary></expr>;</expr_stmt>
            }</block></then></if>

            <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>characterInfo</name><index>[<expr><name>m_characterCount</name></expr>]</index></name><operator>.</operator><name><name>vertex_BL</name><operator>.</operator><name>color</name></name> <operator>=</operator> <name>c0</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>characterInfo</name><index>[<expr><name>m_characterCount</name></expr>]</index></name><operator>.</operator><name><name>vertex_TL</name><operator>.</operator><name>color</name></name> <operator>=</operator> <name>c1</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>characterInfo</name><index>[<expr><name>m_characterCount</name></expr>]</index></name><operator>.</operator><name><name>vertex_TR</name><operator>.</operator><name>color</name></name> <operator>=</operator> <name>c2</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>characterInfo</name><index>[<expr><name>m_characterCount</name></expr>]</index></name><operator>.</operator><name><name>vertex_BR</name><operator>.</operator><name>color</name></name> <operator>=</operator> <name>c3</name></expr>;</expr_stmt>


            <comment type="line">// Setup UVs for the Character</comment>
            <cpp:region>#<cpp:directive>region</cpp:directive> <name>Setup</name> <name>UVs</name></cpp:region>
            <decl_stmt><decl><type><name>Vector2</name></type> <name>uv0</name> <init>= <expr><operator>new</operator> <call><name>Vector2</name><argument_list>(<argument><expr><name><name>m_cached_TextElement</name><operator>.</operator><name>x</name></name> <operator>/</operator> <name><name>m_currentSpriteAsset</name><operator>.</operator><name>spriteSheet</name><operator>.</operator><name>width</name></name></expr></argument>, <argument><expr><name><name>m_cached_TextElement</name><operator>.</operator><name>y</name></name> <operator>/</operator> <name><name>m_currentSpriteAsset</name><operator>.</operator><name>spriteSheet</name><operator>.</operator><name>height</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>  <comment type="line">// bottom left</comment>
            <decl_stmt><decl><type><name>Vector2</name></type> <name>uv1</name> <init>= <expr><operator>new</operator> <call><name>Vector2</name><argument_list>(<argument><expr><name><name>uv0</name><operator>.</operator><name>x</name></name></expr></argument>, <argument><expr><operator>(</operator><name><name>m_cached_TextElement</name><operator>.</operator><name>y</name></name> <operator>+</operator> <name><name>m_cached_TextElement</name><operator>.</operator><name>height</name></name><operator>)</operator> <operator>/</operator> <name><name>m_currentSpriteAsset</name><operator>.</operator><name>spriteSheet</name><operator>.</operator><name>height</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>  <comment type="line">// top left</comment>
            <decl_stmt><decl><type><name>Vector2</name></type> <name>uv2</name> <init>= <expr><operator>new</operator> <call><name>Vector2</name><argument_list>(<argument><expr><operator>(</operator><name><name>m_cached_TextElement</name><operator>.</operator><name>x</name></name> <operator>+</operator> <name><name>m_cached_TextElement</name><operator>.</operator><name>width</name></name><operator>)</operator> <operator>/</operator> <name><name>m_currentSpriteAsset</name><operator>.</operator><name>spriteSheet</name><operator>.</operator><name>width</name></name></expr></argument>, <argument><expr><name><name>uv1</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="line">// top right</comment>
            <decl_stmt><decl><type><name>Vector2</name></type> <name>uv3</name> <init>= <expr><operator>new</operator> <call><name>Vector2</name><argument_list>(<argument><expr><name><name>uv2</name><operator>.</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>uv0</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="line">// bottom right</comment>

            <comment type="line">// Store UV Information</comment>
            <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>characterInfo</name><index>[<expr><name>m_characterCount</name></expr>]</index></name><operator>.</operator><name><name>vertex_BL</name><operator>.</operator><name>uv</name></name> <operator>=</operator> <name>uv0</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>characterInfo</name><index>[<expr><name>m_characterCount</name></expr>]</index></name><operator>.</operator><name><name>vertex_TL</name><operator>.</operator><name>uv</name></name> <operator>=</operator> <name>uv1</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>characterInfo</name><index>[<expr><name>m_characterCount</name></expr>]</index></name><operator>.</operator><name><name>vertex_TR</name><operator>.</operator><name>uv</name></name> <operator>=</operator> <name>uv2</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>characterInfo</name><index>[<expr><name>m_characterCount</name></expr>]</index></name><operator>.</operator><name><name>vertex_BR</name><operator>.</operator><name>uv</name></name> <operator>=</operator> <name>uv3</name></expr>;</expr_stmt>
            <cpp:endregion>#<cpp:directive>endregion</cpp:directive> Setup UVs</cpp:endregion>


            <comment type="line">// Normal</comment>
            <cpp:region>#<cpp:directive>region</cpp:directive> <name>Setup</name> <name>Normals</name> <name>&amp;</name> <name>Tangents</name></cpp:region>
            <comment type="line">//Vector3 normal = new Vector3(0, 0, -1);</comment>
            <comment type="line">//m_textInfo.characterInfo[m_characterCount].vertex_BL.normal = normal;</comment>
            <comment type="line">//m_textInfo.characterInfo[m_characterCount].vertex_TL.normal = normal;</comment>
            <comment type="line">//m_textInfo.characterInfo[m_characterCount].vertex_TR.normal = normal;</comment>
            <comment type="line">//m_textInfo.characterInfo[m_characterCount].vertex_BR.normal = normal;</comment>

            <comment type="line">// Tangents</comment>
            <comment type="line">//Vector4 tangent = new Vector4(-1, 0, 0, 1);</comment>
            <comment type="line">//m_textInfo.characterInfo[m_characterCount].vertex_BL.tangent = tangent;</comment>
            <comment type="line">//m_textInfo.characterInfo[m_characterCount].vertex_TL.tangent = tangent;</comment>
            <comment type="line">//m_textInfo.characterInfo[m_characterCount].vertex_TR.tangent = tangent;</comment>
            <comment type="line">//m_textInfo.characterInfo[m_characterCount].vertex_BR.tangent = tangent;</comment>
            <cpp:endregion>#<cpp:directive>endregion</cpp:directive> end Normals &amp; Tangents</cpp:endregion>

        }</block></function>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Store vertex attributes into the appropriate TMP_MeshInfo.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;param name="i"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="index_X4"&gt;&lt;/param&gt;</comment>
        <function><specifier>protected</specifier> <specifier>virtual</specifier> <type><name>void</name></type> <name>FillCharacterVertexBuffers</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>index_X4</name></decl></parameter>)</parameter_list>
        <block>{
            <decl_stmt><decl><type><name>int</name></type> <name>materialIndex</name> <init>= <expr><name><name>m_textInfo</name><operator>.</operator><name>characterInfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>materialReferenceIndex</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>index_X4</name> <operator>=</operator> <name><name>m_textInfo</name><operator>.</operator><name>meshInfo</name><index>[<expr><name>materialIndex</name></expr>]</index></name><operator>.</operator><name>vertexCount</name></expr>;</expr_stmt>

            <comment type="line">// Make sure buffers allocation are sufficient to hold the vertex data</comment>
            <comment type="line">//if (m_textInfo.meshInfo[materialIndex].vertices.Length &lt; index_X4 + 4)</comment>
            <comment type="line">//    m_textInfo.meshInfo[materialIndex].ResizeMeshInfo(Mathf.NextPowerOfTwo(index_X4 + 4));</comment>


            <decl_stmt><decl><type><name><name>TMP_CharacterInfo</name><index>[]</index></name></type> <name>characterInfoArray</name> <init>= <expr><name><name>m_textInfo</name><operator>.</operator><name>characterInfo</name></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>characterInfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>vertexIndex</name> <operator>=</operator> <name>index_X4</name></expr>;</expr_stmt>

            <comment type="line">// Setup Vertices for Characters</comment>
            <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>meshInfo</name><index>[<expr><name>materialIndex</name></expr>]</index></name><operator>.</operator><name><name>vertices</name><index>[<expr><literal type="number">0</literal> <operator>+</operator> <name>index_X4</name></expr>]</index></name> <operator>=</operator> <name><name>characterInfoArray</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>vertex_BL</name><operator>.</operator><name>position</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>meshInfo</name><index>[<expr><name>materialIndex</name></expr>]</index></name><operator>.</operator><name><name>vertices</name><index>[<expr><literal type="number">1</literal> <operator>+</operator> <name>index_X4</name></expr>]</index></name> <operator>=</operator> <name><name>characterInfoArray</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>vertex_TL</name><operator>.</operator><name>position</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>meshInfo</name><index>[<expr><name>materialIndex</name></expr>]</index></name><operator>.</operator><name><name>vertices</name><index>[<expr><literal type="number">2</literal> <operator>+</operator> <name>index_X4</name></expr>]</index></name> <operator>=</operator> <name><name>characterInfoArray</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>vertex_TR</name><operator>.</operator><name>position</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>meshInfo</name><index>[<expr><name>materialIndex</name></expr>]</index></name><operator>.</operator><name><name>vertices</name><index>[<expr><literal type="number">3</literal> <operator>+</operator> <name>index_X4</name></expr>]</index></name> <operator>=</operator> <name><name>characterInfoArray</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>vertex_BR</name><operator>.</operator><name>position</name></name></expr>;</expr_stmt>


            <comment type="line">// Setup UVS0</comment>
            <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>meshInfo</name><index>[<expr><name>materialIndex</name></expr>]</index></name><operator>.</operator><name><name>uvs0</name><index>[<expr><literal type="number">0</literal> <operator>+</operator> <name>index_X4</name></expr>]</index></name> <operator>=</operator> <name><name>characterInfoArray</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>vertex_BL</name><operator>.</operator><name>uv</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>meshInfo</name><index>[<expr><name>materialIndex</name></expr>]</index></name><operator>.</operator><name><name>uvs0</name><index>[<expr><literal type="number">1</literal> <operator>+</operator> <name>index_X4</name></expr>]</index></name> <operator>=</operator> <name><name>characterInfoArray</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>vertex_TL</name><operator>.</operator><name>uv</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>meshInfo</name><index>[<expr><name>materialIndex</name></expr>]</index></name><operator>.</operator><name><name>uvs0</name><index>[<expr><literal type="number">2</literal> <operator>+</operator> <name>index_X4</name></expr>]</index></name> <operator>=</operator> <name><name>characterInfoArray</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>vertex_TR</name><operator>.</operator><name>uv</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>meshInfo</name><index>[<expr><name>materialIndex</name></expr>]</index></name><operator>.</operator><name><name>uvs0</name><index>[<expr><literal type="number">3</literal> <operator>+</operator> <name>index_X4</name></expr>]</index></name> <operator>=</operator> <name><name>characterInfoArray</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>vertex_BR</name><operator>.</operator><name>uv</name></name></expr>;</expr_stmt>


            <comment type="line">// Setup UVS2</comment>
            <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>meshInfo</name><index>[<expr><name>materialIndex</name></expr>]</index></name><operator>.</operator><name><name>uvs2</name><index>[<expr><literal type="number">0</literal> <operator>+</operator> <name>index_X4</name></expr>]</index></name> <operator>=</operator> <name><name>characterInfoArray</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>vertex_BL</name><operator>.</operator><name>uv2</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>meshInfo</name><index>[<expr><name>materialIndex</name></expr>]</index></name><operator>.</operator><name><name>uvs2</name><index>[<expr><literal type="number">1</literal> <operator>+</operator> <name>index_X4</name></expr>]</index></name> <operator>=</operator> <name><name>characterInfoArray</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>vertex_TL</name><operator>.</operator><name>uv2</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>meshInfo</name><index>[<expr><name>materialIndex</name></expr>]</index></name><operator>.</operator><name><name>uvs2</name><index>[<expr><literal type="number">2</literal> <operator>+</operator> <name>index_X4</name></expr>]</index></name> <operator>=</operator> <name><name>characterInfoArray</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>vertex_TR</name><operator>.</operator><name>uv2</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>meshInfo</name><index>[<expr><name>materialIndex</name></expr>]</index></name><operator>.</operator><name><name>uvs2</name><index>[<expr><literal type="number">3</literal> <operator>+</operator> <name>index_X4</name></expr>]</index></name> <operator>=</operator> <name><name>characterInfoArray</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>vertex_BR</name><operator>.</operator><name>uv2</name></name></expr>;</expr_stmt>


            <comment type="line">// Setup UVS4</comment>
            <comment type="line">//m_textInfo.meshInfo[0].uvs4[0 + index_X4] = characterInfoArray[i].vertex_BL.uv4;</comment>
            <comment type="line">//m_textInfo.meshInfo[0].uvs4[1 + index_X4] = characterInfoArray[i].vertex_TL.uv4;</comment>
            <comment type="line">//m_textInfo.meshInfo[0].uvs4[2 + index_X4] = characterInfoArray[i].vertex_TR.uv4;</comment>
            <comment type="line">//m_textInfo.meshInfo[0].uvs4[3 + index_X4] = characterInfoArray[i].vertex_BR.uv4;</comment>


            <comment type="line">// setup Vertex Colors</comment>
            <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>meshInfo</name><index>[<expr><name>materialIndex</name></expr>]</index></name><operator>.</operator><name><name>colors32</name><index>[<expr><literal type="number">0</literal> <operator>+</operator> <name>index_X4</name></expr>]</index></name> <operator>=</operator> <name><name>characterInfoArray</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>vertex_BL</name><operator>.</operator><name>color</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>meshInfo</name><index>[<expr><name>materialIndex</name></expr>]</index></name><operator>.</operator><name><name>colors32</name><index>[<expr><literal type="number">1</literal> <operator>+</operator> <name>index_X4</name></expr>]</index></name> <operator>=</operator> <name><name>characterInfoArray</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>vertex_TL</name><operator>.</operator><name>color</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>meshInfo</name><index>[<expr><name>materialIndex</name></expr>]</index></name><operator>.</operator><name><name>colors32</name><index>[<expr><literal type="number">2</literal> <operator>+</operator> <name>index_X4</name></expr>]</index></name> <operator>=</operator> <name><name>characterInfoArray</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>vertex_TR</name><operator>.</operator><name>color</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>meshInfo</name><index>[<expr><name>materialIndex</name></expr>]</index></name><operator>.</operator><name><name>colors32</name><index>[<expr><literal type="number">3</literal> <operator>+</operator> <name>index_X4</name></expr>]</index></name> <operator>=</operator> <name><name>characterInfoArray</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>vertex_BR</name><operator>.</operator><name>color</name></name></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>meshInfo</name><index>[<expr><name>materialIndex</name></expr>]</index></name><operator>.</operator><name>vertexCount</name> <operator>=</operator> <name>index_X4</name> <operator>+</operator> <literal type="number">4</literal></expr>;</expr_stmt>
        }</block></function>


        <function><specifier>protected</specifier> <specifier>virtual</specifier> <type><name>void</name></type> <name>FillCharacterVertexBuffers</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>index_X4</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isVolumetric</name></decl></parameter>)</parameter_list>
        <block>{
            <decl_stmt><decl><type><name>int</name></type> <name>materialIndex</name> <init>= <expr><name><name>m_textInfo</name><operator>.</operator><name>characterInfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>materialReferenceIndex</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>index_X4</name> <operator>=</operator> <name><name>m_textInfo</name><operator>.</operator><name>meshInfo</name><index>[<expr><name>materialIndex</name></expr>]</index></name><operator>.</operator><name>vertexCount</name></expr>;</expr_stmt>

            <decl_stmt><decl><type><name><name>TMP_CharacterInfo</name><index>[]</index></name></type> <name>characterInfoArray</name> <init>= <expr><name><name>m_textInfo</name><operator>.</operator><name>characterInfo</name></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>characterInfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>vertexIndex</name> <operator>=</operator> <name>index_X4</name></expr>;</expr_stmt>

            <comment type="line">// Setup Vertices for Characters</comment>
            <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>meshInfo</name><index>[<expr><name>materialIndex</name></expr>]</index></name><operator>.</operator><name><name>vertices</name><index>[<expr><literal type="number">0</literal> <operator>+</operator> <name>index_X4</name></expr>]</index></name> <operator>=</operator> <name><name>characterInfoArray</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>vertex_BL</name><operator>.</operator><name>position</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>meshInfo</name><index>[<expr><name>materialIndex</name></expr>]</index></name><operator>.</operator><name><name>vertices</name><index>[<expr><literal type="number">1</literal> <operator>+</operator> <name>index_X4</name></expr>]</index></name> <operator>=</operator> <name><name>characterInfoArray</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>vertex_TL</name><operator>.</operator><name>position</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>meshInfo</name><index>[<expr><name>materialIndex</name></expr>]</index></name><operator>.</operator><name><name>vertices</name><index>[<expr><literal type="number">2</literal> <operator>+</operator> <name>index_X4</name></expr>]</index></name> <operator>=</operator> <name><name>characterInfoArray</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>vertex_TR</name><operator>.</operator><name>position</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>meshInfo</name><index>[<expr><name>materialIndex</name></expr>]</index></name><operator>.</operator><name><name>vertices</name><index>[<expr><literal type="number">3</literal> <operator>+</operator> <name>index_X4</name></expr>]</index></name> <operator>=</operator> <name><name>characterInfoArray</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>vertex_BR</name><operator>.</operator><name>position</name></name></expr>;</expr_stmt>

            <if>if <condition>(<expr><name>isVolumetric</name></expr>)</condition><then>
            <block>{
                <decl_stmt><decl><type><name>Vector3</name></type> <name>depth</name> <init>= <expr><operator>new</operator> <call><name>Vector3</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>m_fontSize</name> <operator>*</operator> <name>m_fontScale</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>meshInfo</name><index>[<expr><name>materialIndex</name></expr>]</index></name><operator>.</operator><name><name>vertices</name><index>[<expr><literal type="number">4</literal> <operator>+</operator> <name>index_X4</name></expr>]</index></name> <operator>=</operator> <name><name>characterInfoArray</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>vertex_BL</name><operator>.</operator><name>position</name></name> <operator>+</operator> <name>depth</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>meshInfo</name><index>[<expr><name>materialIndex</name></expr>]</index></name><operator>.</operator><name><name>vertices</name><index>[<expr><literal type="number">5</literal> <operator>+</operator> <name>index_X4</name></expr>]</index></name> <operator>=</operator> <name><name>characterInfoArray</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>vertex_TL</name><operator>.</operator><name>position</name></name> <operator>+</operator> <name>depth</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>meshInfo</name><index>[<expr><name>materialIndex</name></expr>]</index></name><operator>.</operator><name><name>vertices</name><index>[<expr><literal type="number">6</literal> <operator>+</operator> <name>index_X4</name></expr>]</index></name> <operator>=</operator> <name><name>characterInfoArray</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>vertex_TR</name><operator>.</operator><name>position</name></name> <operator>+</operator> <name>depth</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>meshInfo</name><index>[<expr><name>materialIndex</name></expr>]</index></name><operator>.</operator><name><name>vertices</name><index>[<expr><literal type="number">7</literal> <operator>+</operator> <name>index_X4</name></expr>]</index></name> <operator>=</operator> <name><name>characterInfoArray</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>vertex_BR</name><operator>.</operator><name>position</name></name> <operator>+</operator> <name>depth</name></expr>;</expr_stmt>
            }</block></then></if>

            <comment type="line">// Setup UVS0</comment>
            <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>meshInfo</name><index>[<expr><name>materialIndex</name></expr>]</index></name><operator>.</operator><name><name>uvs0</name><index>[<expr><literal type="number">0</literal> <operator>+</operator> <name>index_X4</name></expr>]</index></name> <operator>=</operator> <name><name>characterInfoArray</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>vertex_BL</name><operator>.</operator><name>uv</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>meshInfo</name><index>[<expr><name>materialIndex</name></expr>]</index></name><operator>.</operator><name><name>uvs0</name><index>[<expr><literal type="number">1</literal> <operator>+</operator> <name>index_X4</name></expr>]</index></name> <operator>=</operator> <name><name>characterInfoArray</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>vertex_TL</name><operator>.</operator><name>uv</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>meshInfo</name><index>[<expr><name>materialIndex</name></expr>]</index></name><operator>.</operator><name><name>uvs0</name><index>[<expr><literal type="number">2</literal> <operator>+</operator> <name>index_X4</name></expr>]</index></name> <operator>=</operator> <name><name>characterInfoArray</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>vertex_TR</name><operator>.</operator><name>uv</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>meshInfo</name><index>[<expr><name>materialIndex</name></expr>]</index></name><operator>.</operator><name><name>uvs0</name><index>[<expr><literal type="number">3</literal> <operator>+</operator> <name>index_X4</name></expr>]</index></name> <operator>=</operator> <name><name>characterInfoArray</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>vertex_BR</name><operator>.</operator><name>uv</name></name></expr>;</expr_stmt>

            <if>if <condition>(<expr><name>isVolumetric</name></expr>)</condition><then>
            <block>{
                <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>meshInfo</name><index>[<expr><name>materialIndex</name></expr>]</index></name><operator>.</operator><name><name>uvs0</name><index>[<expr><literal type="number">4</literal> <operator>+</operator> <name>index_X4</name></expr>]</index></name> <operator>=</operator> <name><name>characterInfoArray</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>vertex_BL</name><operator>.</operator><name>uv</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>meshInfo</name><index>[<expr><name>materialIndex</name></expr>]</index></name><operator>.</operator><name><name>uvs0</name><index>[<expr><literal type="number">5</literal> <operator>+</operator> <name>index_X4</name></expr>]</index></name> <operator>=</operator> <name><name>characterInfoArray</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>vertex_TL</name><operator>.</operator><name>uv</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>meshInfo</name><index>[<expr><name>materialIndex</name></expr>]</index></name><operator>.</operator><name><name>uvs0</name><index>[<expr><literal type="number">6</literal> <operator>+</operator> <name>index_X4</name></expr>]</index></name> <operator>=</operator> <name><name>characterInfoArray</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>vertex_TR</name><operator>.</operator><name>uv</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>meshInfo</name><index>[<expr><name>materialIndex</name></expr>]</index></name><operator>.</operator><name><name>uvs0</name><index>[<expr><literal type="number">7</literal> <operator>+</operator> <name>index_X4</name></expr>]</index></name> <operator>=</operator> <name><name>characterInfoArray</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>vertex_BR</name><operator>.</operator><name>uv</name></name></expr>;</expr_stmt>
            }</block></then></if>


            <comment type="line">// Setup UVS2</comment>
            <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>meshInfo</name><index>[<expr><name>materialIndex</name></expr>]</index></name><operator>.</operator><name><name>uvs2</name><index>[<expr><literal type="number">0</literal> <operator>+</operator> <name>index_X4</name></expr>]</index></name> <operator>=</operator> <name><name>characterInfoArray</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>vertex_BL</name><operator>.</operator><name>uv2</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>meshInfo</name><index>[<expr><name>materialIndex</name></expr>]</index></name><operator>.</operator><name><name>uvs2</name><index>[<expr><literal type="number">1</literal> <operator>+</operator> <name>index_X4</name></expr>]</index></name> <operator>=</operator> <name><name>characterInfoArray</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>vertex_TL</name><operator>.</operator><name>uv2</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>meshInfo</name><index>[<expr><name>materialIndex</name></expr>]</index></name><operator>.</operator><name><name>uvs2</name><index>[<expr><literal type="number">2</literal> <operator>+</operator> <name>index_X4</name></expr>]</index></name> <operator>=</operator> <name><name>characterInfoArray</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>vertex_TR</name><operator>.</operator><name>uv2</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>meshInfo</name><index>[<expr><name>materialIndex</name></expr>]</index></name><operator>.</operator><name><name>uvs2</name><index>[<expr><literal type="number">3</literal> <operator>+</operator> <name>index_X4</name></expr>]</index></name> <operator>=</operator> <name><name>characterInfoArray</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>vertex_BR</name><operator>.</operator><name>uv2</name></name></expr>;</expr_stmt>

            <if>if <condition>(<expr><name>isVolumetric</name></expr>)</condition><then>
            <block>{
                <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>meshInfo</name><index>[<expr><name>materialIndex</name></expr>]</index></name><operator>.</operator><name><name>uvs2</name><index>[<expr><literal type="number">4</literal> <operator>+</operator> <name>index_X4</name></expr>]</index></name> <operator>=</operator> <name><name>characterInfoArray</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>vertex_BL</name><operator>.</operator><name>uv2</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>meshInfo</name><index>[<expr><name>materialIndex</name></expr>]</index></name><operator>.</operator><name><name>uvs2</name><index>[<expr><literal type="number">5</literal> <operator>+</operator> <name>index_X4</name></expr>]</index></name> <operator>=</operator> <name><name>characterInfoArray</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>vertex_TL</name><operator>.</operator><name>uv2</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>meshInfo</name><index>[<expr><name>materialIndex</name></expr>]</index></name><operator>.</operator><name><name>uvs2</name><index>[<expr><literal type="number">6</literal> <operator>+</operator> <name>index_X4</name></expr>]</index></name> <operator>=</operator> <name><name>characterInfoArray</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>vertex_TR</name><operator>.</operator><name>uv2</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>meshInfo</name><index>[<expr><name>materialIndex</name></expr>]</index></name><operator>.</operator><name><name>uvs2</name><index>[<expr><literal type="number">7</literal> <operator>+</operator> <name>index_X4</name></expr>]</index></name> <operator>=</operator> <name><name>characterInfoArray</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>vertex_BR</name><operator>.</operator><name>uv2</name></name></expr>;</expr_stmt>
            }</block></then></if>


            <comment type="line">// Setup UVS4</comment>
            <comment type="line">//m_textInfo.meshInfo[0].uvs4[0 + index_X4] = characterInfoArray[i].vertex_BL.uv4;</comment>
            <comment type="line">//m_textInfo.meshInfo[0].uvs4[1 + index_X4] = characterInfoArray[i].vertex_TL.uv4;</comment>
            <comment type="line">//m_textInfo.meshInfo[0].uvs4[2 + index_X4] = characterInfoArray[i].vertex_TR.uv4;</comment>
            <comment type="line">//m_textInfo.meshInfo[0].uvs4[3 + index_X4] = characterInfoArray[i].vertex_BR.uv4;</comment>


            <comment type="line">// setup Vertex Colors</comment>
            <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>meshInfo</name><index>[<expr><name>materialIndex</name></expr>]</index></name><operator>.</operator><name><name>colors32</name><index>[<expr><literal type="number">0</literal> <operator>+</operator> <name>index_X4</name></expr>]</index></name> <operator>=</operator> <name><name>characterInfoArray</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>vertex_BL</name><operator>.</operator><name>color</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>meshInfo</name><index>[<expr><name>materialIndex</name></expr>]</index></name><operator>.</operator><name><name>colors32</name><index>[<expr><literal type="number">1</literal> <operator>+</operator> <name>index_X4</name></expr>]</index></name> <operator>=</operator> <name><name>characterInfoArray</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>vertex_TL</name><operator>.</operator><name>color</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>meshInfo</name><index>[<expr><name>materialIndex</name></expr>]</index></name><operator>.</operator><name><name>colors32</name><index>[<expr><literal type="number">2</literal> <operator>+</operator> <name>index_X4</name></expr>]</index></name> <operator>=</operator> <name><name>characterInfoArray</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>vertex_TR</name><operator>.</operator><name>color</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>meshInfo</name><index>[<expr><name>materialIndex</name></expr>]</index></name><operator>.</operator><name><name>colors32</name><index>[<expr><literal type="number">3</literal> <operator>+</operator> <name>index_X4</name></expr>]</index></name> <operator>=</operator> <name><name>characterInfoArray</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>vertex_BR</name><operator>.</operator><name>color</name></name></expr>;</expr_stmt>

            <if>if <condition>(<expr><name>isVolumetric</name></expr>)</condition><then>
            <block>{
                <decl_stmt><decl><type><name>Color32</name></type> <name>backColor</name> <init>= <expr><operator>new</operator> <call><name>Color32</name><argument_list>(<argument><expr><literal type="number">255</literal></expr></argument>, <argument><expr><literal type="number">255</literal></expr></argument>, <argument><expr><literal type="number">128</literal></expr></argument>, <argument><expr><literal type="number">255</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>meshInfo</name><index>[<expr><name>materialIndex</name></expr>]</index></name><operator>.</operator><name><name>colors32</name><index>[<expr><literal type="number">4</literal> <operator>+</operator> <name>index_X4</name></expr>]</index></name> <operator>=</operator> <name>backColor</name></expr>;</expr_stmt> <comment type="line">//characterInfoArray[i].vertex_BL.color;</comment>
                <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>meshInfo</name><index>[<expr><name>materialIndex</name></expr>]</index></name><operator>.</operator><name><name>colors32</name><index>[<expr><literal type="number">5</literal> <operator>+</operator> <name>index_X4</name></expr>]</index></name> <operator>=</operator> <name>backColor</name></expr>;</expr_stmt> <comment type="line">//characterInfoArray[i].vertex_TL.color;</comment>
                <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>meshInfo</name><index>[<expr><name>materialIndex</name></expr>]</index></name><operator>.</operator><name><name>colors32</name><index>[<expr><literal type="number">6</literal> <operator>+</operator> <name>index_X4</name></expr>]</index></name> <operator>=</operator> <name>backColor</name></expr>;</expr_stmt> <comment type="line">//characterInfoArray[i].vertex_TR.color;</comment>
                <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>meshInfo</name><index>[<expr><name>materialIndex</name></expr>]</index></name><operator>.</operator><name><name>colors32</name><index>[<expr><literal type="number">7</literal> <operator>+</operator> <name>index_X4</name></expr>]</index></name> <operator>=</operator> <name>backColor</name></expr>;</expr_stmt> <comment type="line">//characterInfoArray[i].vertex_BR.color;</comment>
            }</block></then></if>

            <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>meshInfo</name><index>[<expr><name>materialIndex</name></expr>]</index></name><operator>.</operator><name>vertexCount</name> <operator>=</operator> <name>index_X4</name> <operator>+</operator> <operator>(</operator><ternary><condition><expr><operator>!</operator><name>isVolumetric</name></expr> ?</condition><then> <expr><literal type="number">4</literal></expr> </then><else>: <expr><literal type="number">8</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
        }</block></function>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Fill Vertex Buffers for Sprites</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;param name="i"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="spriteIndex_X4"&gt;&lt;/param&gt;</comment>
        <function><specifier>protected</specifier> <specifier>virtual</specifier> <type><name>void</name></type> <name>FillSpriteVertexBuffers</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>index_X4</name></decl></parameter>)</parameter_list>
        <block>{
            <decl_stmt><decl><type><name>int</name></type> <name>materialIndex</name> <init>= <expr><name><name>m_textInfo</name><operator>.</operator><name>characterInfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>materialReferenceIndex</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>index_X4</name> <operator>=</operator> <name><name>m_textInfo</name><operator>.</operator><name>meshInfo</name><index>[<expr><name>materialIndex</name></expr>]</index></name><operator>.</operator><name>vertexCount</name></expr>;</expr_stmt>

            <decl_stmt><decl><type><name><name>TMP_CharacterInfo</name><index>[]</index></name></type> <name>characterInfoArray</name> <init>= <expr><name><name>m_textInfo</name><operator>.</operator><name>characterInfo</name></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>characterInfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>vertexIndex</name> <operator>=</operator> <name>index_X4</name></expr>;</expr_stmt>

            <comment type="line">// Setup Vertices for Characters</comment>
            <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>meshInfo</name><index>[<expr><name>materialIndex</name></expr>]</index></name><operator>.</operator><name><name>vertices</name><index>[<expr><literal type="number">0</literal> <operator>+</operator> <name>index_X4</name></expr>]</index></name> <operator>=</operator> <name><name>characterInfoArray</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>vertex_BL</name><operator>.</operator><name>position</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>meshInfo</name><index>[<expr><name>materialIndex</name></expr>]</index></name><operator>.</operator><name><name>vertices</name><index>[<expr><literal type="number">1</literal> <operator>+</operator> <name>index_X4</name></expr>]</index></name> <operator>=</operator> <name><name>characterInfoArray</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>vertex_TL</name><operator>.</operator><name>position</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>meshInfo</name><index>[<expr><name>materialIndex</name></expr>]</index></name><operator>.</operator><name><name>vertices</name><index>[<expr><literal type="number">2</literal> <operator>+</operator> <name>index_X4</name></expr>]</index></name> <operator>=</operator> <name><name>characterInfoArray</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>vertex_TR</name><operator>.</operator><name>position</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>meshInfo</name><index>[<expr><name>materialIndex</name></expr>]</index></name><operator>.</operator><name><name>vertices</name><index>[<expr><literal type="number">3</literal> <operator>+</operator> <name>index_X4</name></expr>]</index></name> <operator>=</operator> <name><name>characterInfoArray</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>vertex_BR</name><operator>.</operator><name>position</name></name></expr>;</expr_stmt>


            <comment type="line">// Setup UVS0</comment>
            <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>meshInfo</name><index>[<expr><name>materialIndex</name></expr>]</index></name><operator>.</operator><name><name>uvs0</name><index>[<expr><literal type="number">0</literal> <operator>+</operator> <name>index_X4</name></expr>]</index></name> <operator>=</operator> <name><name>characterInfoArray</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>vertex_BL</name><operator>.</operator><name>uv</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>meshInfo</name><index>[<expr><name>materialIndex</name></expr>]</index></name><operator>.</operator><name><name>uvs0</name><index>[<expr><literal type="number">1</literal> <operator>+</operator> <name>index_X4</name></expr>]</index></name> <operator>=</operator> <name><name>characterInfoArray</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>vertex_TL</name><operator>.</operator><name>uv</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>meshInfo</name><index>[<expr><name>materialIndex</name></expr>]</index></name><operator>.</operator><name><name>uvs0</name><index>[<expr><literal type="number">2</literal> <operator>+</operator> <name>index_X4</name></expr>]</index></name> <operator>=</operator> <name><name>characterInfoArray</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>vertex_TR</name><operator>.</operator><name>uv</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>meshInfo</name><index>[<expr><name>materialIndex</name></expr>]</index></name><operator>.</operator><name><name>uvs0</name><index>[<expr><literal type="number">3</literal> <operator>+</operator> <name>index_X4</name></expr>]</index></name> <operator>=</operator> <name><name>characterInfoArray</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>vertex_BR</name><operator>.</operator><name>uv</name></name></expr>;</expr_stmt>


            <comment type="line">// Setup UVS2</comment>
            <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>meshInfo</name><index>[<expr><name>materialIndex</name></expr>]</index></name><operator>.</operator><name><name>uvs2</name><index>[<expr><literal type="number">0</literal> <operator>+</operator> <name>index_X4</name></expr>]</index></name> <operator>=</operator> <name><name>characterInfoArray</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>vertex_BL</name><operator>.</operator><name>uv2</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>meshInfo</name><index>[<expr><name>materialIndex</name></expr>]</index></name><operator>.</operator><name><name>uvs2</name><index>[<expr><literal type="number">1</literal> <operator>+</operator> <name>index_X4</name></expr>]</index></name> <operator>=</operator> <name><name>characterInfoArray</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>vertex_TL</name><operator>.</operator><name>uv2</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>meshInfo</name><index>[<expr><name>materialIndex</name></expr>]</index></name><operator>.</operator><name><name>uvs2</name><index>[<expr><literal type="number">2</literal> <operator>+</operator> <name>index_X4</name></expr>]</index></name> <operator>=</operator> <name><name>characterInfoArray</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>vertex_TR</name><operator>.</operator><name>uv2</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>meshInfo</name><index>[<expr><name>materialIndex</name></expr>]</index></name><operator>.</operator><name><name>uvs2</name><index>[<expr><literal type="number">3</literal> <operator>+</operator> <name>index_X4</name></expr>]</index></name> <operator>=</operator> <name><name>characterInfoArray</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>vertex_BR</name><operator>.</operator><name>uv2</name></name></expr>;</expr_stmt>


            <comment type="line">// Setup UVS4</comment>
            <comment type="line">//m_textInfo.meshInfo[0].uvs4[0 + index_X4] = characterInfoArray[i].vertex_BL.uv4;</comment>
            <comment type="line">//m_textInfo.meshInfo[0].uvs4[1 + index_X4] = characterInfoArray[i].vertex_TL.uv4;</comment>
            <comment type="line">//m_textInfo.meshInfo[0].uvs4[2 + index_X4] = characterInfoArray[i].vertex_TR.uv4;</comment>
            <comment type="line">//m_textInfo.meshInfo[0].uvs4[3 + index_X4] = characterInfoArray[i].vertex_BR.uv4;</comment>


            <comment type="line">// setup Vertex Colors</comment>
            <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>meshInfo</name><index>[<expr><name>materialIndex</name></expr>]</index></name><operator>.</operator><name><name>colors32</name><index>[<expr><literal type="number">0</literal> <operator>+</operator> <name>index_X4</name></expr>]</index></name> <operator>=</operator> <name><name>characterInfoArray</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>vertex_BL</name><operator>.</operator><name>color</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>meshInfo</name><index>[<expr><name>materialIndex</name></expr>]</index></name><operator>.</operator><name><name>colors32</name><index>[<expr><literal type="number">1</literal> <operator>+</operator> <name>index_X4</name></expr>]</index></name> <operator>=</operator> <name><name>characterInfoArray</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>vertex_TL</name><operator>.</operator><name>color</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>meshInfo</name><index>[<expr><name>materialIndex</name></expr>]</index></name><operator>.</operator><name><name>colors32</name><index>[<expr><literal type="number">2</literal> <operator>+</operator> <name>index_X4</name></expr>]</index></name> <operator>=</operator> <name><name>characterInfoArray</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>vertex_TR</name><operator>.</operator><name>color</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>meshInfo</name><index>[<expr><name>materialIndex</name></expr>]</index></name><operator>.</operator><name><name>colors32</name><index>[<expr><literal type="number">3</literal> <operator>+</operator> <name>index_X4</name></expr>]</index></name> <operator>=</operator> <name><name>characterInfoArray</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>vertex_BR</name><operator>.</operator><name>color</name></name></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>meshInfo</name><index>[<expr><name>materialIndex</name></expr>]</index></name><operator>.</operator><name>vertexCount</name> <operator>=</operator> <name>index_X4</name> <operator>+</operator> <literal type="number">4</literal></expr>;</expr_stmt>
        }</block></function>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Method to add the underline geometry.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;param name="start"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="end"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="startScale"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="endScale"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="maxScale"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="underlineColor"&gt;&lt;/param&gt;</comment>
        <function><specifier>protected</specifier> <specifier>virtual</specifier> <type><name>void</name></type> <name>DrawUnderlineMesh</name><parameter_list>(<parameter><decl><type><name>Vector3</name></type> <name>start</name></decl></parameter>, <parameter><decl><type><name>Vector3</name></type> <name>end</name></decl></parameter>, <parameter><decl><type><modifier>ref</modifier> <name>int</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>startScale</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>endScale</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>maxScale</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>sdfScale</name></decl></parameter>, <parameter><decl><type><name>Color32</name></type> <name>underlineColor</name></decl></parameter>)</parameter_list>
        <block>{
            <if>if <condition>(<expr><name>m_cached_Underline_GlyphInfo</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then>
            <block>{
                <if>if <condition>(<expr><operator>!</operator><name><name>TMP_Settings</name><operator>.</operator><name>warningsDisabled</name></name></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><call><name><name>Debug</name><operator>.</operator><name>LogWarning</name></name><argument_list>(<argument><expr><literal type="string">"Unable to add underline since the Font Asset doesn't contain the underline character."</literal></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block></then></if>
                <return>return;</return>
            }</block></then></if>

            <decl_stmt><decl><type><name>int</name></type> <name>verticesCount</name> <init>= <expr><name>index</name> <operator>+</operator> <literal type="number">12</literal></expr></init></decl>;</decl_stmt>
            <comment type="line">// Check to make sure our current mesh buffer allocations can hold these new Quads.</comment>
            <if>if <condition>(<expr><name>verticesCount</name> <operator>&gt;</operator> <name><name>m_textInfo</name><operator>.</operator><name>meshInfo</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>vertices</name><operator>.</operator><name>Length</name></name></expr>)</condition><then>
            <block>{
                <comment type="line">// Resize Mesh Buffers</comment>
                <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>meshInfo</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><call><name>ResizeMeshInfo</name><argument_list>(<argument><expr><name>verticesCount</name> <operator>/</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>

            <comment type="line">// Adjust the position of the underline based on the lowest character. This matters for subscript character.</comment>
            <expr_stmt><expr><name><name>start</name><operator>.</operator><name>y</name></name> <operator>=</operator> <call><name><name>Mathf</name><operator>.</operator><name>Min</name></name><argument_list>(<argument><expr><name><name>start</name><operator>.</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>end</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>end</name><operator>.</operator><name>y</name></name> <operator>=</operator> <call><name><name>Mathf</name><operator>.</operator><name>Min</name></name><argument_list>(<argument><expr><name><name>start</name><operator>.</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>end</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <decl_stmt><decl><type><name>float</name></type> <name>segmentWidth</name> <init>= <expr><name><name>m_cached_Underline_GlyphInfo</name><operator>.</operator><name>width</name></name> <operator>/</operator> <literal type="number">2</literal> <operator>*</operator> <name>maxScale</name></expr></init></decl>;</decl_stmt>

            <if>if <condition>(<expr><name><name>end</name><operator>.</operator><name>x</name></name> <operator>-</operator> <name><name>start</name><operator>.</operator><name>x</name></name> <operator>&lt;</operator> <name><name>m_cached_Underline_GlyphInfo</name><operator>.</operator><name>width</name></name> <operator>*</operator> <name>maxScale</name></expr>)</condition><then>
            <block>{
                <expr_stmt><expr><name>segmentWidth</name> <operator>=</operator> <operator>(</operator><name><name>end</name><operator>.</operator><name>x</name></name> <operator>-</operator> <name><name>start</name><operator>.</operator><name>x</name></name><operator>)</operator> <operator>/</operator> <literal type="number">2f</literal></expr>;</expr_stmt>
            }</block></then></if>

            <decl_stmt><decl><type><name>float</name></type> <name>startPadding</name> <init>= <expr><name>m_padding</name> <operator>*</operator> <name>startScale</name> <operator>/</operator> <name>maxScale</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>float</name></type> <name>endPadding</name> <init>= <expr><name>m_padding</name> <operator>*</operator> <name>endScale</name> <operator>/</operator> <name>maxScale</name></expr></init></decl>;</decl_stmt>

            <decl_stmt><decl><type><name>float</name></type> <name>underlineThickness</name> <init>= <expr><name><name>m_cached_Underline_GlyphInfo</name><operator>.</operator><name>height</name></name></expr></init></decl>;</decl_stmt>

            <comment type="line">// UNDERLINE VERTICES FOR (3) LINE SEGMENTS</comment>
            <cpp:region>#<cpp:directive>region</cpp:directive> <name>UNDERLINE</name> <name>VERTICES</name></cpp:region>
            <decl_stmt><decl><type><name><name>Vector3</name><index>[]</index></name></type> <name>vertices</name> <init>= <expr><name><name>m_textInfo</name><operator>.</operator><name>meshInfo</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>vertices</name></expr></init></decl>;</decl_stmt>

            <comment type="line">// Front Part of the Underline</comment>
            <expr_stmt><expr><name><name>vertices</name><index>[<expr><name>index</name> <operator>+</operator> <literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>start</name> <operator>+</operator> <operator>new</operator> <call><name>Vector3</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal> <operator>-</operator> <operator>(</operator><name>underlineThickness</name> <operator>+</operator> <name>m_padding</name><operator>)</operator> <operator>*</operator> <name>maxScale</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// BL</comment>
            <expr_stmt><expr><name><name>vertices</name><index>[<expr><name>index</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>start</name> <operator>+</operator> <operator>new</operator> <call><name>Vector3</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>m_padding</name> <operator>*</operator> <name>maxScale</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// TL</comment>
            <expr_stmt><expr><name><name>vertices</name><index>[<expr><name>index</name> <operator>+</operator> <literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>vertices</name><index>[<expr><name>index</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <operator>new</operator> <call><name>Vector3</name><argument_list>(<argument><expr><name>segmentWidth</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// TR</comment>
            <expr_stmt><expr><name><name>vertices</name><index>[<expr><name>index</name> <operator>+</operator> <literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name><name>vertices</name><index>[<expr><name>index</name> <operator>+</operator> <literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <operator>new</operator> <call><name>Vector3</name><argument_list>(<argument><expr><name>segmentWidth</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// BR</comment>

            <comment type="line">// Middle Part of the Underline</comment>
            <expr_stmt><expr><name><name>vertices</name><index>[<expr><name>index</name> <operator>+</operator> <literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name><name>vertices</name><index>[<expr><name>index</name> <operator>+</operator> <literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt> <comment type="line">// BL</comment>
            <expr_stmt><expr><name><name>vertices</name><index>[<expr><name>index</name> <operator>+</operator> <literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <name><name>vertices</name><index>[<expr><name>index</name> <operator>+</operator> <literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt> <comment type="line">// TL</comment>
            <expr_stmt><expr><name><name>vertices</name><index>[<expr><name>index</name> <operator>+</operator> <literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <name>end</name> <operator>+</operator> <operator>new</operator> <call><name>Vector3</name><argument_list>(<argument><expr><operator>-</operator><name>segmentWidth</name></expr></argument>, <argument><expr><name>m_padding</name> <operator>*</operator> <name>maxScale</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="line">// TR</comment>
            <expr_stmt><expr><name><name>vertices</name><index>[<expr><name>index</name> <operator>+</operator> <literal type="number">7</literal></expr>]</index></name> <operator>=</operator> <name>end</name> <operator>+</operator> <operator>new</operator> <call><name>Vector3</name><argument_list>(<argument><expr><operator>-</operator><name>segmentWidth</name></expr></argument>, <argument><expr><operator>-</operator><operator>(</operator><name>underlineThickness</name> <operator>+</operator> <name>m_padding</name><operator>)</operator> <operator>*</operator> <name>maxScale</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// BR</comment>

            <comment type="line">// End Part of the Underline</comment>
            <expr_stmt><expr><name><name>vertices</name><index>[<expr><name>index</name> <operator>+</operator> <literal type="number">8</literal></expr>]</index></name> <operator>=</operator> <name><name>vertices</name><index>[<expr><name>index</name> <operator>+</operator> <literal type="number">7</literal></expr>]</index></name></expr>;</expr_stmt> <comment type="line">// BL</comment>
            <expr_stmt><expr><name><name>vertices</name><index>[<expr><name>index</name> <operator>+</operator> <literal type="number">9</literal></expr>]</index></name> <operator>=</operator> <name><name>vertices</name><index>[<expr><name>index</name> <operator>+</operator> <literal type="number">6</literal></expr>]</index></name></expr>;</expr_stmt> <comment type="line">// TL</comment>
            <expr_stmt><expr><name><name>vertices</name><index>[<expr><name>index</name> <operator>+</operator> <literal type="number">10</literal></expr>]</index></name> <operator>=</operator> <name>end</name> <operator>+</operator> <operator>new</operator> <call><name>Vector3</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>m_padding</name> <operator>*</operator> <name>maxScale</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// TR</comment>
            <expr_stmt><expr><name><name>vertices</name><index>[<expr><name>index</name> <operator>+</operator> <literal type="number">11</literal></expr>]</index></name> <operator>=</operator> <name>end</name> <operator>+</operator> <operator>new</operator> <call><name>Vector3</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>-</operator><operator>(</operator><name>underlineThickness</name> <operator>+</operator> <name>m_padding</name><operator>)</operator> <operator>*</operator> <name>maxScale</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// BR</comment>
            <cpp:endregion>#<cpp:directive>endregion</cpp:directive></cpp:endregion>

            <comment type="line">// UNDERLINE UV0</comment>
            <cpp:region>#<cpp:directive>region</cpp:directive> <name>HANDLE</name> <name>UV0</name></cpp:region>
            <decl_stmt><decl><type><name><name>Vector2</name><index>[]</index></name></type> <name>uvs0</name> <init>= <expr><name><name>m_textInfo</name><operator>.</operator><name>meshInfo</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>uvs0</name></expr></init></decl>;</decl_stmt>

            <comment type="line">// Calculate UV required to setup the 3 Quads for the Underline.</comment>
            <decl_stmt><decl><type><name>Vector2</name></type> <name>uv0</name> <init>= <expr><operator>new</operator> <call><name>Vector2</name><argument_list>(<argument><expr><operator>(</operator><name><name>m_cached_Underline_GlyphInfo</name><operator>.</operator><name>x</name></name> <operator>-</operator> <name>startPadding</name><operator>)</operator> <operator>/</operator> <name><name>m_fontAsset</name><operator>.</operator><name>fontInfo</name><operator>.</operator><name>AtlasWidth</name></name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>-</operator> <operator>(</operator><name><name>m_cached_Underline_GlyphInfo</name><operator>.</operator><name>y</name></name> <operator>+</operator> <name>m_padding</name> <operator>+</operator> <name><name>m_cached_Underline_GlyphInfo</name><operator>.</operator><name>height</name></name><operator>)</operator> <operator>/</operator> <name><name>m_fontAsset</name><operator>.</operator><name>fontInfo</name><operator>.</operator><name>AtlasHeight</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>  <comment type="line">// bottom left</comment>
            <decl_stmt><decl><type><name>Vector2</name></type> <name>uv1</name> <init>= <expr><operator>new</operator> <call><name>Vector2</name><argument_list>(<argument><expr><name><name>uv0</name><operator>.</operator><name>x</name></name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>-</operator> <operator>(</operator><name><name>m_cached_Underline_GlyphInfo</name><operator>.</operator><name>y</name></name> <operator>-</operator> <name>m_padding</name><operator>)</operator> <operator>/</operator> <name><name>m_fontAsset</name><operator>.</operator><name>fontInfo</name><operator>.</operator><name>AtlasHeight</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>  <comment type="line">// top left</comment>
            <decl_stmt><decl><type><name>Vector2</name></type> <name>uv2</name> <init>= <expr><operator>new</operator> <call><name>Vector2</name><argument_list>(<argument><expr><operator>(</operator><name><name>m_cached_Underline_GlyphInfo</name><operator>.</operator><name>x</name></name> <operator>-</operator> <name>startPadding</name> <operator>+</operator> <name><name>m_cached_Underline_GlyphInfo</name><operator>.</operator><name>width</name></name> <operator>/</operator> <literal type="number">2</literal><operator>)</operator> <operator>/</operator> <name><name>m_fontAsset</name><operator>.</operator><name>fontInfo</name><operator>.</operator><name>AtlasWidth</name></name></expr></argument>, <argument><expr><name><name>uv1</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="line">// Mid Top Left</comment>
            <decl_stmt><decl><type><name>Vector2</name></type> <name>uv3</name> <init>= <expr><operator>new</operator> <call><name>Vector2</name><argument_list>(<argument><expr><name><name>uv2</name><operator>.</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>uv0</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="line">// Mid Bottom Left</comment>
            <decl_stmt><decl><type><name>Vector2</name></type> <name>uv4</name> <init>= <expr><operator>new</operator> <call><name>Vector2</name><argument_list>(<argument><expr><operator>(</operator><name><name>m_cached_Underline_GlyphInfo</name><operator>.</operator><name>x</name></name> <operator>+</operator> <name>endPadding</name> <operator>+</operator> <name><name>m_cached_Underline_GlyphInfo</name><operator>.</operator><name>width</name></name> <operator>/</operator> <literal type="number">2</literal><operator>)</operator> <operator>/</operator> <name><name>m_fontAsset</name><operator>.</operator><name>fontInfo</name><operator>.</operator><name>AtlasWidth</name></name></expr></argument>, <argument><expr><name><name>uv1</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="line">// Mid Top Right</comment>
            <decl_stmt><decl><type><name>Vector2</name></type> <name>uv5</name> <init>= <expr><operator>new</operator> <call><name>Vector2</name><argument_list>(<argument><expr><name><name>uv4</name><operator>.</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>uv0</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="line">// Mid Bottom right</comment>
            <decl_stmt><decl><type><name>Vector2</name></type> <name>uv6</name> <init>= <expr><operator>new</operator> <call><name>Vector2</name><argument_list>(<argument><expr><operator>(</operator><name><name>m_cached_Underline_GlyphInfo</name><operator>.</operator><name>x</name></name> <operator>+</operator> <name>endPadding</name> <operator>+</operator> <name><name>m_cached_Underline_GlyphInfo</name><operator>.</operator><name>width</name></name><operator>)</operator> <operator>/</operator> <name><name>m_fontAsset</name><operator>.</operator><name>fontInfo</name><operator>.</operator><name>AtlasWidth</name></name></expr></argument>, <argument><expr><name><name>uv1</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="line">// End Part - Bottom Right</comment>
            <decl_stmt><decl><type><name>Vector2</name></type> <name>uv7</name> <init>= <expr><operator>new</operator> <call><name>Vector2</name><argument_list>(<argument><expr><name><name>uv6</name><operator>.</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>uv0</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="line">// End Part - Top Right</comment>

            <comment type="line">// Left Part of the Underline</comment>
            <expr_stmt><expr><name><name>uvs0</name><index>[<expr><literal type="number">0</literal> <operator>+</operator> <name>index</name></expr>]</index></name> <operator>=</operator> <name>uv0</name></expr>;</expr_stmt> <comment type="line">// BL</comment>
            <expr_stmt><expr><name><name>uvs0</name><index>[<expr><literal type="number">1</literal> <operator>+</operator> <name>index</name></expr>]</index></name> <operator>=</operator> <name>uv1</name></expr>;</expr_stmt> <comment type="line">// TL</comment>
            <expr_stmt><expr><name><name>uvs0</name><index>[<expr><literal type="number">2</literal> <operator>+</operator> <name>index</name></expr>]</index></name> <operator>=</operator> <name>uv2</name></expr>;</expr_stmt> <comment type="line">// TR</comment>
            <expr_stmt><expr><name><name>uvs0</name><index>[<expr><literal type="number">3</literal> <operator>+</operator> <name>index</name></expr>]</index></name> <operator>=</operator> <name>uv3</name></expr>;</expr_stmt> <comment type="line">// BR</comment>

            <comment type="line">// Middle Part of the Underline</comment>
            <expr_stmt><expr><name><name>uvs0</name><index>[<expr><literal type="number">4</literal> <operator>+</operator> <name>index</name></expr>]</index></name> <operator>=</operator> <operator>new</operator> <call><name>Vector2</name><argument_list>(<argument><expr><name><name>uv2</name><operator>.</operator><name>x</name></name> <operator>-</operator> <name><name>uv2</name><operator>.</operator><name>x</name></name> <operator>*</operator> <literal type="number">0.001f</literal></expr></argument>, <argument><expr><name><name>uv0</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>uvs0</name><index>[<expr><literal type="number">5</literal> <operator>+</operator> <name>index</name></expr>]</index></name> <operator>=</operator> <operator>new</operator> <call><name>Vector2</name><argument_list>(<argument><expr><name><name>uv2</name><operator>.</operator><name>x</name></name> <operator>-</operator> <name><name>uv2</name><operator>.</operator><name>x</name></name> <operator>*</operator> <literal type="number">0.001f</literal></expr></argument>, <argument><expr><name><name>uv1</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>uvs0</name><index>[<expr><literal type="number">6</literal> <operator>+</operator> <name>index</name></expr>]</index></name> <operator>=</operator> <operator>new</operator> <call><name>Vector2</name><argument_list>(<argument><expr><name><name>uv2</name><operator>.</operator><name>x</name></name> <operator>+</operator> <name><name>uv2</name><operator>.</operator><name>x</name></name> <operator>*</operator> <literal type="number">0.001f</literal></expr></argument>, <argument><expr><name><name>uv1</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>uvs0</name><index>[<expr><literal type="number">7</literal> <operator>+</operator> <name>index</name></expr>]</index></name> <operator>=</operator> <operator>new</operator> <call><name>Vector2</name><argument_list>(<argument><expr><name><name>uv2</name><operator>.</operator><name>x</name></name> <operator>+</operator> <name><name>uv2</name><operator>.</operator><name>x</name></name> <operator>*</operator> <literal type="number">0.001f</literal></expr></argument>, <argument><expr><name><name>uv0</name><operator>.</operator><name>y</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// Right Part of the Underline</comment>
            <expr_stmt><expr><name><name>uvs0</name><index>[<expr><literal type="number">8</literal> <operator>+</operator> <name>index</name></expr>]</index></name> <operator>=</operator> <name>uv5</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>uvs0</name><index>[<expr><literal type="number">9</literal> <operator>+</operator> <name>index</name></expr>]</index></name> <operator>=</operator> <name>uv4</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>uvs0</name><index>[<expr><literal type="number">10</literal> <operator>+</operator> <name>index</name></expr>]</index></name> <operator>=</operator> <name>uv6</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>uvs0</name><index>[<expr><literal type="number">11</literal> <operator>+</operator> <name>index</name></expr>]</index></name> <operator>=</operator> <name>uv7</name></expr>;</expr_stmt>
            <cpp:endregion>#<cpp:directive>endregion</cpp:directive></cpp:endregion>

            <comment type="line">// UNDERLINE UV2</comment>
            <cpp:region>#<cpp:directive>region</cpp:directive> <name>HANDLE</name> <name>UV2</name> <name>-</name> <name>SDF</name> <name>SCALE</name></cpp:region>
            <comment type="line">// UV1 contains Face / Border UV layout.</comment>
            <decl_stmt><decl><type><name>float</name></type> <name>min_UvX</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>float</name></type> <name>max_UvX</name> <init>= <expr><operator>(</operator><name><name>vertices</name><index>[<expr><name>index</name> <operator>+</operator> <literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>x</name> <operator>-</operator> <name><name>start</name><operator>.</operator><name>x</name></name><operator>)</operator> <operator>/</operator> <operator>(</operator><name><name>end</name><operator>.</operator><name>x</name></name> <operator>-</operator> <name><name>start</name><operator>.</operator><name>x</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

            <comment type="line">//Calculate the xScale or how much the UV's are getting stretched on the X axis for the middle section of the underline.</comment>
            <decl_stmt><decl><type><name>float</name></type> <name>xScale</name> <init>= <expr><call><name><name>Mathf</name><operator>.</operator><name>Abs</name></name><argument_list>(<argument><expr><name>sdfScale</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <decl_stmt><decl><type><name><name>Vector2</name><index>[]</index></name></type> <name>uvs2</name> <init>= <expr><name><name>m_textInfo</name><operator>.</operator><name>meshInfo</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>uvs2</name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name><name>uvs2</name><index>[<expr><literal type="number">0</literal> <operator>+</operator> <name>index</name></expr>]</index></name> <operator>=</operator> <call><name>PackUV</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>xScale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>uvs2</name><index>[<expr><literal type="number">1</literal> <operator>+</operator> <name>index</name></expr>]</index></name> <operator>=</operator> <call><name>PackUV</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>xScale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>uvs2</name><index>[<expr><literal type="number">2</literal> <operator>+</operator> <name>index</name></expr>]</index></name> <operator>=</operator> <call><name>PackUV</name><argument_list>(<argument><expr><name>max_UvX</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>xScale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>uvs2</name><index>[<expr><literal type="number">3</literal> <operator>+</operator> <name>index</name></expr>]</index></name> <operator>=</operator> <call><name>PackUV</name><argument_list>(<argument><expr><name>max_UvX</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>xScale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>min_UvX</name> <operator>=</operator> <operator>(</operator><name><name>vertices</name><index>[<expr><name>index</name> <operator>+</operator> <literal type="number">4</literal></expr>]</index></name><operator>.</operator><name>x</name> <operator>-</operator> <name><name>start</name><operator>.</operator><name>x</name></name><operator>)</operator> <operator>/</operator> <operator>(</operator><name><name>end</name><operator>.</operator><name>x</name></name> <operator>-</operator> <name><name>start</name><operator>.</operator><name>x</name></name><operator>)</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>max_UvX</name> <operator>=</operator> <operator>(</operator><name><name>vertices</name><index>[<expr><name>index</name> <operator>+</operator> <literal type="number">6</literal></expr>]</index></name><operator>.</operator><name>x</name> <operator>-</operator> <name><name>start</name><operator>.</operator><name>x</name></name><operator>)</operator> <operator>/</operator> <operator>(</operator><name><name>end</name><operator>.</operator><name>x</name></name> <operator>-</operator> <name><name>start</name><operator>.</operator><name>x</name></name><operator>)</operator></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>uvs2</name><index>[<expr><literal type="number">4</literal> <operator>+</operator> <name>index</name></expr>]</index></name> <operator>=</operator> <call><name>PackUV</name><argument_list>(<argument><expr><name>min_UvX</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>xScale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>uvs2</name><index>[<expr><literal type="number">5</literal> <operator>+</operator> <name>index</name></expr>]</index></name> <operator>=</operator> <call><name>PackUV</name><argument_list>(<argument><expr><name>min_UvX</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>xScale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>uvs2</name><index>[<expr><literal type="number">6</literal> <operator>+</operator> <name>index</name></expr>]</index></name> <operator>=</operator> <call><name>PackUV</name><argument_list>(<argument><expr><name>max_UvX</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>xScale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>uvs2</name><index>[<expr><literal type="number">7</literal> <operator>+</operator> <name>index</name></expr>]</index></name> <operator>=</operator> <call><name>PackUV</name><argument_list>(<argument><expr><name>max_UvX</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>xScale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>min_UvX</name> <operator>=</operator> <operator>(</operator><name><name>vertices</name><index>[<expr><name>index</name> <operator>+</operator> <literal type="number">8</literal></expr>]</index></name><operator>.</operator><name>x</name> <operator>-</operator> <name><name>start</name><operator>.</operator><name>x</name></name><operator>)</operator> <operator>/</operator> <operator>(</operator><name><name>end</name><operator>.</operator><name>x</name></name> <operator>-</operator> <name><name>start</name><operator>.</operator><name>x</name></name><operator>)</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>max_UvX</name> <operator>=</operator> <operator>(</operator><name><name>vertices</name><index>[<expr><name>index</name> <operator>+</operator> <literal type="number">6</literal></expr>]</index></name><operator>.</operator><name>x</name> <operator>-</operator> <name><name>start</name><operator>.</operator><name>x</name></name><operator>)</operator> <operator>/</operator> <operator>(</operator><name><name>end</name><operator>.</operator><name>x</name></name> <operator>-</operator> <name><name>start</name><operator>.</operator><name>x</name></name><operator>)</operator></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>uvs2</name><index>[<expr><literal type="number">8</literal> <operator>+</operator> <name>index</name></expr>]</index></name> <operator>=</operator> <call><name>PackUV</name><argument_list>(<argument><expr><name>min_UvX</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>xScale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>uvs2</name><index>[<expr><literal type="number">9</literal> <operator>+</operator> <name>index</name></expr>]</index></name> <operator>=</operator> <call><name>PackUV</name><argument_list>(<argument><expr><name>min_UvX</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>xScale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>uvs2</name><index>[<expr><literal type="number">10</literal> <operator>+</operator> <name>index</name></expr>]</index></name> <operator>=</operator> <call><name>PackUV</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>xScale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>uvs2</name><index>[<expr><literal type="number">11</literal> <operator>+</operator> <name>index</name></expr>]</index></name> <operator>=</operator> <call><name>PackUV</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>xScale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <cpp:endregion>#<cpp:directive>endregion</cpp:directive></cpp:endregion>

            <comment type="line">// UNDERLINE VERTEX COLORS</comment>
            <cpp:region>#<cpp:directive>region</cpp:directive></cpp:region>
            <comment type="line">// Alpha is the lower of the vertex color or tag color alpha used.</comment>
            <expr_stmt><expr><name><name>underlineColor</name><operator>.</operator><name>a</name></name> <operator>=</operator> <ternary><condition><expr><name><name>m_fontColor32</name><operator>.</operator><name>a</name></name> <operator>&lt;</operator> <name><name>underlineColor</name><operator>.</operator><name>a</name></name></expr> ?</condition><then> <expr><call>(<name>byte</name>)<argument_list>(<argument><expr><name><name>m_fontColor32</name><operator>.</operator><name>a</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call>(<name>byte</name>)<argument_list>(<argument><expr><name><name>underlineColor</name><operator>.</operator><name>a</name></name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

            <decl_stmt><decl><type><name><name>Color32</name><index>[]</index></name></type> <name>colors32</name> <init>= <expr><name><name>m_textInfo</name><operator>.</operator><name>meshInfo</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>colors32</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>colors32</name><index>[<expr><literal type="number">0</literal> <operator>+</operator> <name>index</name></expr>]</index></name> <operator>=</operator> <name>underlineColor</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>colors32</name><index>[<expr><literal type="number">1</literal> <operator>+</operator> <name>index</name></expr>]</index></name> <operator>=</operator> <name>underlineColor</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>colors32</name><index>[<expr><literal type="number">2</literal> <operator>+</operator> <name>index</name></expr>]</index></name> <operator>=</operator> <name>underlineColor</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>colors32</name><index>[<expr><literal type="number">3</literal> <operator>+</operator> <name>index</name></expr>]</index></name> <operator>=</operator> <name>underlineColor</name></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>colors32</name><index>[<expr><literal type="number">4</literal> <operator>+</operator> <name>index</name></expr>]</index></name> <operator>=</operator> <name>underlineColor</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>colors32</name><index>[<expr><literal type="number">5</literal> <operator>+</operator> <name>index</name></expr>]</index></name> <operator>=</operator> <name>underlineColor</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>colors32</name><index>[<expr><literal type="number">6</literal> <operator>+</operator> <name>index</name></expr>]</index></name> <operator>=</operator> <name>underlineColor</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>colors32</name><index>[<expr><literal type="number">7</literal> <operator>+</operator> <name>index</name></expr>]</index></name> <operator>=</operator> <name>underlineColor</name></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>colors32</name><index>[<expr><literal type="number">8</literal> <operator>+</operator> <name>index</name></expr>]</index></name> <operator>=</operator> <name>underlineColor</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>colors32</name><index>[<expr><literal type="number">9</literal> <operator>+</operator> <name>index</name></expr>]</index></name> <operator>=</operator> <name>underlineColor</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>colors32</name><index>[<expr><literal type="number">10</literal> <operator>+</operator> <name>index</name></expr>]</index></name> <operator>=</operator> <name>underlineColor</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>colors32</name><index>[<expr><literal type="number">11</literal> <operator>+</operator> <name>index</name></expr>]</index></name> <operator>=</operator> <name>underlineColor</name></expr>;</expr_stmt>
            <cpp:endregion>#<cpp:directive>endregion</cpp:directive></cpp:endregion>

            <expr_stmt><expr><name>index</name> <operator>+=</operator> <literal type="number">12</literal></expr>;</expr_stmt>
        }</block></function>


        <function><specifier>protected</specifier> <specifier>virtual</specifier> <type><name>void</name></type> <name>DrawTextHighlight</name><parameter_list>(<parameter><decl><type><name>Vector3</name></type> <name>start</name></decl></parameter>, <parameter><decl><type><name>Vector3</name></type> <name>end</name></decl></parameter>, <parameter><decl><type><modifier>ref</modifier> <name>int</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>Color32</name></type> <name>highlightColor</name></decl></parameter>)</parameter_list>
        <block>{
            <if>if <condition>(<expr><name>m_cached_Underline_GlyphInfo</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then>
            <block>{
                <if>if <condition>(<expr><operator>!</operator><name><name>TMP_Settings</name><operator>.</operator><name>warningsDisabled</name></name></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><call><name><name>Debug</name><operator>.</operator><name>LogWarning</name></name><argument_list>(<argument><expr><literal type="string">"Unable to add underline since the Font Asset doesn't contain the underline character."</literal></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block></then></if>
                <return>return;</return>
            }</block></then></if>

            <decl_stmt><decl><type><name>int</name></type> <name>verticesCount</name> <init>= <expr><name>index</name> <operator>+</operator> <literal type="number">4</literal></expr></init></decl>;</decl_stmt>
            <comment type="line">// Check to make sure our current mesh buffer allocations can hold these new Quads.</comment>
            <if>if <condition>(<expr><name>verticesCount</name> <operator>&gt;</operator> <name><name>m_textInfo</name><operator>.</operator><name>meshInfo</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>vertices</name><operator>.</operator><name>Length</name></name></expr>)</condition><then>
            <block>{
                <comment type="line">// Resize Mesh Buffers</comment>
                <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>meshInfo</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><call><name>ResizeMeshInfo</name><argument_list>(<argument><expr><name>verticesCount</name> <operator>/</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>

            <comment type="line">// UNDERLINE VERTICES FOR (3) LINE SEGMENTS</comment>
            <cpp:region>#<cpp:directive>region</cpp:directive> <name>HIGHLIGHT</name> <name>VERTICES</name></cpp:region>
            <decl_stmt><decl><type><name><name>Vector3</name><index>[]</index></name></type> <name>vertices</name> <init>= <expr><name><name>m_textInfo</name><operator>.</operator><name>meshInfo</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>vertices</name></expr></init></decl>;</decl_stmt>

            <comment type="line">// Front Part of the Underline</comment>
            <expr_stmt><expr><name><name>vertices</name><index>[<expr><name>index</name> <operator>+</operator> <literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>start</name></expr>;</expr_stmt> <comment type="line">// BL</comment>
            <expr_stmt><expr><name><name>vertices</name><index>[<expr><name>index</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>new</operator> <call><name>Vector3</name><argument_list>(<argument><expr><name><name>start</name><operator>.</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>end</name><operator>.</operator><name>y</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// TL</comment>
            <expr_stmt><expr><name><name>vertices</name><index>[<expr><name>index</name> <operator>+</operator> <literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>end</name></expr>;</expr_stmt> <comment type="line">// TR</comment>
            <expr_stmt><expr><name><name>vertices</name><index>[<expr><name>index</name> <operator>+</operator> <literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <operator>new</operator> <call><name>Vector3</name><argument_list>(<argument><expr><name><name>end</name><operator>.</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>start</name><operator>.</operator><name>y</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// BR</comment>
            <cpp:endregion>#<cpp:directive>endregion</cpp:directive></cpp:endregion>

            <comment type="line">// UNDERLINE UV0</comment>
            <cpp:region>#<cpp:directive>region</cpp:directive> <name>HANDLE</name> <name>UV0</name></cpp:region>
            <decl_stmt><decl><type><name><name>Vector2</name><index>[]</index></name></type> <name>uvs0</name> <init>= <expr><name><name>m_textInfo</name><operator>.</operator><name>meshInfo</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>uvs0</name></expr></init></decl>;</decl_stmt>

            <comment type="line">// Calculate UV required to setup the 3 Quads for the Underline.</comment>
            <decl_stmt><decl><type><name>Vector2</name></type> <name>uv0</name> <init>= <expr><operator>new</operator> <call><name>Vector2</name><argument_list>(<argument><expr><operator>(</operator><name><name>m_cached_Underline_GlyphInfo</name><operator>.</operator><name>x</name></name> <operator>+</operator> <name><name>m_cached_Underline_GlyphInfo</name><operator>.</operator><name>width</name></name> <operator>/</operator> <literal type="number">2</literal><operator>)</operator> <operator>/</operator> <name><name>m_fontAsset</name><operator>.</operator><name>fontInfo</name><operator>.</operator><name>AtlasWidth</name></name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>-</operator> <operator>(</operator><name><name>m_cached_Underline_GlyphInfo</name><operator>.</operator><name>y</name></name> <operator>+</operator> <name><name>m_cached_Underline_GlyphInfo</name><operator>.</operator><name>height</name></name> <operator>/</operator> <literal type="number">2</literal><operator>)</operator> <operator>/</operator> <name><name>m_fontAsset</name><operator>.</operator><name>fontInfo</name><operator>.</operator><name>AtlasHeight</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>  <comment type="line">// bottom left</comment>
            <comment type="line">//Vector2 uv1 = new Vector2(uv0.x, uv0.y);  // top left</comment>
            <comment type="line">//Vector2 uv2 = new Vector2(uv0.x, uv0.y); // Top Right</comment>
            <comment type="line">//Vector2 uv3 = new Vector2(uv2.x, uv0.y); // Bottom Right</comment>

            <comment type="line">// Left Part of the Underline</comment>
            <expr_stmt><expr><name><name>uvs0</name><index>[<expr><literal type="number">0</literal> <operator>+</operator> <name>index</name></expr>]</index></name> <operator>=</operator> <name>uv0</name></expr>;</expr_stmt> <comment type="line">// BL</comment>
            <expr_stmt><expr><name><name>uvs0</name><index>[<expr><literal type="number">1</literal> <operator>+</operator> <name>index</name></expr>]</index></name> <operator>=</operator> <name>uv0</name></expr>;</expr_stmt> <comment type="line">// TL</comment>
            <expr_stmt><expr><name><name>uvs0</name><index>[<expr><literal type="number">2</literal> <operator>+</operator> <name>index</name></expr>]</index></name> <operator>=</operator> <name>uv0</name></expr>;</expr_stmt> <comment type="line">// TR</comment>
            <expr_stmt><expr><name><name>uvs0</name><index>[<expr><literal type="number">3</literal> <operator>+</operator> <name>index</name></expr>]</index></name> <operator>=</operator> <name>uv0</name></expr>;</expr_stmt> <comment type="line">// BR</comment>
            <cpp:endregion>#<cpp:directive>endregion</cpp:directive></cpp:endregion>

            <comment type="line">// UNDERLINE UV2</comment>
            <cpp:region>#<cpp:directive>region</cpp:directive> <name>HANDLE</name> <name>UV2</name> <name>-</name> <name>SDF</name> <name>SCALE</name></cpp:region>
            <comment type="line">// UV1 contains Face / Border UV layout.</comment>
            <comment type="line">//float min_UvX = 0;</comment>
            <comment type="line">//float max_UvX = (vertices[index + 2].x - start.x) / (end.x - start.x);</comment>

            <comment type="line">////Calculate the xScale or how much the UV's are getting stretched on the X axis for the middle section of the underline.</comment>
            <comment type="line">//float xScale = 0; // Mathf.Abs(sdfScale);</comment>

            <decl_stmt><decl><type><name><name>Vector2</name><index>[]</index></name></type> <name>uvs2</name> <init>= <expr><name><name>m_textInfo</name><operator>.</operator><name>meshInfo</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>uvs2</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Vector2</name></type> <name>customUV</name> <init>= <expr><operator>new</operator> <call><name>Vector2</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>uvs2</name><index>[<expr><literal type="number">0</literal> <operator>+</operator> <name>index</name></expr>]</index></name> <operator>=</operator> <name>customUV</name></expr>;</expr_stmt> <comment type="line">// PackUV(-0.2f, -0.2f, xScale);</comment>
            <expr_stmt><expr><name><name>uvs2</name><index>[<expr><literal type="number">1</literal> <operator>+</operator> <name>index</name></expr>]</index></name> <operator>=</operator> <name>customUV</name></expr>;</expr_stmt> <comment type="line">// PackUV(-0.2f, -0.1f, xScale);</comment>
            <expr_stmt><expr><name><name>uvs2</name><index>[<expr><literal type="number">2</literal> <operator>+</operator> <name>index</name></expr>]</index></name> <operator>=</operator> <name>customUV</name></expr>;</expr_stmt> <comment type="line">// PackUV(-0.1f, -0.1f, xScale);</comment>
            <expr_stmt><expr><name><name>uvs2</name><index>[<expr><literal type="number">3</literal> <operator>+</operator> <name>index</name></expr>]</index></name> <operator>=</operator> <name>customUV</name></expr>;</expr_stmt> <comment type="line">// PackUV(-0.1f, -0.2f, xScale);</comment>
            <cpp:endregion>#<cpp:directive>endregion</cpp:directive></cpp:endregion>

            <comment type="line">// HIGHLIGHT VERTEX COLORS</comment>
            <cpp:region>#<cpp:directive>region</cpp:directive></cpp:region>
            <comment type="line">// Alpha is the lower of the vertex color or tag color alpha used.</comment>
            <expr_stmt><expr><name><name>highlightColor</name><operator>.</operator><name>a</name></name> <operator>=</operator> <ternary><condition><expr><name><name>m_fontColor32</name><operator>.</operator><name>a</name></name> <operator>&lt;</operator> <name><name>highlightColor</name><operator>.</operator><name>a</name></name></expr> ?</condition><then> <expr><name><name>m_fontColor32</name><operator>.</operator><name>a</name></name></expr> </then><else>: <expr><name><name>highlightColor</name><operator>.</operator><name>a</name></name></expr></else></ternary></expr>;</expr_stmt>

            <decl_stmt><decl><type><name><name>Color32</name><index>[]</index></name></type> <name>colors32</name> <init>= <expr><name><name>m_textInfo</name><operator>.</operator><name>meshInfo</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>colors32</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>colors32</name><index>[<expr><literal type="number">0</literal> <operator>+</operator> <name>index</name></expr>]</index></name> <operator>=</operator> <name>highlightColor</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>colors32</name><index>[<expr><literal type="number">1</literal> <operator>+</operator> <name>index</name></expr>]</index></name> <operator>=</operator> <name>highlightColor</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>colors32</name><index>[<expr><literal type="number">2</literal> <operator>+</operator> <name>index</name></expr>]</index></name> <operator>=</operator> <name>highlightColor</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>colors32</name><index>[<expr><literal type="number">3</literal> <operator>+</operator> <name>index</name></expr>]</index></name> <operator>=</operator> <name>highlightColor</name></expr>;</expr_stmt>
            <cpp:endregion>#<cpp:directive>endregion</cpp:directive></cpp:endregion>

            <expr_stmt><expr><name>index</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
        }</block></function>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Internal function used to load the default settings of text objects.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <function><specifier>protected</specifier> <type><name>void</name></type> <name>LoadDefaultSettings</name><parameter_list>()</parameter_list>
        <block>{
            <if>if <condition>(<expr><name>m_text</name> <operator>==</operator> <literal type="null">null</literal> <operator>||</operator> <name>m_isWaitingOnResourceLoad</name></expr>)</condition><then>
            <block>{
                <if>if <condition>(<expr><name><name>TMP_Settings</name><operator>.</operator><name>autoSizeTextContainer</name></name></expr>)</condition><then>
                    <block type="pseudo"><expr_stmt><expr><name>autoSizeTextContainer</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt></block></then>
                <else>else
                <block>{
                    <expr_stmt><expr><name>m_rectTransform</name> <operator>=</operator> <name><name>this</name><operator>.</operator><name>rectTransform</name></name></expr>;</expr_stmt>

                    <if>if <condition>(<expr><call><name>GetType</name><argument_list>()</argument_list></call> <operator>==</operator> <typeof>typeof<argument_list>(<argument><expr><name>TextMeshPro</name></expr></argument>)</argument_list></typeof></expr>)</condition><then>
                        <block type="pseudo"><expr_stmt><expr><name><name>m_rectTransform</name><operator>.</operator><name>sizeDelta</name></name> <operator>=</operator> <name><name>TMP_Settings</name><operator>.</operator><name>defaultTextMeshProTextContainerSize</name></name></expr>;</expr_stmt></block></then>
                    <else>else
                        <block type="pseudo"><expr_stmt><expr><name><name>m_rectTransform</name><operator>.</operator><name>sizeDelta</name></name> <operator>=</operator> <name><name>TMP_Settings</name><operator>.</operator><name>defaultTextMeshProUITextContainerSize</name></name></expr>;</expr_stmt></block></else></if>
                }</block></else></if>

                <expr_stmt><expr><name>m_enableWordWrapping</name> <operator>=</operator> <name><name>TMP_Settings</name><operator>.</operator><name>enableWordWrapping</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>m_enableKerning</name> <operator>=</operator> <name><name>TMP_Settings</name><operator>.</operator><name>enableKerning</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>m_enableExtraPadding</name> <operator>=</operator> <name><name>TMP_Settings</name><operator>.</operator><name>enableExtraPadding</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>m_tintAllSprites</name> <operator>=</operator> <name><name>TMP_Settings</name><operator>.</operator><name>enableTintAllSprites</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>m_parseCtrlCharacters</name> <operator>=</operator> <name><name>TMP_Settings</name><operator>.</operator><name>enableParseEscapeCharacters</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>m_fontSize</name> <operator>=</operator> <name>m_fontSizeBase</name> <operator>=</operator> <name><name>TMP_Settings</name><operator>.</operator><name>defaultFontSize</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>m_fontSizeMin</name> <operator>=</operator> <name>m_fontSize</name> <operator>*</operator> <name><name>TMP_Settings</name><operator>.</operator><name>defaultTextAutoSizingMinRatio</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>m_fontSizeMax</name> <operator>=</operator> <name>m_fontSize</name> <operator>*</operator> <name><name>TMP_Settings</name><operator>.</operator><name>defaultTextAutoSizingMaxRatio</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>m_isAlignmentEnumConverted</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>m_isWaitingOnResourceLoad</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
            }</block></then>
            <elseif>else <if>if <condition>(<expr><name>m_isAlignmentEnumConverted</name> <operator>==</operator> <literal type="boolean">false</literal></expr>)</condition><then>
            <block>{
                <comment type="line">// Convert TextAlignmentOptions enumerations.</comment>
                <expr_stmt><expr><name>m_isAlignmentEnumConverted</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>m_textAlignment</name> <operator>=</operator> <call><name><name>TMP_Compatibility</name><operator>.</operator><name>ConvertTextAlignmentEnumValues</name></name><argument_list>(<argument><expr><name>m_textAlignment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if></elseif></if>
        }</block></function>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Method used to find and cache references to the Underline and Ellipsis characters.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;param name=""&gt;&lt;/param&gt;</comment>
        <function><specifier>protected</specifier> <type><name>void</name></type> <name>GetSpecialCharacters</name><parameter_list>(<parameter><decl><type><name>TMP_FontAsset</name></type> <name>fontAsset</name></decl></parameter>)</parameter_list>
        <block>{
            <comment type="line">// Check &amp; Assign Underline Character for use with the Underline tag.</comment>
            <if>if <condition>(<expr><operator>!</operator><call><name><name>fontAsset</name><operator>.</operator><name>characterDictionary</name><operator>.</operator><name>TryGetValue</name></name><argument_list>(<argument><expr><literal type="number">95</literal></expr></argument>, <argument><modifier>out</modifier> <expr><name>m_cached_Underline_GlyphInfo</name></expr></argument>)</argument_list></call></expr>)</condition><then> <comment type="line">//95</comment>
            <block>{
                <comment type="line">// Check fallback fonts</comment>
                <comment type="line">// TODO</comment>
            }</block></then></if>

            <comment type="line">// Check &amp; Assign Underline Character for use with the Underline tag.</comment>
            <if>if <condition>(<expr><operator>!</operator><call><name><name>fontAsset</name><operator>.</operator><name>characterDictionary</name><operator>.</operator><name>TryGetValue</name></name><argument_list>(<argument><expr><literal type="number">8230</literal></expr></argument>, <argument><modifier>out</modifier> <expr><name>m_cached_Ellipsis_GlyphInfo</name></expr></argument>)</argument_list></call></expr>)</condition><then> <comment type="line">//95</comment>
            <block>{
                <comment type="line">// Check fallback fonts</comment>
                <comment type="line">// TODO</comment>
            }</block></then></if>
        }</block></function>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Replace a given number of characters (tag) in the array with a new character and shift subsequent characters in the array.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;param name="chars"&gt;Array which contains the text.&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="insertionIndex"&gt;The index of where the new character will be inserted&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="tagLength"&gt;Length of the tag being replaced.&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="c"&gt;The replacement character.&lt;/param&gt;</comment>
        <function><specifier>protected</specifier> <type><name>void</name></type> <name>ReplaceTagWithCharacter</name><parameter_list>(<parameter><decl><type><name><name>int</name><index>[]</index></name></type> <name>chars</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>insertionIndex</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tagLength</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>c</name></decl></parameter>)</parameter_list>
        <block>{
            <expr_stmt><expr><name><name>chars</name><index>[<expr><name>insertionIndex</name></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>

            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>insertionIndex</name> <operator>+</operator> <name>tagLength</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>chars</name><operator>.</operator><name>Length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{
                <expr_stmt><expr><name><name>chars</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
            }</block></for>
        }</block></function>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// </comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;returns&gt;&lt;/returns&gt;</comment>
        <comment type="line">//protected int GetMaterialReferenceForFontWeight()</comment>
        <comment type="line">//{</comment>
        <comment type="line">//    //bool isItalic = (m_style &amp; FontStyles.Italic) == FontStyles.Italic || (m_fontStyle &amp; FontStyles.Italic) == FontStyles.Italic;</comment>

        <comment type="line">//    m_currentMaterialIndex = MaterialReference.AddMaterialReference(m_currentFontAsset.fontWeights[0].italicTypeface.material, m_currentFontAsset.fontWeights[0].italicTypeface, m_materialReferences, m_materialReferenceIndexLookup);</comment>

        <comment type="line">//    return 0;</comment>
        <comment type="line">//}</comment>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// </comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;returns&gt;&lt;/returns&gt;</comment>
        <function><specifier>protected</specifier> <type><name>TMP_FontAsset</name></type> <name>GetFontAssetForWeight</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fontWeight</name></decl></parameter>)</parameter_list>
        <block>{
            <decl_stmt><decl><type><name>bool</name></type> <name>isItalic</name> <init>= <expr><operator>(</operator><name>m_style</name> <operator>&amp;</operator> <name><name>FontStyles</name><operator>.</operator><name>Italic</name></name><operator>)</operator> <operator>==</operator> <name><name>FontStyles</name><operator>.</operator><name>Italic</name></name> <operator>||</operator> <operator>(</operator><name>m_fontStyle</name> <operator>&amp;</operator> <name><name>FontStyles</name><operator>.</operator><name>Italic</name></name><operator>)</operator> <operator>==</operator> <name><name>FontStyles</name><operator>.</operator><name>Italic</name></name></expr></init></decl>;</decl_stmt>

            <decl_stmt><decl><type><name>TMP_FontAsset</name></type> <name>fontAsset</name> <init>= <expr><literal type="null">null</literal></expr></init></decl>;</decl_stmt>

            <decl_stmt><decl><type><name>int</name></type> <name>weightIndex</name> <init>= <expr><name>fontWeight</name> <operator>/</operator> <literal type="number">100</literal></expr></init></decl>;</decl_stmt>

            <if>if <condition>(<expr><name>isItalic</name></expr>)</condition><then>
                <block type="pseudo"><expr_stmt><expr><name>fontAsset</name> <operator>=</operator> <name><name>m_currentFontAsset</name><operator>.</operator><name>fontWeights</name><index>[<expr><name>weightIndex</name></expr>]</index></name><operator>.</operator><name>italicTypeface</name></expr>;</expr_stmt></block></then>
            <else>else
                <block type="pseudo"><expr_stmt><expr><name>fontAsset</name> <operator>=</operator> <name><name>m_currentFontAsset</name><operator>.</operator><name>fontWeights</name><index>[<expr><name>weightIndex</name></expr>]</index></name><operator>.</operator><name>regularTypeface</name></expr>;</expr_stmt></block></else></if>

            <return>return <expr><name>fontAsset</name></expr>;</return>
        }</block></function>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Method to Enable or Disable child SubMesh objects.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;param name="state"&gt;&lt;/param&gt;</comment>
        <function><specifier>protected</specifier> <specifier>virtual</specifier> <type><name>void</name></type> <name>SetActiveSubMeshes</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>state</name></decl></parameter>)</parameter_list> <block>{ }</block></function>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Destroy Sub Mesh Objects.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <function><specifier>protected</specifier> <specifier>virtual</specifier> <type><name>void</name></type> <name>ClearSubMeshObjects</name><parameter_list>()</parameter_list> <block>{ }</block></function>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Function to clear the geometry of the Primary and Sub Text objects.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <function><specifier>public</specifier> <specifier>virtual</specifier> <type><name>void</name></type> <name>ClearMesh</name><parameter_list>()</parameter_list> <block>{ }</block></function>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Function to clear the geometry of the Primary and Sub Text objects.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <function><specifier>public</specifier> <specifier>virtual</specifier> <type><name>void</name></type> <name>ClearMesh</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>uploadGeometry</name></decl></parameter>)</parameter_list> <block>{ }</block></function>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Function which returns the text after it has been parsed and rich text tags removed.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;returns&gt;&lt;/returns&gt;</comment>
        <function><specifier>public</specifier> <specifier>virtual</specifier> <type><name>string</name></type> <name>GetParsedText</name><parameter_list>()</parameter_list>
        <block>{
            <if>if <condition>(<expr><name>m_textInfo</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then>
                <block type="pseudo"><return>return <expr><name><name>string</name><operator>.</operator><name>Empty</name></name></expr>;</return></block></then></if>

            <decl_stmt><decl><type><name>int</name></type> <name>characterCount</name> <init>= <expr><name><name>m_textInfo</name><operator>.</operator><name>characterCount</name></name></expr></init></decl>;</decl_stmt>

            <comment type="line">// TODO - Could implement some static buffer pool shared by all instances of TMP objects.</comment>
            <decl_stmt><decl><type><name><name>char</name><index>[]</index></name></type> <name>buffer</name> <init>= <expr><operator>new</operator> <name><name>char</name><index>[<expr><name>characterCount</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>characterCount</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name><name>m_textInfo</name><operator>.</operator><name>characterInfo</name><operator>.</operator><name>Length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{
                <expr_stmt><expr><name><name>buffer</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>m_textInfo</name><operator>.</operator><name>characterInfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>character</name></expr>;</expr_stmt>
            }</block></for>

            <return>return <expr><operator>new</operator> <call><name>string</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></function>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Function to pack scale information in the UV2 Channel.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;param name="x"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="y"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="scale"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;returns&gt;&lt;/returns&gt;</comment>
        <comment type="line">//protected Vector2 PackUV(float x, float y, float scale)</comment>
        <comment type="line">//{</comment>
        <comment type="line">//    Vector2 output;</comment>

        <comment type="line">//    output.x = Mathf.Floor(x * 4095);</comment>
        <comment type="line">//    output.y = Mathf.Floor(y * 4095);</comment>

        <comment type="line">//    output.x = (output.x * 4096) + output.y;</comment>
        <comment type="line">//    output.y = scale;</comment>

        <comment type="line">//    return output;</comment>
        <comment type="line">//}</comment>

        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Function to pack scale information in the UV2 Channel.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;param name="x"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="y"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="scale"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;returns&gt;&lt;/returns&gt;</comment>
        <function><specifier>protected</specifier> <type><name>Vector2</name></type> <name>PackUV</name><parameter_list>(<parameter><decl><type><name>float</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>y</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>scale</name></decl></parameter>)</parameter_list>
        <block>{
            <decl_stmt><decl><type><name>Vector2</name></type> <name>output</name></decl>;</decl_stmt>

            <expr_stmt><expr><name><name>output</name><operator>.</operator><name>x</name></name> <operator>=</operator> <call>(<name>int</name>)<argument_list>(<argument><expr><name>x</name> <operator>*</operator> <literal type="number">511</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>output</name><operator>.</operator><name>y</name></name> <operator>=</operator> <call>(<name>int</name>)<argument_list>(<argument><expr><name>y</name> <operator>*</operator> <literal type="number">511</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>output</name><operator>.</operator><name>x</name></name> <operator>=</operator> <operator>(</operator><name><name>output</name><operator>.</operator><name>x</name></name> <operator>*</operator> <literal type="number">4096</literal><operator>)</operator> <operator>+</operator> <name><name>output</name><operator>.</operator><name>y</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>output</name><operator>.</operator><name>y</name></name> <operator>=</operator> <name>scale</name></expr>;</expr_stmt>

            <return>return <expr><name>output</name></expr>;</return>
        }</block></function>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// </comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;param name="x"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="y"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;returns&gt;&lt;/returns&gt;</comment>
        <function><specifier>protected</specifier> <type><name>float</name></type> <name>PackUV</name><parameter_list>(<parameter><decl><type><name>float</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>y</name></decl></parameter>)</parameter_list>
        <block>{
            <decl_stmt><decl><type><name>double</name></type> <name>x0</name> <init>= <expr><call>(<name>int</name>)<argument_list>(<argument><expr><name>x</name> <operator>*</operator> <literal type="number">511</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>double</name></type> <name>y0</name> <init>= <expr><call>(<name>int</name>)<argument_list>(<argument><expr><name>y</name> <operator>*</operator> <literal type="number">511</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <return>return <expr><call>(<name>float</name>)<argument_list>(<argument><expr><operator>(</operator><name>x0</name> <operator>*</operator> <literal type="number">4096</literal><operator>)</operator> <operator>+</operator> <name>y0</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></function>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Function to pack scale information in the UV2 Channel.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;param name="x"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="y"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="scale"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;returns&gt;&lt;/returns&gt;</comment>
        <comment type="line">//protected Vector2 PackUV(float x, float y, float scale)</comment>
        <comment type="line">//{</comment>
        <comment type="line">//    Vector2 output;</comment>

        <comment type="line">//    output.x = Mathf.Floor(x * 4095);</comment>
        <comment type="line">//    output.y = Mathf.Floor(y * 4095);</comment>

        <comment type="line">//    return new Vector2((output.x * 4096) + output.y, scale);</comment>
        <comment type="line">//}</comment>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// </comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;param name="x"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="y"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;returns&gt;&lt;/returns&gt;</comment>
        <comment type="line">//protected float PackUV(float x, float y)</comment>
        <comment type="line">//{</comment>
        <comment type="line">//    x = (x % 5) / 5;</comment>
        <comment type="line">//    y = (y % 5) / 5;</comment>

        <comment type="line">//    return Mathf.Round(x * 4096) + y;</comment>
        <comment type="line">//}</comment>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Method to convert Hex to Int</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;param name="hex"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;returns&gt;&lt;/returns&gt;</comment>
        <function><specifier>protected</specifier> <type><name>int</name></type> <name>HexToInt</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>hex</name></decl></parameter>)</parameter_list>
        <block>{
            <switch>switch <condition>(<expr><name>hex</name></expr>)</condition>
            <block>{
                <case>case <expr><literal type="char">'0'</literal></expr>:</case> <return>return <expr><literal type="number">0</literal></expr>;</return>
                <case>case <expr><literal type="char">'1'</literal></expr>:</case> <return>return <expr><literal type="number">1</literal></expr>;</return>
                <case>case <expr><literal type="char">'2'</literal></expr>:</case> <return>return <expr><literal type="number">2</literal></expr>;</return>
                <case>case <expr><literal type="char">'3'</literal></expr>:</case> <return>return <expr><literal type="number">3</literal></expr>;</return>
                <case>case <expr><literal type="char">'4'</literal></expr>:</case> <return>return <expr><literal type="number">4</literal></expr>;</return>
                <case>case <expr><literal type="char">'5'</literal></expr>:</case> <return>return <expr><literal type="number">5</literal></expr>;</return>
                <case>case <expr><literal type="char">'6'</literal></expr>:</case> <return>return <expr><literal type="number">6</literal></expr>;</return>
                <case>case <expr><literal type="char">'7'</literal></expr>:</case> <return>return <expr><literal type="number">7</literal></expr>;</return>
                <case>case <expr><literal type="char">'8'</literal></expr>:</case> <return>return <expr><literal type="number">8</literal></expr>;</return>
                <case>case <expr><literal type="char">'9'</literal></expr>:</case> <return>return <expr><literal type="number">9</literal></expr>;</return>
                <case>case <expr><literal type="char">'A'</literal></expr>:</case> <return>return <expr><literal type="number">10</literal></expr>;</return>
                <case>case <expr><literal type="char">'B'</literal></expr>:</case> <return>return <expr><literal type="number">11</literal></expr>;</return>
                <case>case <expr><literal type="char">'C'</literal></expr>:</case> <return>return <expr><literal type="number">12</literal></expr>;</return>
                <case>case <expr><literal type="char">'D'</literal></expr>:</case> <return>return <expr><literal type="number">13</literal></expr>;</return>
                <case>case <expr><literal type="char">'E'</literal></expr>:</case> <return>return <expr><literal type="number">14</literal></expr>;</return>
                <case>case <expr><literal type="char">'F'</literal></expr>:</case> <return>return <expr><literal type="number">15</literal></expr>;</return>
                <case>case <expr><literal type="char">'a'</literal></expr>:</case> <return>return <expr><literal type="number">10</literal></expr>;</return>
                <case>case <expr><literal type="char">'b'</literal></expr>:</case> <return>return <expr><literal type="number">11</literal></expr>;</return>
                <case>case <expr><literal type="char">'c'</literal></expr>:</case> <return>return <expr><literal type="number">12</literal></expr>;</return>
                <case>case <expr><literal type="char">'d'</literal></expr>:</case> <return>return <expr><literal type="number">13</literal></expr>;</return>
                <case>case <expr><literal type="char">'e'</literal></expr>:</case> <return>return <expr><literal type="number">14</literal></expr>;</return>
                <case>case <expr><literal type="char">'f'</literal></expr>:</case> <return>return <expr><literal type="number">15</literal></expr>;</return>
            }</block></switch>
            <return>return <expr><literal type="number">15</literal></expr>;</return>
        }</block></function>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Convert UTF-16 Hex to Char</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;returns&gt;The Unicode hex.&lt;/returns&gt;</comment>
        <comment type="line">/// &lt;param name="i"&gt;The index.&lt;/param&gt;</comment>
        <function><specifier>protected</specifier> <type><name>int</name></type> <name>GetUTF16</name><parameter_list>(<parameter><decl><type><name>string</name></type> <name>text</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list>
        <block>{
            <decl_stmt><decl><type><name>int</name></type> <name>unicode</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>unicode</name> <operator>+=</operator> <call><name>HexToInt</name><argument_list>(<argument><expr><name><name>text</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="number">12</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>unicode</name> <operator>+=</operator> <call><name>HexToInt</name><argument_list>(<argument><expr><name><name>text</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="number">8</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>unicode</name> <operator>+=</operator> <call><name>HexToInt</name><argument_list>(<argument><expr><name><name>text</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="number">4</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>unicode</name> <operator>+=</operator> <call><name>HexToInt</name><argument_list>(<argument><expr><name><name>text</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>unicode</name></expr>;</return>
        }</block></function>

        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Convert UTF-16 Hex to Char</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;returns&gt;The Unicode hex.&lt;/returns&gt;</comment>
        <comment type="line">/// &lt;param name="i"&gt;The index.&lt;/param&gt;</comment>
        <function><specifier>protected</specifier> <type><name>int</name></type> <name>GetUTF16</name><parameter_list>(<parameter><decl><type><name>StringBuilder</name></type> <name>text</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list>
        <block>{
            <decl_stmt><decl><type><name>int</name></type> <name>unicode</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>unicode</name> <operator>+=</operator> <call><name>HexToInt</name><argument_list>(<argument><expr><name><name>text</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="number">12</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>unicode</name> <operator>+=</operator> <call><name>HexToInt</name><argument_list>(<argument><expr><name><name>text</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="number">8</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>unicode</name> <operator>+=</operator> <call><name>HexToInt</name><argument_list>(<argument><expr><name><name>text</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="number">4</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>unicode</name> <operator>+=</operator> <call><name>HexToInt</name><argument_list>(<argument><expr><name><name>text</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>unicode</name></expr>;</return>
        }</block></function>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Convert UTF-32 Hex to Char</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;returns&gt;The Unicode hex.&lt;/returns&gt;</comment>
        <comment type="line">/// &lt;param name="i"&gt;The index.&lt;/param&gt;</comment>
        <function><specifier>protected</specifier> <type><name>int</name></type> <name>GetUTF32</name><parameter_list>(<parameter><decl><type><name>string</name></type> <name>text</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list>
        <block>{
            <decl_stmt><decl><type><name>int</name></type> <name>unicode</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>unicode</name> <operator>+=</operator> <call><name>HexToInt</name><argument_list>(<argument><expr><name><name>text</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="number">30</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>unicode</name> <operator>+=</operator> <call><name>HexToInt</name><argument_list>(<argument><expr><name><name>text</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="number">24</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>unicode</name> <operator>+=</operator> <call><name>HexToInt</name><argument_list>(<argument><expr><name><name>text</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="number">20</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>unicode</name> <operator>+=</operator> <call><name>HexToInt</name><argument_list>(<argument><expr><name><name>text</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="number">16</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>unicode</name> <operator>+=</operator> <call><name>HexToInt</name><argument_list>(<argument><expr><name><name>text</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="number">12</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>unicode</name> <operator>+=</operator> <call><name>HexToInt</name><argument_list>(<argument><expr><name><name>text</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">5</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="number">8</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>unicode</name> <operator>+=</operator> <call><name>HexToInt</name><argument_list>(<argument><expr><name><name>text</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">6</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="number">4</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>unicode</name> <operator>+=</operator> <call><name>HexToInt</name><argument_list>(<argument><expr><name><name>text</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">7</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>unicode</name></expr>;</return>
        }</block></function>

        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Convert UTF-32 Hex to Char</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;returns&gt;The Unicode hex.&lt;/returns&gt;</comment>
        <comment type="line">/// &lt;param name="i"&gt;The index.&lt;/param&gt;</comment>
        <function><specifier>protected</specifier> <type><name>int</name></type> <name>GetUTF32</name><parameter_list>(<parameter><decl><type><name>StringBuilder</name></type> <name>text</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list>
        <block>{
            <decl_stmt><decl><type><name>int</name></type> <name>unicode</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>unicode</name> <operator>+=</operator> <call><name>HexToInt</name><argument_list>(<argument><expr><name><name>text</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="number">30</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>unicode</name> <operator>+=</operator> <call><name>HexToInt</name><argument_list>(<argument><expr><name><name>text</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="number">24</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>unicode</name> <operator>+=</operator> <call><name>HexToInt</name><argument_list>(<argument><expr><name><name>text</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="number">20</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>unicode</name> <operator>+=</operator> <call><name>HexToInt</name><argument_list>(<argument><expr><name><name>text</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="number">16</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>unicode</name> <operator>+=</operator> <call><name>HexToInt</name><argument_list>(<argument><expr><name><name>text</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="number">12</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>unicode</name> <operator>+=</operator> <call><name>HexToInt</name><argument_list>(<argument><expr><name><name>text</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">5</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="number">8</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>unicode</name> <operator>+=</operator> <call><name>HexToInt</name><argument_list>(<argument><expr><name><name>text</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">6</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="number">4</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>unicode</name> <operator>+=</operator> <call><name>HexToInt</name><argument_list>(<argument><expr><name><name>text</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">7</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>unicode</name></expr>;</return>
        }</block></function>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Method to convert Hex color values to Color32</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;param name="hexChars"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="tagCount"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;returns&gt;&lt;/returns&gt;</comment>
        <function><specifier>protected</specifier> <type><name>Color32</name></type> <name>HexCharsToColor</name><parameter_list>(<parameter><decl><type><name><name>char</name><index>[]</index></name></type> <name>hexChars</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tagCount</name></decl></parameter>)</parameter_list>
        <block>{
            <if>if <condition>(<expr><name>tagCount</name> <operator>==</operator> <literal type="number">4</literal></expr>)</condition><then>
            <block>{
                <decl_stmt><decl><type><name>byte</name></type> <name>r</name> <init>= <expr><call>(<name>byte</name>)<argument_list>(<argument><expr><call><name>HexToInt</name><argument_list>(<argument><expr><name><name>hexChars</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">16</literal> <operator>+</operator> <call><name>HexToInt</name><argument_list>(<argument><expr><name><name>hexChars</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>byte</name></type> <name>g</name> <init>= <expr><call>(<name>byte</name>)<argument_list>(<argument><expr><call><name>HexToInt</name><argument_list>(<argument><expr><name><name>hexChars</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">16</literal> <operator>+</operator> <call><name>HexToInt</name><argument_list>(<argument><expr><name><name>hexChars</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>byte</name></type> <name>b</name> <init>= <expr><call>(<name>byte</name>)<argument_list>(<argument><expr><call><name>HexToInt</name><argument_list>(<argument><expr><name><name>hexChars</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">16</literal> <operator>+</operator> <call><name>HexToInt</name><argument_list>(<argument><expr><name><name>hexChars</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <return>return <expr><operator>new</operator> <call><name>Color32</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>g</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><literal type="number">255</literal></expr></argument>)</argument_list></call></expr>;</return>
            }</block></then>
            <elseif>else <if>if <condition>(<expr><name>tagCount</name> <operator>==</operator> <literal type="number">5</literal></expr>)</condition><then>
            <block>{
                <decl_stmt><decl><type><name>byte</name></type> <name>r</name> <init>= <expr><call>(<name>byte</name>)<argument_list>(<argument><expr><call><name>HexToInt</name><argument_list>(<argument><expr><name><name>hexChars</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">16</literal> <operator>+</operator> <call><name>HexToInt</name><argument_list>(<argument><expr><name><name>hexChars</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>byte</name></type> <name>g</name> <init>= <expr><call>(<name>byte</name>)<argument_list>(<argument><expr><call><name>HexToInt</name><argument_list>(<argument><expr><name><name>hexChars</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">16</literal> <operator>+</operator> <call><name>HexToInt</name><argument_list>(<argument><expr><name><name>hexChars</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>byte</name></type> <name>b</name> <init>= <expr><call>(<name>byte</name>)<argument_list>(<argument><expr><call><name>HexToInt</name><argument_list>(<argument><expr><name><name>hexChars</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">16</literal> <operator>+</operator> <call><name>HexToInt</name><argument_list>(<argument><expr><name><name>hexChars</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>byte</name></type> <name>a</name> <init>= <expr><call>(<name>byte</name>)<argument_list>(<argument><expr><call><name>HexToInt</name><argument_list>(<argument><expr><name><name>hexChars</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">16</literal> <operator>+</operator> <call><name>HexToInt</name><argument_list>(<argument><expr><name><name>hexChars</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <return>return <expr><operator>new</operator> <call><name>Color32</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>g</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</return>
            }</block></then></if></elseif>
            <elseif>else <if>if <condition>(<expr><name>tagCount</name> <operator>==</operator> <literal type="number">7</literal></expr>)</condition><then>
            <block>{
                <decl_stmt><decl><type><name>byte</name></type> <name>r</name> <init>= <expr><call>(<name>byte</name>)<argument_list>(<argument><expr><call><name>HexToInt</name><argument_list>(<argument><expr><name><name>hexChars</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">16</literal> <operator>+</operator> <call><name>HexToInt</name><argument_list>(<argument><expr><name><name>hexChars</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>byte</name></type> <name>g</name> <init>= <expr><call>(<name>byte</name>)<argument_list>(<argument><expr><call><name>HexToInt</name><argument_list>(<argument><expr><name><name>hexChars</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">16</literal> <operator>+</operator> <call><name>HexToInt</name><argument_list>(<argument><expr><name><name>hexChars</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>byte</name></type> <name>b</name> <init>= <expr><call>(<name>byte</name>)<argument_list>(<argument><expr><call><name>HexToInt</name><argument_list>(<argument><expr><name><name>hexChars</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">16</literal> <operator>+</operator> <call><name>HexToInt</name><argument_list>(<argument><expr><name><name>hexChars</name><index>[<expr><literal type="number">6</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <return>return <expr><operator>new</operator> <call><name>Color32</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>g</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><literal type="number">255</literal></expr></argument>)</argument_list></call></expr>;</return>
            }</block></then></if></elseif>
            <elseif>else <if>if <condition>(<expr><name>tagCount</name> <operator>==</operator> <literal type="number">9</literal></expr>)</condition><then>
            <block>{
                <decl_stmt><decl><type><name>byte</name></type> <name>r</name> <init>= <expr><call>(<name>byte</name>)<argument_list>(<argument><expr><call><name>HexToInt</name><argument_list>(<argument><expr><name><name>hexChars</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">16</literal> <operator>+</operator> <call><name>HexToInt</name><argument_list>(<argument><expr><name><name>hexChars</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>byte</name></type> <name>g</name> <init>= <expr><call>(<name>byte</name>)<argument_list>(<argument><expr><call><name>HexToInt</name><argument_list>(<argument><expr><name><name>hexChars</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">16</literal> <operator>+</operator> <call><name>HexToInt</name><argument_list>(<argument><expr><name><name>hexChars</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>byte</name></type> <name>b</name> <init>= <expr><call>(<name>byte</name>)<argument_list>(<argument><expr><call><name>HexToInt</name><argument_list>(<argument><expr><name><name>hexChars</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">16</literal> <operator>+</operator> <call><name>HexToInt</name><argument_list>(<argument><expr><name><name>hexChars</name><index>[<expr><literal type="number">6</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>byte</name></type> <name>a</name> <init>= <expr><call>(<name>byte</name>)<argument_list>(<argument><expr><call><name>HexToInt</name><argument_list>(<argument><expr><name><name>hexChars</name><index>[<expr><literal type="number">7</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">16</literal> <operator>+</operator> <call><name>HexToInt</name><argument_list>(<argument><expr><name><name>hexChars</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <return>return <expr><operator>new</operator> <call><name>Color32</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>g</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</return>
            }</block></then></if></elseif>
            <elseif>else <if>if <condition>(<expr><name>tagCount</name> <operator>==</operator> <literal type="number">10</literal></expr>)</condition><then>
            <block>{
                <decl_stmt><decl><type><name>byte</name></type> <name>r</name> <init>= <expr><call>(<name>byte</name>)<argument_list>(<argument><expr><call><name>HexToInt</name><argument_list>(<argument><expr><name><name>hexChars</name><index>[<expr><literal type="number">7</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">16</literal> <operator>+</operator> <call><name>HexToInt</name><argument_list>(<argument><expr><name><name>hexChars</name><index>[<expr><literal type="number">7</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>byte</name></type> <name>g</name> <init>= <expr><call>(<name>byte</name>)<argument_list>(<argument><expr><call><name>HexToInt</name><argument_list>(<argument><expr><name><name>hexChars</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">16</literal> <operator>+</operator> <call><name>HexToInt</name><argument_list>(<argument><expr><name><name>hexChars</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>byte</name></type> <name>b</name> <init>= <expr><call>(<name>byte</name>)<argument_list>(<argument><expr><call><name>HexToInt</name><argument_list>(<argument><expr><name><name>hexChars</name><index>[<expr><literal type="number">9</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">16</literal> <operator>+</operator> <call><name>HexToInt</name><argument_list>(<argument><expr><name><name>hexChars</name><index>[<expr><literal type="number">9</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <return>return <expr><operator>new</operator> <call><name>Color32</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>g</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><literal type="number">255</literal></expr></argument>)</argument_list></call></expr>;</return>
            }</block></then></if></elseif>
            <elseif>else <if>if <condition>(<expr><name>tagCount</name> <operator>==</operator> <literal type="number">11</literal></expr>)</condition><then>
            <block>{
                <decl_stmt><decl><type><name>byte</name></type> <name>r</name> <init>= <expr><call>(<name>byte</name>)<argument_list>(<argument><expr><call><name>HexToInt</name><argument_list>(<argument><expr><name><name>hexChars</name><index>[<expr><literal type="number">7</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">16</literal> <operator>+</operator> <call><name>HexToInt</name><argument_list>(<argument><expr><name><name>hexChars</name><index>[<expr><literal type="number">7</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>byte</name></type> <name>g</name> <init>= <expr><call>(<name>byte</name>)<argument_list>(<argument><expr><call><name>HexToInt</name><argument_list>(<argument><expr><name><name>hexChars</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">16</literal> <operator>+</operator> <call><name>HexToInt</name><argument_list>(<argument><expr><name><name>hexChars</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>byte</name></type> <name>b</name> <init>= <expr><call>(<name>byte</name>)<argument_list>(<argument><expr><call><name>HexToInt</name><argument_list>(<argument><expr><name><name>hexChars</name><index>[<expr><literal type="number">9</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">16</literal> <operator>+</operator> <call><name>HexToInt</name><argument_list>(<argument><expr><name><name>hexChars</name><index>[<expr><literal type="number">9</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>byte</name></type> <name>a</name> <init>= <expr><call>(<name>byte</name>)<argument_list>(<argument><expr><call><name>HexToInt</name><argument_list>(<argument><expr><name><name>hexChars</name><index>[<expr><literal type="number">10</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">16</literal> <operator>+</operator> <call><name>HexToInt</name><argument_list>(<argument><expr><name><name>hexChars</name><index>[<expr><literal type="number">10</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <return>return <expr><operator>new</operator> <call><name>Color32</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>g</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</return>
            }</block></then></if></elseif>
            <elseif>else <if>if <condition>(<expr><name>tagCount</name> <operator>==</operator> <literal type="number">13</literal></expr>)</condition><then>
            <block>{
                <decl_stmt><decl><type><name>byte</name></type> <name>r</name> <init>= <expr><call>(<name>byte</name>)<argument_list>(<argument><expr><call><name>HexToInt</name><argument_list>(<argument><expr><name><name>hexChars</name><index>[<expr><literal type="number">7</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">16</literal> <operator>+</operator> <call><name>HexToInt</name><argument_list>(<argument><expr><name><name>hexChars</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>byte</name></type> <name>g</name> <init>= <expr><call>(<name>byte</name>)<argument_list>(<argument><expr><call><name>HexToInt</name><argument_list>(<argument><expr><name><name>hexChars</name><index>[<expr><literal type="number">9</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">16</literal> <operator>+</operator> <call><name>HexToInt</name><argument_list>(<argument><expr><name><name>hexChars</name><index>[<expr><literal type="number">10</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>byte</name></type> <name>b</name> <init>= <expr><call>(<name>byte</name>)<argument_list>(<argument><expr><call><name>HexToInt</name><argument_list>(<argument><expr><name><name>hexChars</name><index>[<expr><literal type="number">11</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">16</literal> <operator>+</operator> <call><name>HexToInt</name><argument_list>(<argument><expr><name><name>hexChars</name><index>[<expr><literal type="number">12</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <return>return <expr><operator>new</operator> <call><name>Color32</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>g</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><literal type="number">255</literal></expr></argument>)</argument_list></call></expr>;</return>
            }</block></then></if></elseif>
            <elseif>else <if>if <condition>(<expr><name>tagCount</name> <operator>==</operator> <literal type="number">15</literal></expr>)</condition><then>
            <block>{
                <decl_stmt><decl><type><name>byte</name></type> <name>r</name> <init>= <expr><call>(<name>byte</name>)<argument_list>(<argument><expr><call><name>HexToInt</name><argument_list>(<argument><expr><name><name>hexChars</name><index>[<expr><literal type="number">7</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">16</literal> <operator>+</operator> <call><name>HexToInt</name><argument_list>(<argument><expr><name><name>hexChars</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>byte</name></type> <name>g</name> <init>= <expr><call>(<name>byte</name>)<argument_list>(<argument><expr><call><name>HexToInt</name><argument_list>(<argument><expr><name><name>hexChars</name><index>[<expr><literal type="number">9</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">16</literal> <operator>+</operator> <call><name>HexToInt</name><argument_list>(<argument><expr><name><name>hexChars</name><index>[<expr><literal type="number">10</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>byte</name></type> <name>b</name> <init>= <expr><call>(<name>byte</name>)<argument_list>(<argument><expr><call><name>HexToInt</name><argument_list>(<argument><expr><name><name>hexChars</name><index>[<expr><literal type="number">11</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">16</literal> <operator>+</operator> <call><name>HexToInt</name><argument_list>(<argument><expr><name><name>hexChars</name><index>[<expr><literal type="number">12</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>byte</name></type> <name>a</name> <init>= <expr><call>(<name>byte</name>)<argument_list>(<argument><expr><call><name>HexToInt</name><argument_list>(<argument><expr><name><name>hexChars</name><index>[<expr><literal type="number">13</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">16</literal> <operator>+</operator> <call><name>HexToInt</name><argument_list>(<argument><expr><name><name>hexChars</name><index>[<expr><literal type="number">14</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <return>return <expr><operator>new</operator> <call><name>Color32</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>g</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</return>
            }</block></then></if></elseif></if>

            <return>return <expr><operator>new</operator> <call><name>Color32</name><argument_list>(<argument><expr><literal type="number">255</literal></expr></argument>, <argument><expr><literal type="number">255</literal></expr></argument>, <argument><expr><literal type="number">255</literal></expr></argument>, <argument><expr><literal type="number">255</literal></expr></argument>)</argument_list></call></expr>;</return>
        }</block></function>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Method to convert Hex Color values to Color32</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;param name="hexChars"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="startIndex"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="length"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;returns&gt;&lt;/returns&gt;</comment>
        <function><specifier>protected</specifier> <type><name>Color32</name></type> <name>HexCharsToColor</name><parameter_list>(<parameter><decl><type><name><name>char</name><index>[]</index></name></type> <name>hexChars</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>startIndex</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>length</name></decl></parameter>)</parameter_list>
        <block>{
            <if>if <condition>(<expr><name>length</name> <operator>==</operator> <literal type="number">7</literal></expr>)</condition><then>
            <block>{
                <decl_stmt><decl><type><name>byte</name></type> <name>r</name> <init>= <expr><call>(<name>byte</name>)<argument_list>(<argument><expr><call><name>HexToInt</name><argument_list>(<argument><expr><name><name>hexChars</name><index>[<expr><name>startIndex</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">16</literal> <operator>+</operator> <call><name>HexToInt</name><argument_list>(<argument><expr><name><name>hexChars</name><index>[<expr><name>startIndex</name> <operator>+</operator> <literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>byte</name></type> <name>g</name> <init>= <expr><call>(<name>byte</name>)<argument_list>(<argument><expr><call><name>HexToInt</name><argument_list>(<argument><expr><name><name>hexChars</name><index>[<expr><name>startIndex</name> <operator>+</operator> <literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">16</literal> <operator>+</operator> <call><name>HexToInt</name><argument_list>(<argument><expr><name><name>hexChars</name><index>[<expr><name>startIndex</name> <operator>+</operator> <literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>byte</name></type> <name>b</name> <init>= <expr><call>(<name>byte</name>)<argument_list>(<argument><expr><call><name>HexToInt</name><argument_list>(<argument><expr><name><name>hexChars</name><index>[<expr><name>startIndex</name> <operator>+</operator> <literal type="number">5</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">16</literal> <operator>+</operator> <call><name>HexToInt</name><argument_list>(<argument><expr><name><name>hexChars</name><index>[<expr><name>startIndex</name> <operator>+</operator> <literal type="number">6</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <return>return <expr><operator>new</operator> <call><name>Color32</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>g</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><literal type="number">255</literal></expr></argument>)</argument_list></call></expr>;</return>
            }</block></then>
            <elseif>else <if>if <condition>(<expr><name>length</name> <operator>==</operator> <literal type="number">9</literal></expr>)</condition><then>
            <block>{
                <decl_stmt><decl><type><name>byte</name></type> <name>r</name> <init>= <expr><call>(<name>byte</name>)<argument_list>(<argument><expr><call><name>HexToInt</name><argument_list>(<argument><expr><name><name>hexChars</name><index>[<expr><name>startIndex</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">16</literal> <operator>+</operator> <call><name>HexToInt</name><argument_list>(<argument><expr><name><name>hexChars</name><index>[<expr><name>startIndex</name> <operator>+</operator> <literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>byte</name></type> <name>g</name> <init>= <expr><call>(<name>byte</name>)<argument_list>(<argument><expr><call><name>HexToInt</name><argument_list>(<argument><expr><name><name>hexChars</name><index>[<expr><name>startIndex</name> <operator>+</operator> <literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">16</literal> <operator>+</operator> <call><name>HexToInt</name><argument_list>(<argument><expr><name><name>hexChars</name><index>[<expr><name>startIndex</name> <operator>+</operator> <literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>byte</name></type> <name>b</name> <init>= <expr><call>(<name>byte</name>)<argument_list>(<argument><expr><call><name>HexToInt</name><argument_list>(<argument><expr><name><name>hexChars</name><index>[<expr><name>startIndex</name> <operator>+</operator> <literal type="number">5</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">16</literal> <operator>+</operator> <call><name>HexToInt</name><argument_list>(<argument><expr><name><name>hexChars</name><index>[<expr><name>startIndex</name> <operator>+</operator> <literal type="number">6</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>byte</name></type> <name>a</name> <init>= <expr><call>(<name>byte</name>)<argument_list>(<argument><expr><call><name>HexToInt</name><argument_list>(<argument><expr><name><name>hexChars</name><index>[<expr><name>startIndex</name> <operator>+</operator> <literal type="number">7</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">16</literal> <operator>+</operator> <call><name>HexToInt</name><argument_list>(<argument><expr><name><name>hexChars</name><index>[<expr><name>startIndex</name> <operator>+</operator> <literal type="number">8</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <return>return <expr><operator>new</operator> <call><name>Color32</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>g</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</return>
            }</block></then></if></elseif></if>

            <return>return <expr><name>s_colorWhite</name></expr>;</return>
        }</block></function>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Method which returns the number of parameters used in a tag attribute and populates an array with such values.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;param name="chars"&gt;Char[] containing the tag attribute and data&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="startIndex"&gt;The index of the first char of the data&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="length"&gt;The length of the data&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="parameters"&gt;The number of parameters contained in the Char[]&lt;/param&gt;</comment>
        <comment type="line">/// &lt;returns&gt;&lt;/returns&gt;</comment>
        <function><type><name>int</name></type> <name>GetAttributeParameters</name><parameter_list>(<parameter><decl><type><name><name>char</name><index>[]</index></name></type> <name>chars</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>startIndex</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>length</name></decl></parameter>, <parameter><decl><type><name><modifier>ref</modifier> <name>float</name><index>[]</index></name></type> <name>parameters</name></decl></parameter>)</parameter_list>
        <block>{
            <decl_stmt><decl><type><name>int</name></type> <name>endIndex</name> <init>= <expr><name>startIndex</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>attributeCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

            <while>while <condition>(<expr><name>endIndex</name> <operator>&lt;</operator> <name>startIndex</name> <operator>+</operator> <name>length</name></expr>)</condition>
            <block>{
                <expr_stmt><expr><name><name>parameters</name><index>[<expr><name>attributeCount</name></expr>]</index></name> <operator>=</operator> <call><name>ConvertToFloat</name><argument_list>(<argument><expr><name>chars</name></expr></argument>, <argument><expr><name>startIndex</name></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><modifier>out</modifier> <expr><name>endIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name>length</name> <operator>-=</operator> <operator>(</operator><name>endIndex</name> <operator>-</operator> <name>startIndex</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>startIndex</name> <operator>=</operator> <name>endIndex</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

                <expr_stmt><expr><name>attributeCount</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            }</block></while>

            <return>return <expr><name>attributeCount</name></expr>;</return>
        }</block></function>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Extracts a float value from char[] assuming we know the position of the start, end and decimal point.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;param name="chars"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="startIndex"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="length"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;returns&gt;&lt;/returns&gt;</comment>
        <function><specifier>protected</specifier> <type><name>float</name></type> <name>ConvertToFloat</name><parameter_list>(<parameter><decl><type><name><name>char</name><index>[]</index></name></type> <name>chars</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>startIndex</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>length</name></decl></parameter>)</parameter_list>
        <block>{
            <decl_stmt><decl><type><name>int</name></type> <name>lastIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <return>return <expr><call><name>ConvertToFloat</name><argument_list>(<argument><expr><name>chars</name></expr></argument>, <argument><expr><name>startIndex</name></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><modifier>out</modifier> <expr><name>lastIndex</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></function>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Extracts a float value from char[] given a start index and length. </comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;param name="chars"&gt;&lt;/param&gt; The Char[] containing the numerical sequence.</comment>
        <comment type="line">/// &lt;param name="startIndex"&gt;&lt;/param&gt; The index of the start of the numerical sequence.</comment>
        <comment type="line">/// &lt;param name="length"&gt;&lt;/param&gt; The length of the numerical sequence.</comment>
        <comment type="line">/// &lt;param name="lastIndex"&gt;&lt;/param&gt; Index of the last character in the validated sequence.</comment>
        <comment type="line">/// &lt;returns&gt;&lt;/returns&gt;</comment>
        <function><specifier>protected</specifier> <type><name>float</name></type> <name>ConvertToFloat</name><parameter_list>(<parameter><decl><type><name><name>char</name><index>[]</index></name></type> <name>chars</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>startIndex</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>length</name></decl></parameter>, <parameter><decl><type><modifier>out</modifier> <name>int</name></type> <name>lastIndex</name></decl></parameter>)</parameter_list>
        <block>{
            <if>if <condition>(<expr><name>startIndex</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{ <expr_stmt><expr><name>lastIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <return>return <expr><operator>-</operator><literal type="number">9999</literal></expr>;</return> }</block></then></if>
            <decl_stmt><decl><type><name>int</name></type> <name>endIndex</name> <init>= <expr><name>startIndex</name> <operator>+</operator> <name>length</name></expr></init></decl>;</decl_stmt>

            <decl_stmt><decl><type><name>bool</name></type> <name>isIntegerValue</name> <init>= <expr><literal type="boolean">true</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>float</name></type> <name>decimalPointMultiplier</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

            <comment type="line">// Set value multiplier checking the first character to determine if we are using '+' or '-'</comment>
            <decl_stmt><decl><type><name>int</name></type> <name>valueSignMultiplier</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name><name>chars</name><index>[<expr><name>startIndex</name></expr>]</index></name> <operator>==</operator> <literal type="char">'+'</literal></expr>)</condition><then>
            <block>{
                <expr_stmt><expr><name>valueSignMultiplier</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>startIndex</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            }</block></then>
            <elseif>else <if>if <condition>(<expr><name><name>chars</name><index>[<expr><name>startIndex</name></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition><then>
            <block>{
                <expr_stmt><expr><name>valueSignMultiplier</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>startIndex</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            }</block></then></if></elseif></if>

            <decl_stmt><decl><type><name>float</name></type> <name>value</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>startIndex</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>endIndex</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{
                <decl_stmt><decl><type><name>uint</name></type> <name>c</name> <init>= <expr><name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

                <if>if <condition>(<expr><name>c</name> <operator>&gt;=</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name>c</name> <operator>&lt;=</operator> <literal type="char">'9'</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition><then>
                <block>{
                    <if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition><then>
                    <block>{
                        <expr_stmt><expr><name>isIntegerValue</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
                        <expr_stmt><expr><name>decimalPointMultiplier</name> <operator>=</operator> <literal type="number">0.1f</literal></expr>;</expr_stmt>
                        <continue>continue;</continue>
                    }</block></then></if>

                    <comment type="line">//Calculate integer and floating point value</comment>
                    <if>if <condition>(<expr><name>isIntegerValue</name></expr>)</condition><then>
                        <block type="pseudo"><expr_stmt><expr><name>value</name> <operator>=</operator> <name>value</name> <operator>*</operator> <literal type="number">10</literal> <operator>+</operator> <operator>(</operator><name>c</name> <operator>-</operator> <literal type="number">48</literal><operator>)</operator> <operator>*</operator> <name>valueSignMultiplier</name></expr>;</expr_stmt></block></then>
                    <else>else
                <block>{
                        <expr_stmt><expr><name>value</name> <operator>=</operator> <name>value</name> <operator>+</operator> <operator>(</operator><name>c</name> <operator>-</operator> <literal type="number">48</literal><operator>)</operator> <operator>*</operator> <name>decimalPointMultiplier</name> <operator>*</operator> <name>valueSignMultiplier</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>decimalPointMultiplier</name> <operator>*=</operator> <literal type="number">0.1f</literal></expr>;</expr_stmt>
                }</block></else></if>

                    <continue>continue;</continue>
                }</block></then>
                <elseif>else <if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">','</literal></expr>)</condition><then>
                <block>{
                    <if>if <condition>(<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name>endIndex</name> <operator>&amp;&amp;</operator> <name><name>chars</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition><then>
                        <block type="pseudo"><expr_stmt><expr><name>lastIndex</name> <operator>=</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block></then>
                <else>else
                        <block type="pseudo"><expr_stmt><expr><name>lastIndex</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block></else></if>

                    <return>return <expr><name>value</name></expr>;</return>
                }</block></then></if></elseif></if>
            }</block></for>

            <expr_stmt><expr><name>lastIndex</name> <operator>=</operator> <name>endIndex</name></expr>;</expr_stmt>
            <return>return <expr><name>value</name></expr>;</return>
        }</block></function>


        <comment type="line">/// &lt;summary&gt;</comment>
        <comment type="line">/// Function to identify and validate the rich tag. Returns the position of the &gt; if the tag was valid.</comment>
        <comment type="line">/// &lt;/summary&gt;</comment>
        <comment type="line">/// &lt;param name="chars"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="startIndex"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;param name="endIndex"&gt;&lt;/param&gt;</comment>
        <comment type="line">/// &lt;returns&gt;&lt;/returns&gt;</comment>
        <function><specifier>protected</specifier> <type><name>bool</name></type> <name>ValidateHtmlTag</name><parameter_list>(<parameter><decl><type><name><name>int</name><index>[]</index></name></type> <name>chars</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>startIndex</name></decl></parameter>, <parameter><decl><type><modifier>out</modifier> <name>int</name></type> <name>endIndex</name></decl></parameter>)</parameter_list>
        <block>{
            <decl_stmt><decl><type><name>int</name></type> <name>tagCharCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>byte</name></type> <name>attributeFlag</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

            <decl_stmt><decl><type><name>TagUnits</name></type> <name>tagUnits</name> <init>= <expr><name><name>TagUnits</name><operator>.</operator><name>Pixels</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>TagType</name></type> <name>tagType</name> <init>= <expr><name><name>TagType</name><operator>.</operator><name>None</name></name></expr></init></decl>;</decl_stmt>

            <decl_stmt><decl><type><name>int</name></type> <name>attributeIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>m_xmlAttribute</name><index>[<expr><name>attributeIndex</name></expr>]</index></name><operator>.</operator><name>nameHashCode</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>m_xmlAttribute</name><index>[<expr><name>attributeIndex</name></expr>]</index></name><operator>.</operator><name>valueType</name> <operator>=</operator> <name><name>TagType</name><operator>.</operator><name>None</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>m_xmlAttribute</name><index>[<expr><name>attributeIndex</name></expr>]</index></name><operator>.</operator><name>valueHashCode</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>m_xmlAttribute</name><index>[<expr><name>attributeIndex</name></expr>]</index></name><operator>.</operator><name>valueStartIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>m_xmlAttribute</name><index>[<expr><name>attributeIndex</name></expr>]</index></name><operator>.</operator><name>valueLength</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

            <comment type="line">// Clear attribute name hash codes</comment>
            <expr_stmt><expr><name><name>m_xmlAttribute</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>nameHashCode</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>m_xmlAttribute</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>nameHashCode</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>m_xmlAttribute</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>.</operator><name>nameHashCode</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>m_xmlAttribute</name><index>[<expr><literal type="number">4</literal></expr>]</index></name><operator>.</operator><name>nameHashCode</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

            <expr_stmt><expr><name>endIndex</name> <operator>=</operator> <name>startIndex</name></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>bool</name></type> <name>isTagSet</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bool</name></type> <name>isValidHtmlTag</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>

            <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>startIndex</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>chars</name><operator>.</operator><name>Length</name></name> <operator>&amp;&amp;</operator> <name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>tagCharCount</name> <operator>&lt;</operator> <name><name>m_htmlTag</name><operator>.</operator><name>Length</name></name> <operator>&amp;&amp;</operator> <name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">60</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{
                <if>if <condition>(<expr><name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="number">62</literal></expr>)</condition><then> <comment type="line">// ASCII Code of End HTML tag '&gt;'</comment>
                <block>{
                    <expr_stmt><expr><name>isValidHtmlTag</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><name>endIndex</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>m_htmlTag</name><index>[<expr><name>tagCharCount</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><literal type="number">0</literal></expr>;</expr_stmt>
                    <break>break;</break>
                }</block></then></if>

                <expr_stmt><expr><name><name>m_htmlTag</name><index>[<expr><name>tagCharCount</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>tagCharCount</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

                <if>if <condition>(<expr><name>attributeFlag</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><then>
                <block>{
                    <if>if <condition>(<expr><name>tagType</name> <operator>==</operator> <name><name>TagType</name><operator>.</operator><name>None</name></name></expr>)</condition><then>
                    <block>{
                        <comment type="line">// Check for attribute type</comment>
                        <if>if <condition>(<expr><name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="number">43</literal> <operator>||</operator> <name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="number">45</literal> <operator>||</operator> <name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="number">46</literal> <operator>||</operator> <operator>(</operator><name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;=</operator> <literal type="char">'9'</literal><operator>)</operator></expr>)</condition><then>
                        <block>{
                            <expr_stmt><expr><name>tagType</name> <operator>=</operator> <name><name>TagType</name><operator>.</operator><name>NumericalValue</name></name></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>m_xmlAttribute</name><index>[<expr><name>attributeIndex</name></expr>]</index></name><operator>.</operator><name>valueType</name> <operator>=</operator> <name><name>TagType</name><operator>.</operator><name>NumericalValue</name></name></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>m_xmlAttribute</name><index>[<expr><name>attributeIndex</name></expr>]</index></name><operator>.</operator><name>valueStartIndex</name> <operator>=</operator> <name>tagCharCount</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>m_xmlAttribute</name><index>[<expr><name>attributeIndex</name></expr>]</index></name><operator>.</operator><name>valueLength</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                        }</block></then>
                        <elseif>else <if>if <condition>(<expr><name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="number">35</literal></expr>)</condition><then>
                        <block>{
                            <expr_stmt><expr><name>tagType</name> <operator>=</operator> <name><name>TagType</name><operator>.</operator><name>ColorValue</name></name></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>m_xmlAttribute</name><index>[<expr><name>attributeIndex</name></expr>]</index></name><operator>.</operator><name>valueType</name> <operator>=</operator> <name><name>TagType</name><operator>.</operator><name>ColorValue</name></name></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>m_xmlAttribute</name><index>[<expr><name>attributeIndex</name></expr>]</index></name><operator>.</operator><name>valueStartIndex</name> <operator>=</operator> <name>tagCharCount</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>m_xmlAttribute</name><index>[<expr><name>attributeIndex</name></expr>]</index></name><operator>.</operator><name>valueLength</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                        }</block></then></if></elseif>
                        <elseif>else <if>if <condition>(<expr><name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="number">34</literal></expr>)</condition><then>
                        <block>{
                            <expr_stmt><expr><name>tagType</name> <operator>=</operator> <name><name>TagType</name><operator>.</operator><name>StringValue</name></name></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>m_xmlAttribute</name><index>[<expr><name>attributeIndex</name></expr>]</index></name><operator>.</operator><name>valueType</name> <operator>=</operator> <name><name>TagType</name><operator>.</operator><name>StringValue</name></name></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>m_xmlAttribute</name><index>[<expr><name>attributeIndex</name></expr>]</index></name><operator>.</operator><name>valueStartIndex</name> <operator>=</operator> <name>tagCharCount</name></expr>;</expr_stmt>
                        }</block></then></if></elseif>
                        <else>else
                        <block>{
                            <expr_stmt><expr><name>tagType</name> <operator>=</operator> <name><name>TagType</name><operator>.</operator><name>StringValue</name></name></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>m_xmlAttribute</name><index>[<expr><name>attributeIndex</name></expr>]</index></name><operator>.</operator><name>valueType</name> <operator>=</operator> <name><name>TagType</name><operator>.</operator><name>StringValue</name></name></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>m_xmlAttribute</name><index>[<expr><name>attributeIndex</name></expr>]</index></name><operator>.</operator><name>valueStartIndex</name> <operator>=</operator> <name>tagCharCount</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>m_xmlAttribute</name><index>[<expr><name>attributeIndex</name></expr>]</index></name><operator>.</operator><name>valueHashCode</name> <operator>=</operator> <operator>(</operator><name><name>m_xmlAttribute</name><index>[<expr><name>attributeIndex</name></expr>]</index></name><operator>.</operator><name>valueHashCode</name> <operator>&lt;&lt;</operator> <literal type="number">5</literal><operator>)</operator> <operator>+</operator> <name><name>m_xmlAttribute</name><index>[<expr><name>attributeIndex</name></expr>]</index></name><operator>.</operator><name>valueHashCode</name> <operator>^</operator> <name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>m_xmlAttribute</name><index>[<expr><name>attributeIndex</name></expr>]</index></name><operator>.</operator><name>valueLength</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                        }</block></else></if>
                    }</block></then>
                    <else>else
                    <block>{
                        <if>if <condition>(<expr><name>tagType</name> <operator>==</operator> <name><name>TagType</name><operator>.</operator><name>NumericalValue</name></name></expr>)</condition><then>
                        <block>{
                            <comment type="line">// Check for termination of numerical value.</comment>
                            <if>if <condition>(<expr><name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="number">112</literal> <operator>||</operator> <name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="number">101</literal> <operator>||</operator> <name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="number">37</literal> <operator>||</operator> <name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="number">32</literal></expr>)</condition><then>
                            <block>{
                                <expr_stmt><expr><name>attributeFlag</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
                                <expr_stmt><expr><name>tagType</name> <operator>=</operator> <name><name>TagType</name><operator>.</operator><name>None</name></name></expr>;</expr_stmt>
                                <expr_stmt><expr><name>attributeIndex</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                                <expr_stmt><expr><name><name>m_xmlAttribute</name><index>[<expr><name>attributeIndex</name></expr>]</index></name><operator>.</operator><name>nameHashCode</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                                <expr_stmt><expr><name><name>m_xmlAttribute</name><index>[<expr><name>attributeIndex</name></expr>]</index></name><operator>.</operator><name>valueType</name> <operator>=</operator> <name><name>TagType</name><operator>.</operator><name>None</name></name></expr>;</expr_stmt>
                                <expr_stmt><expr><name><name>m_xmlAttribute</name><index>[<expr><name>attributeIndex</name></expr>]</index></name><operator>.</operator><name>valueHashCode</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                                <expr_stmt><expr><name><name>m_xmlAttribute</name><index>[<expr><name>attributeIndex</name></expr>]</index></name><operator>.</operator><name>valueStartIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                                <expr_stmt><expr><name><name>m_xmlAttribute</name><index>[<expr><name>attributeIndex</name></expr>]</index></name><operator>.</operator><name>valueLength</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

                                <if>if <condition>(<expr><name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="number">101</literal></expr>)</condition><then>
                                    <block type="pseudo"><expr_stmt><expr><name>tagUnits</name> <operator>=</operator> <name><name>TagUnits</name><operator>.</operator><name>FontUnits</name></name></expr>;</expr_stmt></block></then>
                                <elseif>else <if>if <condition>(<expr><name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="number">37</literal></expr>)</condition><then>
                                    <block type="pseudo"><expr_stmt><expr><name>tagUnits</name> <operator>=</operator> <name><name>TagUnits</name><operator>.</operator><name>Percentage</name></name></expr>;</expr_stmt></block></then></if></elseif></if>
                            }</block></then>
                            <elseif>else <if>if <condition>(<expr><name>attributeFlag</name> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition><then>
                            <block>{
                                <expr_stmt><expr><name><name>m_xmlAttribute</name><index>[<expr><name>attributeIndex</name></expr>]</index></name><operator>.</operator><name>valueLength</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                            }</block></then></if></elseif></if>
                        }</block></then>
                        <elseif>else <if>if <condition>(<expr><name>tagType</name> <operator>==</operator> <name><name>TagType</name><operator>.</operator><name>ColorValue</name></name></expr>)</condition><then>
                        <block>{
                            <if>if <condition>(<expr><name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">32</literal></expr>)</condition><then>
                            <block>{
                                <expr_stmt><expr><name><name>m_xmlAttribute</name><index>[<expr><name>attributeIndex</name></expr>]</index></name><operator>.</operator><name>valueLength</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                            }</block></then>
                            <else>else
                            <block>{
                                <expr_stmt><expr><name>attributeFlag</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
                                <expr_stmt><expr><name>tagType</name> <operator>=</operator> <name><name>TagType</name><operator>.</operator><name>None</name></name></expr>;</expr_stmt>
                                <expr_stmt><expr><name>attributeIndex</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                                <expr_stmt><expr><name><name>m_xmlAttribute</name><index>[<expr><name>attributeIndex</name></expr>]</index></name><operator>.</operator><name>nameHashCode</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                                <expr_stmt><expr><name><name>m_xmlAttribute</name><index>[<expr><name>attributeIndex</name></expr>]</index></name><operator>.</operator><name>valueType</name> <operator>=</operator> <name><name>TagType</name><operator>.</operator><name>None</name></name></expr>;</expr_stmt>
                                <expr_stmt><expr><name><name>m_xmlAttribute</name><index>[<expr><name>attributeIndex</name></expr>]</index></name><operator>.</operator><name>valueHashCode</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                                <expr_stmt><expr><name><name>m_xmlAttribute</name><index>[<expr><name>attributeIndex</name></expr>]</index></name><operator>.</operator><name>valueStartIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                                <expr_stmt><expr><name><name>m_xmlAttribute</name><index>[<expr><name>attributeIndex</name></expr>]</index></name><operator>.</operator><name>valueLength</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                            }</block></else></if>
                        }</block></then></if></elseif>
                        <elseif>else <if>if <condition>(<expr><name>tagType</name> <operator>==</operator> <name><name>TagType</name><operator>.</operator><name>StringValue</name></name></expr>)</condition><then>
                        <block>{
                            <comment type="line">// Compute HashCode value for the named tag.</comment>
                            <if>if <condition>(<expr><name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">34</literal></expr>)</condition><then>
                            <block>{
                                <expr_stmt><expr><name><name>m_xmlAttribute</name><index>[<expr><name>attributeIndex</name></expr>]</index></name><operator>.</operator><name>valueHashCode</name> <operator>=</operator> <operator>(</operator><name><name>m_xmlAttribute</name><index>[<expr><name>attributeIndex</name></expr>]</index></name><operator>.</operator><name>valueHashCode</name> <operator>&lt;&lt;</operator> <literal type="number">5</literal><operator>)</operator> <operator>+</operator> <name><name>m_xmlAttribute</name><index>[<expr><name>attributeIndex</name></expr>]</index></name><operator>.</operator><name>valueHashCode</name> <operator>^</operator> <name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
                                <expr_stmt><expr><name><name>m_xmlAttribute</name><index>[<expr><name>attributeIndex</name></expr>]</index></name><operator>.</operator><name>valueLength</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                            }</block></then>
                            <else>else
                            <block>{
                                <comment type="line">//m_xmlAttribute[attributeIndex].valueHashCode = -1;</comment>
                                <expr_stmt><expr><name>attributeFlag</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
                                <expr_stmt><expr><name>tagType</name> <operator>=</operator> <name><name>TagType</name><operator>.</operator><name>None</name></name></expr>;</expr_stmt>
                                <expr_stmt><expr><name>attributeIndex</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                                <expr_stmt><expr><name><name>m_xmlAttribute</name><index>[<expr><name>attributeIndex</name></expr>]</index></name><operator>.</operator><name>nameHashCode</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                                <expr_stmt><expr><name><name>m_xmlAttribute</name><index>[<expr><name>attributeIndex</name></expr>]</index></name><operator>.</operator><name>valueType</name> <operator>=</operator> <name><name>TagType</name><operator>.</operator><name>None</name></name></expr>;</expr_stmt>
                                <expr_stmt><expr><name><name>m_xmlAttribute</name><index>[<expr><name>attributeIndex</name></expr>]</index></name><operator>.</operator><name>valueHashCode</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                                <expr_stmt><expr><name><name>m_xmlAttribute</name><index>[<expr><name>attributeIndex</name></expr>]</index></name><operator>.</operator><name>valueStartIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                                <expr_stmt><expr><name><name>m_xmlAttribute</name><index>[<expr><name>attributeIndex</name></expr>]</index></name><operator>.</operator><name>valueLength</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                            }</block></else></if>
                        }</block></then></if></elseif></if>
                    }</block></else></if>
                }</block></then></if>


                <if>if <condition>(<expr><name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="number">61</literal></expr>)</condition><then> <comment type="line">// '=' </comment>
                    <block type="pseudo"><expr_stmt><expr><name>attributeFlag</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block></then></if>

                <comment type="line">// Compute HashCode for the name of the attribute</comment>
                <if>if <condition>(<expr><name>attributeFlag</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="number">32</literal></expr>)</condition><then>
                <block>{
                    <if>if <condition>(<expr><name>isTagSet</name></expr>)</condition><then> <block type="pseudo"><return>return <expr><literal type="boolean">false</literal></expr>;</return></block></then></if>

                    <expr_stmt><expr><name>isTagSet</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><name>attributeFlag</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

                    <expr_stmt><expr><name>tagType</name> <operator>=</operator> <name><name>TagType</name><operator>.</operator><name>None</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>attributeIndex</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>m_xmlAttribute</name><index>[<expr><name>attributeIndex</name></expr>]</index></name><operator>.</operator><name>nameHashCode</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>m_xmlAttribute</name><index>[<expr><name>attributeIndex</name></expr>]</index></name><operator>.</operator><name>valueType</name> <operator>=</operator> <name><name>TagType</name><operator>.</operator><name>None</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>m_xmlAttribute</name><index>[<expr><name>attributeIndex</name></expr>]</index></name><operator>.</operator><name>valueHashCode</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>m_xmlAttribute</name><index>[<expr><name>attributeIndex</name></expr>]</index></name><operator>.</operator><name>valueStartIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>m_xmlAttribute</name><index>[<expr><name>attributeIndex</name></expr>]</index></name><operator>.</operator><name>valueLength</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                }</block></then></if>

                <if>if <condition>(<expr><name>attributeFlag</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then>
                    <block type="pseudo"><expr_stmt><expr><name><name>m_xmlAttribute</name><index>[<expr><name>attributeIndex</name></expr>]</index></name><operator>.</operator><name>nameHashCode</name> <operator>=</operator> <operator>(</operator><name><name>m_xmlAttribute</name><index>[<expr><name>attributeIndex</name></expr>]</index></name><operator>.</operator><name>nameHashCode</name> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator> <operator>-</operator> <name><name>m_xmlAttribute</name><index>[<expr><name>attributeIndex</name></expr>]</index></name><operator>.</operator><name>nameHashCode</name> <operator>+</operator> <name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block></then></if>

                <if>if <condition>(<expr><name>attributeFlag</name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="number">32</literal></expr>)</condition><then>
                    <block type="pseudo"><expr_stmt><expr><name>attributeFlag</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block></then></if>

            }</block></for>

            <if>if <condition>(<expr><operator>!</operator><name>isValidHtmlTag</name></expr>)</condition><then>
            <block>{
                <return>return <expr><literal type="boolean">false</literal></expr>;</return>
            }</block></then></if>

            <comment type="line">//Debug.Log("Tag is [" + m_htmlTag.ArrayToString() + "].  Tag HashCode: " + m_xmlAttribute[0].nameHashCode + "  Tag Value HashCode: " + m_xmlAttribute[0].valueHashCode + "  Attribute 1 HashCode: " + m_xmlAttribute[1].nameHashCode + " Value HashCode: " + m_xmlAttribute[1].valueHashCode);</comment>
            <comment type="line">//for (int i = 0; i &lt; attributeIndex + 1; i++)</comment>
            <comment type="line">//    Debug.Log("Tag [" + i + "] with HashCode: " + m_xmlAttribute[i].nameHashCode + " has value of [" + new string(m_htmlTag, m_xmlAttribute[i].valueStartIndex, m_xmlAttribute[i].valueLength) + "] Numerical Value: " + ConvertToFloat(m_htmlTag, m_xmlAttribute[i].valueStartIndex, m_xmlAttribute[i].valueLength));</comment>


            <comment type="line">// Special handling of the no parsing tag &lt;/noparse&gt; &lt;/NOPARSE&gt; tag</comment>
            <if>if <condition>(<expr><name>tag_NoParsing</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>m_xmlAttribute</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>nameHashCode</name> <operator>!=</operator> <literal type="number">53822163</literal> <operator>&amp;&amp;</operator> <name><name>m_xmlAttribute</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>nameHashCode</name> <operator>!=</operator> <literal type="number">49429939</literal><operator>)</operator></expr>)</condition><then>
                <block type="pseudo"><return>return <expr><literal type="boolean">false</literal></expr>;</return></block></then>
            <elseif>else <if>if <condition>(<expr><name><name>m_xmlAttribute</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>nameHashCode</name> <operator>==</operator> <literal type="number">53822163</literal> <operator>||</operator> <name><name>m_xmlAttribute</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>nameHashCode</name> <operator>==</operator> <literal type="number">49429939</literal></expr>)</condition><then>
            <block>{
                <expr_stmt><expr><name>tag_NoParsing</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
                <return>return <expr><literal type="boolean">true</literal></expr>;</return>
            }</block></then></if></elseif></if>

            <comment type="line">// Color &lt;#FFF&gt; 3 Hex values (short form)</comment>
            <if>if <condition>(<expr><name><name>m_htmlTag</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">35</literal> <operator>&amp;&amp;</operator> <name>tagCharCount</name> <operator>==</operator> <literal type="number">4</literal></expr>)</condition><then>
            <block>{
                <expr_stmt><expr><name>m_htmlColor</name> <operator>=</operator> <call><name>HexCharsToColor</name><argument_list>(<argument><expr><name>m_htmlTag</name></expr></argument>, <argument><expr><name>tagCharCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>m_colorStack</name><operator>.</operator><name>Add</name></name><argument_list>(<argument><expr><name>m_htmlColor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><literal type="boolean">true</literal></expr>;</return>
            }</block></then>
            <comment type="line">// Color &lt;#FFF7&gt; 4 Hex values with alpha (short form)</comment>
            <elseif>else <if>if <condition>(<expr><name><name>m_htmlTag</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">35</literal> <operator>&amp;&amp;</operator> <name>tagCharCount</name> <operator>==</operator> <literal type="number">5</literal></expr>)</condition><then>
            <block>{
                <expr_stmt><expr><name>m_htmlColor</name> <operator>=</operator> <call><name>HexCharsToColor</name><argument_list>(<argument><expr><name>m_htmlTag</name></expr></argument>, <argument><expr><name>tagCharCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>m_colorStack</name><operator>.</operator><name>Add</name></name><argument_list>(<argument><expr><name>m_htmlColor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><literal type="boolean">true</literal></expr>;</return>
            }</block></then></if></elseif>
            <comment type="line">// Color &lt;#FF00FF&gt;</comment>
            <elseif>else <if>if <condition>(<expr><name><name>m_htmlTag</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">35</literal> <operator>&amp;&amp;</operator> <name>tagCharCount</name> <operator>==</operator> <literal type="number">7</literal></expr>)</condition><then> <comment type="line">// if Tag begins with # and contains 7 characters. </comment>
            <block>{
                <expr_stmt><expr><name>m_htmlColor</name> <operator>=</operator> <call><name>HexCharsToColor</name><argument_list>(<argument><expr><name>m_htmlTag</name></expr></argument>, <argument><expr><name>tagCharCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>m_colorStack</name><operator>.</operator><name>Add</name></name><argument_list>(<argument><expr><name>m_htmlColor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><literal type="boolean">true</literal></expr>;</return>
            }</block></then></if></elseif>
            <comment type="line">// Color &lt;#FF00FF00&gt; with alpha</comment>
            <elseif>else <if>if <condition>(<expr><name><name>m_htmlTag</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">35</literal> <operator>&amp;&amp;</operator> <name>tagCharCount</name> <operator>==</operator> <literal type="number">9</literal></expr>)</condition><then> <comment type="line">// if Tag begins with # and contains 9 characters. </comment>
            <block>{
                <expr_stmt><expr><name>m_htmlColor</name> <operator>=</operator> <call><name>HexCharsToColor</name><argument_list>(<argument><expr><name>m_htmlTag</name></expr></argument>, <argument><expr><name>tagCharCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>m_colorStack</name><operator>.</operator><name>Add</name></name><argument_list>(<argument><expr><name>m_htmlColor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><literal type="boolean">true</literal></expr>;</return>
            }</block></then></if></elseif>
            <else>else
            <block>{
                <decl_stmt><decl><type><name>float</name></type> <name>value</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

                <switch>switch <condition>(<expr><name><name>m_xmlAttribute</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>nameHashCode</name></expr>)</condition>
                <block>{
                    <case>case <expr><literal type="number">98</literal></expr>:</case> <comment type="line">// &lt;b&gt;</comment>
                    <case>case <expr><literal type="number">66</literal></expr>:</case> <comment type="line">// &lt;B&gt;</comment>
                        <expr_stmt><expr><name>m_style</name> <operator>|=</operator> <name><name>FontStyles</name><operator>.</operator><name>Bold</name></name></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name><name>m_fontStyleStack</name><operator>.</operator><name>Add</name></name><argument_list>(<argument><expr><name><name>FontStyles</name><operator>.</operator><name>Bold</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <expr_stmt><expr><name>m_fontWeightInternal</name> <operator>=</operator> <literal type="number">700</literal></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name><name>m_fontWeightStack</name><operator>.</operator><name>Add</name></name><argument_list>(<argument><expr><literal type="number">700</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                    <case>case <expr><literal type="number">427</literal></expr>:</case> <comment type="line">// &lt;/b&gt;</comment>
                    <case>case <expr><literal type="number">395</literal></expr>:</case> <comment type="line">// &lt;/B&gt;</comment>
                        <if>if <condition>(<expr><operator>(</operator><name>m_fontStyle</name> <operator>&amp;</operator> <name><name>FontStyles</name><operator>.</operator><name>Bold</name></name><operator>)</operator> <operator>!=</operator> <name><name>FontStyles</name><operator>.</operator><name>Bold</name></name></expr>)</condition><then>
                        <block>{
                            <expr_stmt><expr><name>m_fontWeightInternal</name> <operator>=</operator> <call><name><name>m_fontWeightStack</name><operator>.</operator><name>Remove</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

                            <if>if <condition>(<expr><call><name><name>m_fontStyleStack</name><operator>.</operator><name>Remove</name></name><argument_list>(<argument><expr><name><name>FontStyles</name><operator>.</operator><name>Bold</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then>
                                <block type="pseudo"><expr_stmt><expr><name>m_style</name> <operator>&amp;=</operator> <operator>~</operator><name><name>FontStyles</name><operator>.</operator><name>Bold</name></name></expr>;</expr_stmt></block></then></if>
                        }</block></then></if>
                        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                    <case>case <expr><literal type="number">105</literal></expr>:</case> <comment type="line">// &lt;i&gt;</comment>
                    <case>case <expr><literal type="number">73</literal></expr>:</case> <comment type="line">// &lt;I&gt;</comment>
                        <expr_stmt><expr><name>m_style</name> <operator>|=</operator> <name><name>FontStyles</name><operator>.</operator><name>Italic</name></name></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name><name>m_fontStyleStack</name><operator>.</operator><name>Add</name></name><argument_list>(<argument><expr><name><name>FontStyles</name><operator>.</operator><name>Italic</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                    <case>case <expr><literal type="number">434</literal></expr>:</case> <comment type="line">// &lt;/i&gt;</comment>
                    <case>case <expr><literal type="number">402</literal></expr>:</case> <comment type="line">// &lt;/I&gt;</comment>
                        <if>if <condition>(<expr><call><name><name>m_fontStyleStack</name><operator>.</operator><name>Remove</name></name><argument_list>(<argument><expr><name><name>FontStyles</name><operator>.</operator><name>Italic</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then>
                            <block type="pseudo"><expr_stmt><expr><name>m_style</name> <operator>&amp;=</operator> <operator>~</operator><name><name>FontStyles</name><operator>.</operator><name>Italic</name></name></expr>;</expr_stmt></block></then></if>

                        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                    <case>case <expr><literal type="number">115</literal></expr>:</case> <comment type="line">// &lt;s&gt;</comment>
                    <case>case <expr><literal type="number">83</literal></expr>:</case> <comment type="line">// &lt;S&gt;</comment>
                        <expr_stmt><expr><name>m_style</name> <operator>|=</operator> <name><name>FontStyles</name><operator>.</operator><name>Strikethrough</name></name></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name><name>m_fontStyleStack</name><operator>.</operator><name>Add</name></name><argument_list>(<argument><expr><name><name>FontStyles</name><operator>.</operator><name>Strikethrough</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <if>if <condition>(<expr><name><name>m_xmlAttribute</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>nameHashCode</name> <operator>==</operator> <literal type="number">281955</literal> <operator>||</operator> <name><name>m_xmlAttribute</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>nameHashCode</name> <operator>==</operator> <literal type="number">192323</literal></expr>)</condition><then>
                        <block>{
                            <expr_stmt><expr><name>m_strikethroughColor</name> <operator>=</operator> <call><name>HexCharsToColor</name><argument_list>(<argument><expr><name>m_htmlTag</name></expr></argument>, <argument><expr><name><name>m_xmlAttribute</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>valueStartIndex</name></expr></argument>, <argument><expr><name><name>m_xmlAttribute</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>valueLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>m_strikethroughColor</name><operator>.</operator><name>a</name></name> <operator>=</operator> <ternary><condition><expr><name><name>m_htmlColor</name><operator>.</operator><name>a</name></name> <operator>&lt;</operator> <name><name>m_strikethroughColor</name><operator>.</operator><name>a</name></name></expr> ?</condition><then> <expr><call>(<name>byte</name>)<argument_list>(<argument><expr><name><name>m_htmlColor</name><operator>.</operator><name>a</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call>(<name>byte</name>)<argument_list>(<argument><expr><name><name>m_strikethroughColor</name> <operator>.</operator><name>a</name></name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
                        }</block></then>
                        <else>else
                            <block type="pseudo"><expr_stmt><expr><name>m_strikethroughColor</name> <operator>=</operator> <name>m_htmlColor</name></expr>;</expr_stmt></block></else></if>

                        <expr_stmt><expr><call><name><name>m_strikethroughColorStack</name><operator>.</operator><name>Add</name></name><argument_list>(<argument><expr><name>m_strikethroughColor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                    <case>case <expr><literal type="number">444</literal></expr>:</case> <comment type="line">// &lt;/s&gt;</comment>
                    <case>case <expr><literal type="number">412</literal></expr>:</case> <comment type="line">// &lt;/S&gt;</comment>
                        <if>if <condition>(<expr><operator>(</operator><name>m_fontStyle</name> <operator>&amp;</operator> <name><name>FontStyles</name><operator>.</operator><name>Strikethrough</name></name><operator>)</operator> <operator>!=</operator> <name><name>FontStyles</name><operator>.</operator><name>Strikethrough</name></name></expr>)</condition><then>
                        <block>{
                            <if>if <condition>(<expr><call><name><name>m_fontStyleStack</name><operator>.</operator><name>Remove</name></name><argument_list>(<argument><expr><name><name>FontStyles</name><operator>.</operator><name>Strikethrough</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then>
                                <block type="pseudo"><expr_stmt><expr><name>m_style</name> <operator>&amp;=</operator> <operator>~</operator><name><name>FontStyles</name><operator>.</operator><name>Strikethrough</name></name></expr>;</expr_stmt></block></then></if>
                        }</block></then></if>
                        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                    <case>case <expr><literal type="number">117</literal></expr>:</case> <comment type="line">// &lt;u&gt;</comment>
                    <case>case <expr><literal type="number">85</literal></expr>:</case> <comment type="line">// &lt;U&gt;</comment>
                        <expr_stmt><expr><name>m_style</name> <operator>|=</operator> <name><name>FontStyles</name><operator>.</operator><name>Underline</name></name></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name><name>m_fontStyleStack</name><operator>.</operator><name>Add</name></name><argument_list>(<argument><expr><name><name>FontStyles</name><operator>.</operator><name>Underline</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <if>if <condition>(<expr><name><name>m_xmlAttribute</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>nameHashCode</name> <operator>==</operator> <literal type="number">281955</literal> <operator>||</operator> <name><name>m_xmlAttribute</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>nameHashCode</name> <operator>==</operator> <literal type="number">192323</literal></expr>)</condition><then>
                        <block>{
                            <expr_stmt><expr><name>m_underlineColor</name> <operator>=</operator> <call><name>HexCharsToColor</name><argument_list>(<argument><expr><name>m_htmlTag</name></expr></argument>, <argument><expr><name><name>m_xmlAttribute</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>valueStartIndex</name></expr></argument>, <argument><expr><name><name>m_xmlAttribute</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>valueLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>m_underlineColor</name><operator>.</operator><name>a</name></name> <operator>=</operator> <ternary><condition><expr><name><name>m_htmlColor</name><operator>.</operator><name>a</name></name> <operator>&lt;</operator> <name><name>m_underlineColor</name><operator>.</operator><name>a</name></name></expr> ?</condition><then> <expr><call>(<name>byte</name>)<argument_list>(<argument><expr><name><name>m_htmlColor</name><operator>.</operator><name>a</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call>(<name>byte</name>)<argument_list>(<argument><expr><name><name>m_underlineColor</name><operator>.</operator><name>a</name></name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
                        }</block></then>
                        <else>else
                            <block type="pseudo"><expr_stmt><expr><name>m_underlineColor</name> <operator>=</operator> <name>m_htmlColor</name></expr>;</expr_stmt></block></else></if>

                        <expr_stmt><expr><call><name><name>m_underlineColorStack</name><operator>.</operator><name>Add</name></name><argument_list>(<argument><expr><name>m_underlineColor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                    <case>case <expr><literal type="number">446</literal></expr>:</case> <comment type="line">// &lt;/u&gt;</comment>
                    <case>case <expr><literal type="number">414</literal></expr>:</case> <comment type="line">// &lt;/U&gt;</comment>
                        <if>if <condition>(<expr><operator>(</operator><name>m_fontStyle</name> <operator>&amp;</operator> <name><name>FontStyles</name><operator>.</operator><name>Underline</name></name><operator>)</operator> <operator>!=</operator> <name><name>FontStyles</name><operator>.</operator><name>Underline</name></name></expr>)</condition><then>
                        <block>{
                            <expr_stmt><expr><name>m_underlineColor</name> <operator>=</operator> <call><name><name>m_underlineColorStack</name><operator>.</operator><name>Remove</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

                            <if>if <condition>(<expr><call><name><name>m_fontStyleStack</name><operator>.</operator><name>Remove</name></name><argument_list>(<argument><expr><name><name>FontStyles</name><operator>.</operator><name>Underline</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then>
                                <block type="pseudo"><expr_stmt><expr><name>m_style</name> <operator>&amp;=</operator> <operator>~</operator><name><name>FontStyles</name><operator>.</operator><name>Underline</name></name></expr>;</expr_stmt></block></then></if>
                        }</block></then></if>
                        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                    <case>case <expr><literal type="number">43045</literal></expr>:</case> <comment type="line">// &lt;mark=#FF00FF80&gt;</comment>
                    <case>case <expr><literal type="number">30245</literal></expr>:</case> <comment type="line">// &lt;MARK&gt;</comment>
                        <expr_stmt><expr><name>m_style</name> <operator>|=</operator> <name><name>FontStyles</name><operator>.</operator><name>Highlight</name></name></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name><name>m_fontStyleStack</name><operator>.</operator><name>Add</name></name><argument_list>(<argument><expr><name><name>FontStyles</name><operator>.</operator><name>Highlight</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <expr_stmt><expr><name>m_highlightColor</name> <operator>=</operator> <call><name>HexCharsToColor</name><argument_list>(<argument><expr><name>m_htmlTag</name></expr></argument>, <argument><expr><name><name>m_xmlAttribute</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>valueStartIndex</name></expr></argument>, <argument><expr><name><name>m_xmlAttribute</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>valueLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>m_highlightColor</name><operator>.</operator><name>a</name></name> <operator>=</operator> <ternary><condition><expr><name><name>m_htmlColor</name><operator>.</operator><name>a</name></name> <operator>&lt;</operator> <name><name>m_highlightColor</name><operator>.</operator><name>a</name></name></expr> ?</condition><then> <expr><call>(<name>byte</name>)<argument_list>(<argument><expr><name><name>m_htmlColor</name><operator>.</operator><name>a</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call>(<name>byte</name>)<argument_list>(<argument><expr><name><name>m_highlightColor</name><operator>.</operator><name>a</name></name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name><name>m_highlightColorStack</name><operator>.</operator><name>Add</name></name><argument_list>(<argument><expr><name>m_highlightColor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                    <case>case <expr><literal type="number">155892</literal></expr>:</case> <comment type="line">// &lt;/mark&gt;</comment>
                    <case>case <expr><literal type="number">143092</literal></expr>:</case> <comment type="line">// &lt;/MARK&gt;</comment>
                        <if>if <condition>(<expr><operator>(</operator><name>m_fontStyle</name> <operator>&amp;</operator> <name><name>FontStyles</name><operator>.</operator><name>Highlight</name></name><operator>)</operator> <operator>!=</operator> <name><name>FontStyles</name><operator>.</operator><name>Highlight</name></name></expr>)</condition><then>
                        <block>{
                            <expr_stmt><expr><name>m_highlightColor</name> <operator>=</operator> <call><name><name>m_highlightColorStack</name><operator>.</operator><name>Remove</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

                            <if>if <condition>(<expr><call><name><name>m_fontStyleStack</name><operator>.</operator><name>Remove</name></name><argument_list>(<argument><expr><name><name>FontStyles</name><operator>.</operator><name>Highlight</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then>
                                <block type="pseudo"><expr_stmt><expr><name>m_style</name> <operator>&amp;=</operator> <operator>~</operator><name><name>FontStyles</name><operator>.</operator><name>Highlight</name></name></expr>;</expr_stmt></block></then></if>
                        }</block></then></if>
                        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                    <case>case <expr><literal type="number">6552</literal></expr>:</case> <comment type="line">// &lt;sub&gt;</comment>
                    <case>case <expr><literal type="number">4728</literal></expr>:</case> <comment type="line">// &lt;SUB&gt;</comment>
                        <expr_stmt><expr><name>m_fontScaleMultiplier</name> <operator>*=</operator> <ternary><condition><expr><name><name>m_currentFontAsset</name><operator>.</operator><name>fontInfo</name><operator>.</operator><name>SubSize</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name><name>m_currentFontAsset</name><operator>.</operator><name>fontInfo</name><operator>.</operator><name>SubSize</name></name></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name><name>m_baselineOffsetStack</name><operator>.</operator><name>Push</name></name><argument_list>(<argument><expr><name>m_baselineOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>m_baselineOffset</name> <operator>+=</operator> <name><name>m_currentFontAsset</name><operator>.</operator><name>fontInfo</name><operator>.</operator><name>SubscriptOffset</name></name> <operator>*</operator> <name>m_fontScale</name> <operator>*</operator> <name>m_fontScaleMultiplier</name></expr>;</expr_stmt>

                        <expr_stmt><expr><call><name><name>m_fontStyleStack</name><operator>.</operator><name>Add</name></name><argument_list>(<argument><expr><name><name>FontStyles</name><operator>.</operator><name>Subscript</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>m_style</name> <operator>|=</operator> <name><name>FontStyles</name><operator>.</operator><name>Subscript</name></name></expr>;</expr_stmt>
                        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                    <case>case <expr><literal type="number">22673</literal></expr>:</case> <comment type="line">// &lt;/sub&gt;</comment>
                    <case>case <expr><literal type="number">20849</literal></expr>:</case> <comment type="line">// &lt;/SUB&gt;</comment>
                        <if>if <condition>(<expr><operator>(</operator><name>m_style</name> <operator>&amp;</operator> <name><name>FontStyles</name><operator>.</operator><name>Subscript</name></name><operator>)</operator> <operator>==</operator> <name><name>FontStyles</name><operator>.</operator><name>Subscript</name></name></expr>)</condition><then>
                        <block>{
                            <if>if <condition>(<expr><name>m_fontScaleMultiplier</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><then>
                            <block>{
                                <comment type="line">//m_baselineOffset -= m_currentFontAsset.fontInfo.SubscriptOffset * m_fontScale * m_fontScaleMultiplier;</comment>
                                <expr_stmt><expr><name>m_baselineOffset</name> <operator>=</operator> <call><name><name>m_baselineOffsetStack</name><operator>.</operator><name>Pop</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                                <expr_stmt><expr><name>m_fontScaleMultiplier</name> <operator>/=</operator> <ternary><condition><expr><name><name>m_currentFontAsset</name><operator>.</operator><name>fontInfo</name><operator>.</operator><name>SubSize</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name><name>m_currentFontAsset</name><operator>.</operator><name>fontInfo</name><operator>.</operator><name>SubSize</name></name></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
                            }</block></then></if>

                            <if>if <condition>(<expr><call><name><name>m_fontStyleStack</name><operator>.</operator><name>Remove</name></name><argument_list>(<argument><expr><name><name>FontStyles</name><operator>.</operator><name>Subscript</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then>
                                <block type="pseudo"><expr_stmt><expr><name>m_style</name> <operator>&amp;=</operator> <operator>~</operator><name><name>FontStyles</name><operator>.</operator><name>Subscript</name></name></expr>;</expr_stmt></block></then></if>
                        }</block></then></if>
                        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                    <case>case <expr><literal type="number">6566</literal></expr>:</case> <comment type="line">// &lt;sup&gt;</comment>
                    <case>case <expr><literal type="number">4742</literal></expr>:</case> <comment type="line">// &lt;SUP&gt;</comment>
                        <expr_stmt><expr><name>m_fontScaleMultiplier</name> <operator>*=</operator> <ternary><condition><expr><name><name>m_currentFontAsset</name><operator>.</operator><name>fontInfo</name><operator>.</operator><name>SubSize</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name><name>m_currentFontAsset</name><operator>.</operator><name>fontInfo</name><operator>.</operator><name>SubSize</name></name></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name><name>m_baselineOffsetStack</name><operator>.</operator><name>Push</name></name><argument_list>(<argument><expr><name>m_baselineOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>m_baselineOffset</name> <operator>+=</operator> <name><name>m_currentFontAsset</name><operator>.</operator><name>fontInfo</name><operator>.</operator><name>SuperscriptOffset</name></name> <operator>*</operator> <name>m_fontScale</name> <operator>*</operator> <name>m_fontScaleMultiplier</name></expr>;</expr_stmt>

                        <expr_stmt><expr><call><name><name>m_fontStyleStack</name><operator>.</operator><name>Add</name></name><argument_list>(<argument><expr><name><name>FontStyles</name><operator>.</operator><name>Superscript</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>m_style</name> <operator>|=</operator> <name><name>FontStyles</name><operator>.</operator><name>Superscript</name></name></expr>;</expr_stmt>
                        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                    <case>case <expr><literal type="number">22687</literal></expr>:</case> <comment type="line">// &lt;/sup&gt;</comment>
                    <case>case <expr><literal type="number">20863</literal></expr>:</case> <comment type="line">// &lt;/SUP&gt;</comment>
                        <if>if <condition>(<expr><operator>(</operator><name>m_style</name> <operator>&amp;</operator> <name><name>FontStyles</name><operator>.</operator><name>Superscript</name></name><operator>)</operator> <operator>==</operator> <name><name>FontStyles</name><operator>.</operator><name>Superscript</name></name></expr>)</condition><then>
                        <block>{
                            <if>if <condition>(<expr><name>m_fontScaleMultiplier</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><then>
                            <block>{
                                <comment type="line">//m_baselineOffset -= m_currentFontAsset.fontInfo.SuperscriptOffset * m_fontScale * m_fontScaleMultiplier;</comment>
                                <expr_stmt><expr><name>m_baselineOffset</name> <operator>=</operator> <call><name><name>m_baselineOffsetStack</name><operator>.</operator><name>Pop</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                                <expr_stmt><expr><name>m_fontScaleMultiplier</name> <operator>/=</operator> <ternary><condition><expr><name><name>m_currentFontAsset</name><operator>.</operator><name>fontInfo</name><operator>.</operator><name>SubSize</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name><name>m_currentFontAsset</name><operator>.</operator><name>fontInfo</name><operator>.</operator><name>SubSize</name></name></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
                            }</block></then></if>

                            <if>if <condition>(<expr><call><name><name>m_fontStyleStack</name><operator>.</operator><name>Remove</name></name><argument_list>(<argument><expr><name><name>FontStyles</name><operator>.</operator><name>Superscript</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then>
                                <block type="pseudo"><expr_stmt><expr><name>m_style</name> <operator>&amp;=</operator> <operator>~</operator><name><name>FontStyles</name><operator>.</operator><name>Superscript</name></name></expr>;</expr_stmt></block></then></if>
                        }</block></then></if>
                        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                    <case>case <expr><operator>-</operator><literal type="number">330774850</literal></expr>:</case> <comment type="line">// &lt;font-weight&gt;</comment>
                    <case>case <expr><literal type="number">2012149182</literal></expr>:</case> <comment type="line">// &lt;FONT-WEIGHT&gt;</comment>
                        <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>ConvertToFloat</name><argument_list>(<argument><expr><name>m_htmlTag</name></expr></argument>, <argument><expr><name><name>m_xmlAttribute</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>valueStartIndex</name></expr></argument>, <argument><expr><name><name>m_xmlAttribute</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>valueLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if>if <condition>(<expr><name>value</name> <operator>==</operator> <operator>-</operator><literal type="number">9999</literal></expr>)</condition><then> <block type="pseudo"><return>return <expr><literal type="boolean">false</literal></expr>;</return></block></then></if>

                        <if>if <condition>(<expr><operator>(</operator><name>m_fontStyle</name> <operator>&amp;</operator> <name><name>FontStyles</name><operator>.</operator><name>Bold</name></name><operator>)</operator> <operator>==</operator> <name><name>FontStyles</name><operator>.</operator><name>Bold</name></name></expr>)</condition><then>
                        <block>{
                            <comment type="line">// Nothing happens since Bold is forced on the text.</comment>
                            <comment type="line">//m_fontWeight = 700;</comment>
                            <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                        }</block></then></if>


                        <comment type="line">// Remove bold style</comment>
                        <expr_stmt><expr><name>m_style</name> <operator>&amp;=</operator> <operator>~</operator><name><name>FontStyles</name><operator>.</operator><name>Bold</name></name></expr>;</expr_stmt>

                        <switch>switch <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator><name>value</name></expr>)</condition>
                        <block>{
                            <case>case <expr><literal type="number">100</literal></expr>:</case>
                                <expr_stmt><expr><name>m_fontWeightInternal</name> <operator>=</operator> <literal type="number">100</literal></expr>;</expr_stmt>
                                <break>break;</break>
                            <case>case <expr><literal type="number">200</literal></expr>:</case>
                                <expr_stmt><expr><name>m_fontWeightInternal</name> <operator>=</operator> <literal type="number">200</literal></expr>;</expr_stmt>
                                <break>break;</break>
                            <case>case <expr><literal type="number">300</literal></expr>:</case>
                                <expr_stmt><expr><name>m_fontWeightInternal</name> <operator>=</operator> <literal type="number">300</literal></expr>;</expr_stmt>
                                <break>break;</break>
                            <case>case <expr><literal type="number">400</literal></expr>:</case>
                                <expr_stmt><expr><name>m_fontWeightInternal</name> <operator>=</operator> <literal type="number">400</literal></expr>;</expr_stmt>

                                <break>break;</break>
                            <case>case <expr><literal type="number">500</literal></expr>:</case>
                                <expr_stmt><expr><name>m_fontWeightInternal</name> <operator>=</operator> <literal type="number">500</literal></expr>;</expr_stmt>
                                <break>break;</break>
                            <case>case <expr><literal type="number">600</literal></expr>:</case>
                                <expr_stmt><expr><name>m_fontWeightInternal</name> <operator>=</operator> <literal type="number">600</literal></expr>;</expr_stmt>
                                <break>break;</break>
                            <case>case <expr><literal type="number">700</literal></expr>:</case>
                                <expr_stmt><expr><name>m_fontWeightInternal</name> <operator>=</operator> <literal type="number">700</literal></expr>;</expr_stmt>
                                <expr_stmt><expr><name>m_style</name> <operator>|=</operator> <name><name>FontStyles</name><operator>.</operator><name>Bold</name></name></expr>;</expr_stmt>
                                <break>break;</break>
                            <case>case <expr><literal type="number">800</literal></expr>:</case>
                                <expr_stmt><expr><name>m_fontWeightInternal</name> <operator>=</operator> <literal type="number">800</literal></expr>;</expr_stmt>
                                <break>break;</break>
                            <case>case <expr><literal type="number">900</literal></expr>:</case>
                                <expr_stmt><expr><name>m_fontWeightInternal</name> <operator>=</operator> <literal type="number">900</literal></expr>;</expr_stmt>
                                <break>break;</break>
                        }</block></switch>

                        <expr_stmt><expr><call><name><name>m_fontWeightStack</name><operator>.</operator><name>Add</name></name><argument_list>(<argument><expr><name>m_fontWeightInternal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                    <case>case <expr><operator>-</operator><literal type="number">1885698441</literal></expr>:</case> <comment type="line">// &lt;/font-weight&gt;</comment>
                    <case>case <expr><literal type="number">457225591</literal></expr>:</case> <comment type="line">// &lt;/FONT-WEIGHT&gt;</comment>
                        <expr_stmt><expr><name>m_fontWeightInternal</name> <operator>=</operator> <call><name><name>m_fontWeightStack</name><operator>.</operator><name>Remove</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                        <if>if <condition>(<expr><name>m_fontWeightInternal</name> <operator>==</operator> <literal type="number">400</literal></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><name>m_style</name> <operator>&amp;=</operator> <operator>~</operator><name><name>FontStyles</name><operator>.</operator><name>Bold</name></name></expr>;</expr_stmt></block></then></if>
                        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                    <case>case <expr><literal type="number">6380</literal></expr>:</case> <comment type="line">// &lt;pos=000.00px&gt; &lt;pos=0em&gt; &lt;pos=50%&gt;</comment>
                    <case>case <expr><literal type="number">4556</literal></expr>:</case> <comment type="line">// &lt;POS&gt;</comment>
                        <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>ConvertToFloat</name><argument_list>(<argument><expr><name>m_htmlTag</name></expr></argument>, <argument><expr><name><name>m_xmlAttribute</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>valueStartIndex</name></expr></argument>, <argument><expr><name><name>m_xmlAttribute</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>valueLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if>if <condition>(<expr><name>value</name> <operator>==</operator> <operator>-</operator><literal type="number">9999</literal></expr>)</condition><then> <block type="pseudo"><return>return <expr><literal type="boolean">false</literal></expr>;</return></block></then></if>

                        <switch>switch <condition>(<expr><name>tagUnits</name></expr>)</condition>
                        <block>{
                            <case>case <expr><name><name>TagUnits</name><operator>.</operator><name>Pixels</name></name></expr>:</case>
                                <comment type="line">//if (m_xmlAttribute[1].nameHashCode == 275917) //</comment>
                                <comment type="line">//{</comment>
                                <comment type="line">//	// left = 3774683</comment>
                                <comment type="line">//	// right= 136703040</comment>
                                <comment type="line">//	if (m_xmlAttribute [1].valueHashCode == 136703040)</comment>
                                <comment type="line">//	{</comment>
                                <comment type="line">//		// track the endindex so we can return to this character.</comment>
                                <comment type="line">//		Debug.Log ("align=right startIndex" + endIndex);</comment>
                                <comment type="line">//	}</comment>
                                <comment type="line">//}</comment>
                                <expr_stmt><expr><name>m_xAdvance</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
                                <comment type="line">//m_isIgnoringAlignment = true;</comment>
                                <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                            <case>case <expr><name><name>TagUnits</name><operator>.</operator><name>FontUnits</name></name></expr>:</case>
                                <expr_stmt><expr><name>m_xAdvance</name> <operator>=</operator> <name>value</name> <operator>*</operator> <name>m_fontScale</name> <operator>*</operator> <name><name>m_fontAsset</name><operator>.</operator><name>fontInfo</name><operator>.</operator><name>TabWidth</name></name> <operator>/</operator> <name><name>m_fontAsset</name><operator>.</operator><name>tabSize</name></name></expr>;</expr_stmt>
                                <comment type="line">//m_isIgnoringAlignment = true;</comment>
                                <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                            <case>case <expr><name><name>TagUnits</name><operator>.</operator><name>Percentage</name></name></expr>:</case>
                                <expr_stmt><expr><name>m_xAdvance</name> <operator>=</operator> <name>m_marginWidth</name> <operator>*</operator> <name>value</name> <operator>/</operator> <literal type="number">100</literal></expr>;</expr_stmt>

                                <comment type="line">//if (m_xmlAttribute[1].nameHashCode == 275917) //</comment>
                                <comment type="line">//{</comment>
                                <comment type="line">//	//Debug.Log ("align tag.");</comment>
                                <comment type="line">//	// left = 3774683</comment>
                                <comment type="line">//	// right= 136703040</comment>
                                <comment type="line">//	if (m_xmlAttribute [1].valueHashCode == 136703040)</comment>
                                <comment type="line">//	{</comment>
                                <comment type="line">//		// track the endindex so we can return to this character.</comment>
                                <comment type="line">//		SaveWordWrappingState (ref m_SavedAlignment, endIndex, m_characterCount);</comment>
                                <comment type="line">//	}</comment>
                                <comment type="line">//}</comment>
                                <comment type="line">//m_isIgnoringAlignment = true;</comment>
                                <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                        }</block></switch>
                        <return>return <expr><literal type="boolean">false</literal></expr>;</return>
                    <case>case <expr><literal type="number">22501</literal></expr>:</case> <comment type="line">// &lt;/pos&gt;</comment>
                    <case>case <expr><literal type="number">20677</literal></expr>:</case> <comment type="line">// &lt;/POS&gt;</comment>
                                <comment type="block">/*
                                // Should retrun the index of where the tag started and adjust xAdvance.
                                if (m_isParsingText)
                                {
                                    if (m_SavedAlignment.previous_WordBreak != 0) 
                                    {
                                        float current_xAdvance = m_xAdvance; 
                                        endIndex = RestoreWordWrappingState (ref m_SavedAlignment);
                                        m_characterCount -= 1;
                                        m_xAdvance -= current_xAdvance - m_xAdvance;
                                    }
                                    m_SavedAlignment.previous_WordBreak = 0;

                                    m_isIgnoringAlignment = false;
                                }
                                */</comment>
                        <expr_stmt><expr><name>m_isIgnoringAlignment</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
                        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                    <case>case <expr><literal type="number">16034505</literal></expr>:</case> <comment type="line">// &lt;voffset&gt;</comment>
                    <case>case <expr><literal type="number">11642281</literal></expr>:</case> <comment type="line">// &lt;VOFFSET&gt;</comment>
                        <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>ConvertToFloat</name><argument_list>(<argument><expr><name>m_htmlTag</name></expr></argument>, <argument><expr><name><name>m_xmlAttribute</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>valueStartIndex</name></expr></argument>, <argument><expr><name><name>m_xmlAttribute</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>valueLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if>if <condition>(<expr><name>value</name> <operator>==</operator> <operator>-</operator><literal type="number">9999</literal></expr>)</condition><then> <block type="pseudo"><return>return <expr><literal type="boolean">false</literal></expr>;</return></block></then></if>

                        <switch>switch <condition>(<expr><name>tagUnits</name></expr>)</condition>
                        <block>{
                            <case>case <expr><name><name>TagUnits</name><operator>.</operator><name>Pixels</name></name></expr>:</case>
                                <expr_stmt><expr><name>m_baselineOffset</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
                                <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                            <case>case <expr><name><name>TagUnits</name><operator>.</operator><name>FontUnits</name></name></expr>:</case>
                                <expr_stmt><expr><name>m_baselineOffset</name> <operator>=</operator> <name>value</name> <operator>*</operator> <name>m_fontScale</name> <operator>*</operator> <name><name>m_fontAsset</name><operator>.</operator><name>fontInfo</name><operator>.</operator><name>Ascender</name></name></expr>;</expr_stmt>
                                <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                            <case>case <expr><name><name>TagUnits</name><operator>.</operator><name>Percentage</name></name></expr>:</case>
                                <comment type="line">//m_baselineOffset = m_marginHeight * val / 100;</comment>
                                <return>return <expr><literal type="boolean">false</literal></expr>;</return>
                        }</block></switch>
                        <return>return <expr><literal type="boolean">false</literal></expr>;</return>
                    <case>case <expr><literal type="number">54741026</literal></expr>:</case> <comment type="line">// &lt;/voffset&gt;</comment>
                    <case>case <expr><literal type="number">50348802</literal></expr>:</case> <comment type="line">// &lt;/VOFFSET&gt;</comment>
                        <expr_stmt><expr><name>m_baselineOffset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                    <case>case <expr><literal type="number">43991</literal></expr>:</case> <comment type="line">// &lt;page&gt;</comment>
                    <case>case <expr><literal type="number">31191</literal></expr>:</case> <comment type="line">// &lt;PAGE&gt;</comment>
                        <comment type="line">// This tag only works when Overflow - Page mode is used.</comment>
                        <if>if <condition>(<expr><name>m_overflowMode</name> <operator>==</operator> <name><name>TextOverflowModes</name><operator>.</operator><name>Page</name></name></expr>)</condition><then>
                        <block>{
                            <expr_stmt><expr><name>m_xAdvance</name> <operator>=</operator> <literal type="number">0</literal> <operator>+</operator> <name>tag_LineIndent</name> <operator>+</operator> <name>tag_Indent</name></expr>;</expr_stmt>
                            <expr_stmt><expr><name>m_lineOffset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                            <expr_stmt><expr><name>m_pageNumber</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                            <expr_stmt><expr><name>m_isNewPage</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                        }</block></then></if>
                        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                    <comment type="line">// &lt;BR&gt; tag is now handled inline where it is replaced by a linefeed or \n.</comment>
                    <comment type="line">//case 544: // &lt;BR&gt;</comment>
                    <comment type="line">//case 800: // &lt;br&gt;</comment>
                    <comment type="line">//    m_forceLineBreak = true;</comment>
                    <comment type="line">//    return true;</comment>
                    <case>case <expr><literal type="number">43969</literal></expr>:</case> <comment type="line">// &lt;nobr&gt;</comment>
                    <case>case <expr><literal type="number">31169</literal></expr>:</case> <comment type="line">// &lt;NOBR&gt;</comment>
                        <expr_stmt><expr><name>m_isNonBreakingSpace</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                    <case>case <expr><literal type="number">156816</literal></expr>:</case> <comment type="line">// &lt;/nobr&gt;</comment>
                    <case>case <expr><literal type="number">144016</literal></expr>:</case> <comment type="line">// &lt;/NOBR&gt;</comment>
                        <expr_stmt><expr><name>m_isNonBreakingSpace</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
                        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                    <case>case <expr><literal type="number">45545</literal></expr>:</case> <comment type="line">// &lt;size=&gt;</comment>
                    <case>case <expr><literal type="number">32745</literal></expr>:</case> <comment type="line">// &lt;SIZE&gt;</comment>
                        <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>ConvertToFloat</name><argument_list>(<argument><expr><name>m_htmlTag</name></expr></argument>, <argument><expr><name><name>m_xmlAttribute</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>valueStartIndex</name></expr></argument>, <argument><expr><name><name>m_xmlAttribute</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>valueLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if>if <condition>(<expr><name>value</name> <operator>==</operator> <operator>-</operator><literal type="number">9999</literal></expr>)</condition><then> <block type="pseudo"><return>return <expr><literal type="boolean">false</literal></expr>;</return></block></then></if>

                        <switch>switch <condition>(<expr><name>tagUnits</name></expr>)</condition>
                        <block>{
                            <case>case <expr><name><name>TagUnits</name><operator>.</operator><name>Pixels</name></name></expr>:</case>
                                <if>if <condition>(<expr><name><name>m_htmlTag</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>==</operator> <literal type="number">43</literal></expr>)</condition><then> <comment type="line">// &lt;size=+00&gt;</comment>
                                <block>{
                                    <expr_stmt><expr><name>m_currentFontSize</name> <operator>=</operator> <name>m_fontSize</name> <operator>+</operator> <name>value</name></expr>;</expr_stmt>
                                    <expr_stmt><expr><call><name><name>m_sizeStack</name><operator>.</operator><name>Add</name></name><argument_list>(<argument><expr><name>m_currentFontSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                    <expr_stmt><expr><name>m_fontScale</name> <operator>=</operator> <operator>(</operator><name>m_currentFontSize</name> <operator>/</operator> <name><name>m_currentFontAsset</name><operator>.</operator><name>fontInfo</name><operator>.</operator><name>PointSize</name></name> <operator>*</operator> <name><name>m_currentFontAsset</name><operator>.</operator><name>fontInfo</name><operator>.</operator><name>Scale</name></name> <operator>*</operator> <operator>(</operator><ternary><condition><expr><name>m_isOrthographic</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0.1f</literal></expr></else></ternary><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
                                    <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                                }</block></then>
                                <elseif>else <if>if <condition>(<expr><name><name>m_htmlTag</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>==</operator> <literal type="number">45</literal></expr>)</condition><then> <comment type="line">// &lt;size=-00&gt;</comment>
                                <block>{
                                    <expr_stmt><expr><name>m_currentFontSize</name> <operator>=</operator> <name>m_fontSize</name> <operator>+</operator> <name>value</name></expr>;</expr_stmt>
                                    <expr_stmt><expr><call><name><name>m_sizeStack</name><operator>.</operator><name>Add</name></name><argument_list>(<argument><expr><name>m_currentFontSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                    <expr_stmt><expr><name>m_fontScale</name> <operator>=</operator> <operator>(</operator><name>m_currentFontSize</name> <operator>/</operator> <name><name>m_currentFontAsset</name><operator>.</operator><name>fontInfo</name><operator>.</operator><name>PointSize</name></name> <operator>*</operator> <name><name>m_currentFontAsset</name><operator>.</operator><name>fontInfo</name><operator>.</operator><name>Scale</name></name> <operator>*</operator> <operator>(</operator><ternary><condition><expr><name>m_isOrthographic</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0.1f</literal></expr></else></ternary><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
                                    <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                                }</block></then></if></elseif>
                                <else>else <comment type="line">// &lt;size=00.0&gt;</comment>
                                <block>{
                                    <expr_stmt><expr><name>m_currentFontSize</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
                                    <expr_stmt><expr><call><name><name>m_sizeStack</name><operator>.</operator><name>Add</name></name><argument_list>(<argument><expr><name>m_currentFontSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                    <expr_stmt><expr><name>m_fontScale</name> <operator>=</operator> <operator>(</operator><name>m_currentFontSize</name> <operator>/</operator> <name><name>m_currentFontAsset</name><operator>.</operator><name>fontInfo</name><operator>.</operator><name>PointSize</name></name> <operator>*</operator> <name><name>m_currentFontAsset</name><operator>.</operator><name>fontInfo</name><operator>.</operator><name>Scale</name></name> <operator>*</operator> <operator>(</operator><ternary><condition><expr><name>m_isOrthographic</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0.1f</literal></expr></else></ternary><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
                                    <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                                }</block></else></if>
                            <case>case <expr><name><name>TagUnits</name><operator>.</operator><name>FontUnits</name></name></expr>:</case>
                                <expr_stmt><expr><name>m_currentFontSize</name> <operator>=</operator> <name>m_fontSize</name> <operator>*</operator> <name>value</name></expr>;</expr_stmt>
                                <expr_stmt><expr><call><name><name>m_sizeStack</name><operator>.</operator><name>Add</name></name><argument_list>(<argument><expr><name>m_currentFontSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <expr_stmt><expr><name>m_fontScale</name> <operator>=</operator> <operator>(</operator><name>m_currentFontSize</name> <operator>/</operator> <name><name>m_currentFontAsset</name><operator>.</operator><name>fontInfo</name><operator>.</operator><name>PointSize</name></name> <operator>*</operator> <name><name>m_currentFontAsset</name><operator>.</operator><name>fontInfo</name><operator>.</operator><name>Scale</name></name> <operator>*</operator> <operator>(</operator><ternary><condition><expr><name>m_isOrthographic</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0.1f</literal></expr></else></ternary><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
                                <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                            <case>case <expr><name><name>TagUnits</name><operator>.</operator><name>Percentage</name></name></expr>:</case>
                                <expr_stmt><expr><name>m_currentFontSize</name> <operator>=</operator> <name>m_fontSize</name> <operator>*</operator> <name>value</name> <operator>/</operator> <literal type="number">100</literal></expr>;</expr_stmt>
                                <expr_stmt><expr><call><name><name>m_sizeStack</name><operator>.</operator><name>Add</name></name><argument_list>(<argument><expr><name>m_currentFontSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <expr_stmt><expr><name>m_fontScale</name> <operator>=</operator> <operator>(</operator><name>m_currentFontSize</name> <operator>/</operator> <name><name>m_currentFontAsset</name><operator>.</operator><name>fontInfo</name><operator>.</operator><name>PointSize</name></name> <operator>*</operator> <name><name>m_currentFontAsset</name><operator>.</operator><name>fontInfo</name><operator>.</operator><name>Scale</name></name> <operator>*</operator> <operator>(</operator><ternary><condition><expr><name>m_isOrthographic</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0.1f</literal></expr></else></ternary><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
                                <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                        }</block></switch>
                        <return>return <expr><literal type="boolean">false</literal></expr>;</return>
                    <case>case <expr><literal type="number">158392</literal></expr>:</case> <comment type="line">// &lt;/size&gt;</comment>
                    <case>case <expr><literal type="number">145592</literal></expr>:</case> <comment type="line">// &lt;/SIZE&gt;</comment>
                        <expr_stmt><expr><name>m_currentFontSize</name> <operator>=</operator> <call><name><name>m_sizeStack</name><operator>.</operator><name>Remove</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>m_fontScale</name> <operator>=</operator> <operator>(</operator><name>m_currentFontSize</name> <operator>/</operator> <name><name>m_currentFontAsset</name><operator>.</operator><name>fontInfo</name><operator>.</operator><name>PointSize</name></name> <operator>*</operator> <name><name>m_currentFontAsset</name><operator>.</operator><name>fontInfo</name><operator>.</operator><name>Scale</name></name> <operator>*</operator> <operator>(</operator><ternary><condition><expr><name>m_isOrthographic</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0.1f</literal></expr></else></ternary><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
                        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                    <case>case <expr><literal type="number">41311</literal></expr>:</case> <comment type="line">// &lt;font=xx&gt;</comment>
                    <case>case <expr><literal type="number">28511</literal></expr>:</case> <comment type="line">// &lt;FONT&gt;</comment>
                        <comment type="line">//Debug.Log("Font name: \"" + new string(m_htmlTag, m_xmlAttribute[0].valueStartIndex, m_xmlAttribute[0].valueLength) + "\"   HashCode: " + m_xmlAttribute[0].valueHashCode + "   Material Name: \"" + new string(m_htmlTag, m_xmlAttribute[1].valueStartIndex, m_xmlAttribute[1].valueLength) + "\"   Hashcode: " + m_xmlAttribute[1].valueHashCode);</comment>

                        <decl_stmt><decl><type><name>int</name></type> <name>fontHashCode</name> <init>= <expr><name><name>m_xmlAttribute</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>valueHashCode</name></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>int</name></type> <name>materialAttributeHashCode</name> <init>= <expr><name><name>m_xmlAttribute</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>nameHashCode</name></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>int</name></type> <name>materialHashCode</name> <init>= <expr><name><name>m_xmlAttribute</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>valueHashCode</name></expr></init></decl>;</decl_stmt>

                        <comment type="line">// Special handling for &lt;font=default&gt; or &lt;font=Default&gt;</comment>
                        <if>if <condition>(<expr><name>fontHashCode</name> <operator>==</operator> <literal type="number">764638571</literal> <operator>||</operator> <name>fontHashCode</name> <operator>==</operator> <literal type="number">523367755</literal></expr>)</condition><then>
                        <block>{
                            <expr_stmt><expr><name>m_currentFontAsset</name> <operator>=</operator> <name><name>m_materialReferences</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>fontAsset</name></expr>;</expr_stmt>
                            <expr_stmt><expr><name>m_currentMaterial</name> <operator>=</operator> <name><name>m_materialReferences</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>material</name></expr>;</expr_stmt>
                            <expr_stmt><expr><name>m_currentMaterialIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                            <comment type="line">//Debug.Log("&lt;font=Default&gt; assigning Font Asset [" + m_currentFontAsset.name + "] with Material [" + m_currentMaterial.name + "].");</comment>

                            <expr_stmt><expr><name>m_fontScale</name> <operator>=</operator> <operator>(</operator><name>m_currentFontSize</name> <operator>/</operator> <name><name>m_currentFontAsset</name><operator>.</operator><name>fontInfo</name><operator>.</operator><name>PointSize</name></name> <operator>*</operator> <name><name>m_currentFontAsset</name><operator>.</operator><name>fontInfo</name><operator>.</operator><name>Scale</name></name> <operator>*</operator> <operator>(</operator><ternary><condition><expr><name>m_isOrthographic</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0.1f</literal></expr></else></ternary><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

                            <expr_stmt><expr><call><name><name>m_materialReferenceStack</name><operator>.</operator><name>Add</name></name><argument_list>(<argument><expr><name><name>m_materialReferences</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                            <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                        }</block></then></if>

                        <decl_stmt><decl><type><name>TMP_FontAsset</name></type> <name>tempFont</name></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>Material</name></type> <name>tempMaterial</name></decl>;</decl_stmt>

                        <comment type="line">// HANDLE NEW FONT ASSET</comment>
                        <if>if <condition>(<expr><call><name><name>MaterialReferenceManager</name><operator>.</operator><name>TryGetFontAsset</name></name><argument_list>(<argument><expr><name>fontHashCode</name></expr></argument>, <argument><modifier>out</modifier> <expr><name>tempFont</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                        <block>{
                            <comment type="line">//if (tempFont != m_currentFontAsset)</comment>
                            <comment type="line">//{</comment>
                            <comment type="line">//    //Debug.Log("Assigning Font Asset: " + tempFont.name);</comment>
                            <comment type="line">//    m_currentFontAsset = tempFont;</comment>
                            <comment type="line">//    m_fontScale = (m_currentFontSize / m_currentFontAsset.fontInfo.PointSize * m_currentFontAsset.fontInfo.Scale * (m_isOrthographic ? 1 : 0.1f));</comment>
                            <comment type="line">//}</comment>
                        }</block></then>
                        <else>else
                        <block>{
                            <comment type="line">// Load Font Asset</comment>
                            <expr_stmt><expr><name>tempFont</name> <operator>=</operator> <call><name><name>Resources</name><operator>.</operator><name><name>Load</name><argument_list type="generic">&lt;<argument><name>TMP_FontAsset</name></argument>&gt;</argument_list></name></name><argument_list>(<argument><expr><name><name>TMP_Settings</name><operator>.</operator><name>defaultFontAssetPath</name></name> <operator>+</operator> <operator>new</operator> <call><name>string</name><argument_list>(<argument><expr><name>m_htmlTag</name></expr></argument>, <argument><expr><name><name>m_xmlAttribute</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>valueStartIndex</name></expr></argument>, <argument><expr><name><name>m_xmlAttribute</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>valueLength</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                            <if>if <condition>(<expr><name>tempFont</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then>
                                <block type="pseudo"><return>return <expr><literal type="boolean">false</literal></expr>;</return></block></then></if>

                            <comment type="line">// Add new reference to the font asset as well as default material to the MaterialReferenceManager</comment>
                            <expr_stmt><expr><call><name><name>MaterialReferenceManager</name><operator>.</operator><name>AddFontAsset</name></name><argument_list>(<argument><expr><name>tempFont</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        }</block></else></if>


                        <comment type="line">// HANDLE NEW MATERIAL</comment>
                        <if>if <condition>(<expr><name>materialAttributeHashCode</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>materialHashCode</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then>
                        <block>{
                            <comment type="line">// No material specified then use default font asset material.</comment>
                            <expr_stmt><expr><name>m_currentMaterial</name> <operator>=</operator> <name><name>tempFont</name><operator>.</operator><name>material</name></name></expr>;</expr_stmt>

                            <expr_stmt><expr><name>m_currentMaterialIndex</name> <operator>=</operator> <call><name><name>MaterialReference</name><operator>.</operator><name>AddMaterialReference</name></name><argument_list>(<argument><expr><name>m_currentMaterial</name></expr></argument>, <argument><expr><name>tempFont</name></expr></argument>, <argument><expr><name>m_materialReferences</name></expr></argument>, <argument><expr><name>m_materialReferenceIndexLookup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                            <expr_stmt><expr><call><name><name>m_materialReferenceStack</name><operator>.</operator><name>Add</name></name><argument_list>(<argument><expr><name><name>m_materialReferences</name><index>[<expr><name>m_currentMaterialIndex</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        }</block></then>
                        <elseif>else <if>if <condition>(<expr><name>materialAttributeHashCode</name> <operator>==</operator> <literal type="number">103415287</literal> <operator>||</operator> <name>materialAttributeHashCode</name> <operator>==</operator> <literal type="number">72669687</literal></expr>)</condition><then> <comment type="line">// using material attribute</comment>
                        <block>{
                            <if>if <condition>(<expr><call><name><name>MaterialReferenceManager</name><operator>.</operator><name>TryGetMaterial</name></name><argument_list>(<argument><expr><name>materialHashCode</name></expr></argument>, <argument><modifier>out</modifier> <expr><name>tempMaterial</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                            <block>{
                                <expr_stmt><expr><name>m_currentMaterial</name> <operator>=</operator> <name>tempMaterial</name></expr>;</expr_stmt>

                                <expr_stmt><expr><name>m_currentMaterialIndex</name> <operator>=</operator> <call><name><name>MaterialReference</name><operator>.</operator><name>AddMaterialReference</name></name><argument_list>(<argument><expr><name>m_currentMaterial</name></expr></argument>, <argument><expr><name>tempFont</name></expr></argument>, <argument><expr><name>m_materialReferences</name></expr></argument>, <argument><expr><name>m_materialReferenceIndexLookup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                                <expr_stmt><expr><call><name><name>m_materialReferenceStack</name><operator>.</operator><name>Add</name></name><argument_list>(<argument><expr><name><name>m_materialReferences</name><index>[<expr><name>m_currentMaterialIndex</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            }</block></then>
                            <else>else
                            <block>{
                                <comment type="line">// Load new material</comment>
                                <expr_stmt><expr><name>tempMaterial</name> <operator>=</operator> <call><name><name>Resources</name><operator>.</operator><name><name>Load</name><argument_list type="generic">&lt;<argument><name>Material</name></argument>&gt;</argument_list></name></name><argument_list>(<argument><expr><name><name>TMP_Settings</name><operator>.</operator><name>defaultFontAssetPath</name></name> <operator>+</operator> <operator>new</operator> <call><name>string</name><argument_list>(<argument><expr><name>m_htmlTag</name></expr></argument>, <argument><expr><name><name>m_xmlAttribute</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>valueStartIndex</name></expr></argument>, <argument><expr><name><name>m_xmlAttribute</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>valueLength</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                                <if>if <condition>(<expr><name>tempMaterial</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then>
                                    <block type="pseudo"><return>return <expr><literal type="boolean">false</literal></expr>;</return></block></then></if>

                                <comment type="line">// Add new reference to this material in the MaterialReferenceManager</comment>
                                <expr_stmt><expr><call><name><name>MaterialReferenceManager</name><operator>.</operator><name>AddFontMaterial</name></name><argument_list>(<argument><expr><name>materialHashCode</name></expr></argument>, <argument><expr><name>tempMaterial</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                                <expr_stmt><expr><name>m_currentMaterial</name> <operator>=</operator> <name>tempMaterial</name></expr>;</expr_stmt>

                                <expr_stmt><expr><name>m_currentMaterialIndex</name> <operator>=</operator> <call><name><name>MaterialReference</name><operator>.</operator><name>AddMaterialReference</name></name><argument_list>(<argument><expr><name>m_currentMaterial</name></expr></argument>, <argument><expr><name>tempFont</name></expr></argument>, <argument><expr><name>m_materialReferences</name></expr></argument>, <argument><expr><name>m_materialReferenceIndexLookup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                                <expr_stmt><expr><call><name><name>m_materialReferenceStack</name><operator>.</operator><name>Add</name></name><argument_list>(<argument><expr><name><name>m_materialReferences</name><index>[<expr><name>m_currentMaterialIndex</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            }</block></else></if>
                        }</block></then></if></elseif>
                        <else>else
                            <block type="pseudo"><return>return <expr><literal type="boolean">false</literal></expr>;</return></block></else></if>

                        <expr_stmt><expr><name>m_currentFontAsset</name> <operator>=</operator> <name>tempFont</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>m_fontScale</name> <operator>=</operator> <operator>(</operator><name>m_currentFontSize</name> <operator>/</operator> <name><name>m_currentFontAsset</name><operator>.</operator><name>fontInfo</name><operator>.</operator><name>PointSize</name></name> <operator>*</operator> <name><name>m_currentFontAsset</name><operator>.</operator><name>fontInfo</name><operator>.</operator><name>Scale</name></name> <operator>*</operator> <operator>(</operator><ternary><condition><expr><name>m_isOrthographic</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0.1f</literal></expr></else></ternary><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

                        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                    <case>case <expr><literal type="number">154158</literal></expr>:</case> <comment type="line">// &lt;/font&gt;</comment>
                    <case>case <expr><literal type="number">141358</literal></expr>:</case> <comment type="line">// &lt;/FONT&gt;</comment>
                        <block>{
                            <decl_stmt><decl><type><name>MaterialReference</name></type> <name>materialReference</name> <init>= <expr><call><name><name>m_materialReferenceStack</name><operator>.</operator><name>Remove</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

                            <expr_stmt><expr><name>m_currentFontAsset</name> <operator>=</operator> <name><name>materialReference</name><operator>.</operator><name>fontAsset</name></name></expr>;</expr_stmt>
                            <expr_stmt><expr><name>m_currentMaterial</name> <operator>=</operator> <name><name>materialReference</name><operator>.</operator><name>material</name></name></expr>;</expr_stmt>
                            <expr_stmt><expr><name>m_currentMaterialIndex</name> <operator>=</operator> <name><name>materialReference</name><operator>.</operator><name>index</name></name></expr>;</expr_stmt>

                            <expr_stmt><expr><name>m_fontScale</name> <operator>=</operator> <operator>(</operator><name>m_currentFontSize</name> <operator>/</operator> <name><name>m_currentFontAsset</name><operator>.</operator><name>fontInfo</name><operator>.</operator><name>PointSize</name></name> <operator>*</operator> <name><name>m_currentFontAsset</name><operator>.</operator><name>fontInfo</name><operator>.</operator><name>Scale</name></name> <operator>*</operator> <operator>(</operator><ternary><condition><expr><name>m_isOrthographic</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0.1f</literal></expr></else></ternary><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

                            <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                        }</block>
                    <case>case <expr><literal type="number">103415287</literal></expr>:</case> <comment type="line">// &lt;material="material name"&gt;</comment>
                    <case>case <expr><literal type="number">72669687</literal></expr>:</case> <comment type="line">// &lt;MATERIAL&gt;</comment>
                        <expr_stmt><expr><name>materialHashCode</name> <operator>=</operator> <name><name>m_xmlAttribute</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>valueHashCode</name></expr>;</expr_stmt>

                        <comment type="line">// Special handling for &lt;material=default&gt; or &lt;material=Default&gt;</comment>
                        <if>if <condition>(<expr><name>materialHashCode</name> <operator>==</operator> <literal type="number">764638571</literal> <operator>||</operator> <name>materialHashCode</name> <operator>==</operator> <literal type="number">523367755</literal></expr>)</condition><then>
                        <block>{
                            <comment type="line">// Check if material font atlas texture matches that of the current font asset.</comment>
                            <comment type="line">//if (m_currentFontAsset.atlas.GetInstanceID() != m_currentMaterial.GetTexture(ShaderUtilities.ID_MainTex).GetInstanceID()) return false;</comment>

                            <expr_stmt><expr><name>m_currentMaterial</name> <operator>=</operator> <name><name>m_materialReferences</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>material</name></expr>;</expr_stmt>
                            <expr_stmt><expr><name>m_currentMaterialIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

                            <expr_stmt><expr><call><name><name>m_materialReferenceStack</name><operator>.</operator><name>Add</name></name><argument_list>(<argument><expr><name><name>m_materialReferences</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                            <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                        }</block></then></if>


                        <comment type="line">// Check if material </comment>
                        <if>if <condition>(<expr><call><name><name>MaterialReferenceManager</name><operator>.</operator><name>TryGetMaterial</name></name><argument_list>(<argument><expr><name>materialHashCode</name></expr></argument>, <argument><modifier>out</modifier> <expr><name>tempMaterial</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                        <block>{
                            <comment type="line">// Check if material font atlas texture matches that of the current font asset.</comment>
                            <comment type="line">//if (m_currentFontAsset.atlas.GetInstanceID() != tempMaterial.GetTexture(ShaderUtilities.ID_MainTex).GetInstanceID()) return false;</comment>

                            <expr_stmt><expr><name>m_currentMaterial</name> <operator>=</operator> <name>tempMaterial</name></expr>;</expr_stmt>

                            <expr_stmt><expr><name>m_currentMaterialIndex</name> <operator>=</operator> <call><name><name>MaterialReference</name><operator>.</operator><name>AddMaterialReference</name></name><argument_list>(<argument><expr><name>m_currentMaterial</name></expr></argument>, <argument><expr><name>m_currentFontAsset</name></expr></argument>, <argument><expr><name>m_materialReferences</name></expr></argument>, <argument><expr><name>m_materialReferenceIndexLookup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                            <expr_stmt><expr><call><name><name>m_materialReferenceStack</name><operator>.</operator><name>Add</name></name><argument_list>(<argument><expr><name><name>m_materialReferences</name><index>[<expr><name>m_currentMaterialIndex</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        }</block></then>
                        <else>else
                        <block>{
                            <comment type="line">// Load new material</comment>
                            <expr_stmt><expr><name>tempMaterial</name> <operator>=</operator> <call><name><name>Resources</name><operator>.</operator><name><name>Load</name><argument_list type="generic">&lt;<argument><name>Material</name></argument>&gt;</argument_list></name></name><argument_list>(<argument><expr><name><name>TMP_Settings</name><operator>.</operator><name>defaultFontAssetPath</name></name> <operator>+</operator> <operator>new</operator> <call><name>string</name><argument_list>(<argument><expr><name>m_htmlTag</name></expr></argument>, <argument><expr><name><name>m_xmlAttribute</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>valueStartIndex</name></expr></argument>, <argument><expr><name><name>m_xmlAttribute</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>valueLength</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                            <if>if <condition>(<expr><name>tempMaterial</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then>
                                <block type="pseudo"><return>return <expr><literal type="boolean">false</literal></expr>;</return></block></then></if>

                            <comment type="line">// Check if material font atlas texture matches that of the current font asset.</comment>
                            <comment type="line">//if (m_currentFontAsset.atlas.GetInstanceID() != tempMaterial.GetTexture(ShaderUtilities.ID_MainTex).GetInstanceID()) return false;</comment>

                            <comment type="line">// Add new reference to this material in the MaterialReferenceManager</comment>
                            <expr_stmt><expr><call><name><name>MaterialReferenceManager</name><operator>.</operator><name>AddFontMaterial</name></name><argument_list>(<argument><expr><name>materialHashCode</name></expr></argument>, <argument><expr><name>tempMaterial</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                            <expr_stmt><expr><name>m_currentMaterial</name> <operator>=</operator> <name>tempMaterial</name></expr>;</expr_stmt>

                            <expr_stmt><expr><name>m_currentMaterialIndex</name> <operator>=</operator> <call><name><name>MaterialReference</name><operator>.</operator><name>AddMaterialReference</name></name><argument_list>(<argument><expr><name>m_currentMaterial</name></expr></argument>, <argument><expr><name>m_currentFontAsset</name></expr></argument> , <argument><expr><name>m_materialReferences</name></expr></argument>, <argument><expr><name>m_materialReferenceIndexLookup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                            <expr_stmt><expr><call><name><name>m_materialReferenceStack</name><operator>.</operator><name>Add</name></name><argument_list>(<argument><expr><name><name>m_materialReferences</name><index>[<expr><name>m_currentMaterialIndex</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        }</block></else></if>
                        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                    <case>case <expr><literal type="number">374360934</literal></expr>:</case> <comment type="line">// &lt;/material&gt;</comment>
                    <case>case <expr><literal type="number">343615334</literal></expr>:</case> <comment type="line">// &lt;/MATERIAL&gt;</comment>
                        <block>{
                            <comment type="line">//if (m_currentMaterial.GetTexture(ShaderUtilities.ID_MainTex).GetInstanceID() != m_materialReferenceStack.PreviousItem().material.GetTexture(ShaderUtilities.ID_MainTex).GetInstanceID())</comment>
                            <comment type="line">//    return false;</comment>

                            <decl_stmt><decl><type><name>MaterialReference</name></type> <name>materialReference</name> <init>= <expr><call><name><name>m_materialReferenceStack</name><operator>.</operator><name>Remove</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

                            <expr_stmt><expr><name>m_currentMaterial</name> <operator>=</operator> <name><name>materialReference</name><operator>.</operator><name>material</name></name></expr>;</expr_stmt>
                            <expr_stmt><expr><name>m_currentMaterialIndex</name> <operator>=</operator> <name><name>materialReference</name><operator>.</operator><name>index</name></name></expr>;</expr_stmt>

                            <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                        }</block>
                    <case>case <expr><literal type="number">320078</literal></expr>:</case> <comment type="line">// &lt;space=000.00&gt;</comment>
                    <case>case <expr><literal type="number">230446</literal></expr>:</case> <comment type="line">// &lt;SPACE&gt;</comment>
                        <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>ConvertToFloat</name><argument_list>(<argument><expr><name>m_htmlTag</name></expr></argument>, <argument><expr><name><name>m_xmlAttribute</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>valueStartIndex</name></expr></argument>, <argument><expr><name><name>m_xmlAttribute</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>valueLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if>if <condition>(<expr><name>value</name> <operator>==</operator> <operator>-</operator><literal type="number">9999</literal></expr>)</condition><then> <block type="pseudo"><return>return <expr><literal type="boolean">false</literal></expr>;</return></block></then></if>

                        <switch>switch <condition>(<expr><name>tagUnits</name></expr>)</condition>
                        <block>{
                            <case>case <expr><name><name>TagUnits</name><operator>.</operator><name>Pixels</name></name></expr>:</case>
                                <expr_stmt><expr><name>m_xAdvance</name> <operator>+=</operator> <name>value</name></expr>;</expr_stmt>
                                <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                            <case>case <expr><name><name>TagUnits</name><operator>.</operator><name>FontUnits</name></name></expr>:</case>
                                <expr_stmt><expr><name>m_xAdvance</name> <operator>+=</operator> <name>value</name> <operator>*</operator> <name>m_fontScale</name> <operator>*</operator> <name><name>m_fontAsset</name><operator>.</operator><name>fontInfo</name><operator>.</operator><name>TabWidth</name></name> <operator>/</operator> <name><name>m_fontAsset</name><operator>.</operator><name>tabSize</name></name></expr>;</expr_stmt>
                                <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                            <case>case <expr><name><name>TagUnits</name><operator>.</operator><name>Percentage</name></name></expr>:</case>
                                <comment type="line">// Not applicable</comment>
                                <return>return <expr><literal type="boolean">false</literal></expr>;</return>
                        }</block></switch>
                        <return>return <expr><literal type="boolean">false</literal></expr>;</return>
                    <case>case <expr><literal type="number">276254</literal></expr>:</case> <comment type="line">// &lt;alpha=#FF&gt;</comment>
                    <case>case <expr><literal type="number">186622</literal></expr>:</case> <comment type="line">// &lt;ALPHA&gt;</comment>
                        <if>if <condition>(<expr><name><name>m_xmlAttribute</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>valueLength</name> <operator>!=</operator> <literal type="number">3</literal></expr>)</condition><then> <block type="pseudo"><return>return <expr><literal type="boolean">false</literal></expr>;</return></block></then></if>

                        <expr_stmt><expr><name><name>m_htmlColor</name><operator>.</operator><name>a</name></name> <operator>=</operator> <call>(<name>byte</name>)<argument_list>(<argument><expr><call><name>HexToInt</name><argument_list>(<argument><expr><name><name>m_htmlTag</name><index>[<expr><literal type="number">7</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">16</literal> <operator>+</operator> <call><name>HexToInt</name><argument_list>(<argument><expr><name><name>m_htmlTag</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <return>return <expr><literal type="boolean">true</literal></expr>;</return>

                    <case>case <expr><literal type="number">1750458</literal></expr>:</case> <comment type="line">// &lt;a name=" "&gt;</comment>
                        <return>return <expr><literal type="boolean">false</literal></expr>;</return>
                    <case>case <expr><literal type="number">426</literal></expr>:</case> <comment type="line">// &lt;/a&gt;</comment>
                        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                    <case>case <expr><literal type="number">43066</literal></expr>:</case> <comment type="line">// &lt;link="name"&gt;</comment>
                    <case>case <expr><literal type="number">30266</literal></expr>:</case> <comment type="line">// &lt;LINK&gt;</comment>
                        <if>if <condition>(<expr><name>m_isParsingText</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>m_isCalculatingPreferredValues</name></expr>)</condition><then>
                        <block>{
                            <decl_stmt><decl><type><name>int</name></type> <name>index</name> <init>= <expr><name><name>m_textInfo</name><operator>.</operator><name>linkCount</name></name></expr></init></decl>;</decl_stmt>

                            <if>if <condition>(<expr><name>index</name> <operator>+</operator> <literal type="number">1</literal> <operator>&gt;</operator> <name><name>m_textInfo</name><operator>.</operator><name>linkInfo</name><operator>.</operator><name>Length</name></name></expr>)</condition><then>
                                <block type="pseudo"><expr_stmt><expr><call><name><name>TMP_TextInfo</name><operator>.</operator><name>Resize</name></name><argument_list>(<argument><modifier>ref</modifier> <expr><name><name>m_textInfo</name><operator>.</operator><name>linkInfo</name></name></expr></argument>, <argument><expr><name>index</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block></then></if>

                            <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>linkInfo</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>textComponent</name> <operator>=</operator> <name>this</name></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>linkInfo</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>hashCode</name> <operator>=</operator> <name><name>m_xmlAttribute</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>valueHashCode</name></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>linkInfo</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>linkTextfirstCharacterIndex</name> <operator>=</operator> <name>m_characterCount</name></expr>;</expr_stmt>

                            <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>linkInfo</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>linkIdFirstCharacterIndex</name> <operator>=</operator> <name>startIndex</name> <operator>+</operator> <name><name>m_xmlAttribute</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>valueStartIndex</name></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>linkInfo</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>linkIdLength</name> <operator>=</operator> <name><name>m_xmlAttribute</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>valueLength</name></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>linkInfo</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><call><name>SetLinkID</name><argument_list>(<argument><expr><name>m_htmlTag</name></expr></argument>, <argument><expr><name><name>m_xmlAttribute</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>valueStartIndex</name></expr></argument>, <argument><expr><name><name>m_xmlAttribute</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>valueLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        }</block></then></if>
                        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                    <case>case <expr><literal type="number">155913</literal></expr>:</case> <comment type="line">// &lt;/link&gt;</comment>
                    <case>case <expr><literal type="number">143113</literal></expr>:</case> <comment type="line">// &lt;/LINK&gt;</comment>
                        <if>if <condition>(<expr><name>m_isParsingText</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>m_isCalculatingPreferredValues</name></expr>)</condition><then>
                        <block>{
                            <if>if <condition>(<expr><name><name>m_textInfo</name><operator>.</operator><name>linkCount</name></name> <operator>&lt;</operator> <name><name>m_textInfo</name><operator>.</operator><name>linkInfo</name><operator>.</operator><name>Length</name></name></expr>)</condition><then>
                            <block>{
                                <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>linkInfo</name><index>[<expr><name><name>m_textInfo</name><operator>.</operator><name>linkCount</name></name></expr>]</index></name><operator>.</operator><name>linkTextLength</name> <operator>=</operator> <name>m_characterCount</name> <operator>-</operator> <name><name>m_textInfo</name><operator>.</operator><name>linkInfo</name><index>[<expr><name><name>m_textInfo</name><operator>.</operator><name>linkCount</name></name></expr>]</index></name><operator>.</operator><name>linkTextfirstCharacterIndex</name></expr>;</expr_stmt>

                                <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>linkCount</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                            }</block></then></if>
                        }</block></then></if>
                        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                    <case>case <expr><literal type="number">275917</literal></expr>:</case> <comment type="line">// &lt;align=&gt;</comment>
                    <case>case <expr><literal type="number">186285</literal></expr>:</case> <comment type="line">// &lt;ALIGN&gt;</comment>
                        <switch>switch <condition>(<expr><name><name>m_xmlAttribute</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>valueHashCode</name></expr>)</condition>
                        <block>{
                            <case>case <expr><literal type="number">3774683</literal></expr>:</case> <comment type="line">// &lt;align=left&gt;</comment>
                                <expr_stmt><expr><name>m_lineJustification</name> <operator>=</operator> <name><name>TextAlignmentOptions</name><operator>.</operator><name>Left</name></name></expr>;</expr_stmt>
                                <expr_stmt><expr><call><name><name>m_lineJustificationStack</name><operator>.</operator><name>Add</name></name><argument_list>(<argument><expr><name>m_lineJustification</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                            <case>case <expr><literal type="number">136703040</literal></expr>:</case> <comment type="line">// &lt;align=right&gt;</comment>
                                <expr_stmt><expr><name>m_lineJustification</name> <operator>=</operator> <name><name>TextAlignmentOptions</name><operator>.</operator><name>Right</name></name></expr>;</expr_stmt>
                                <expr_stmt><expr><call><name><name>m_lineJustificationStack</name><operator>.</operator><name>Add</name></name><argument_list>(<argument><expr><name>m_lineJustification</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                            <case>case <expr><operator>-</operator><literal type="number">458210101</literal></expr>:</case> <comment type="line">// &lt;align=center&gt;</comment>
                                <expr_stmt><expr><name>m_lineJustification</name> <operator>=</operator> <name><name>TextAlignmentOptions</name><operator>.</operator><name>Center</name></name></expr>;</expr_stmt>
                                <expr_stmt><expr><call><name><name>m_lineJustificationStack</name><operator>.</operator><name>Add</name></name><argument_list>(<argument><expr><name>m_lineJustification</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                            <case>case <expr><operator>-</operator><literal type="number">523808257</literal></expr>:</case> <comment type="line">// &lt;align=justified&gt;</comment>
                                <expr_stmt><expr><name>m_lineJustification</name> <operator>=</operator> <name><name>TextAlignmentOptions</name><operator>.</operator><name>Justified</name></name></expr>;</expr_stmt>
                                <expr_stmt><expr><call><name><name>m_lineJustificationStack</name><operator>.</operator><name>Add</name></name><argument_list>(<argument><expr><name>m_lineJustification</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                            <case>case <expr><literal type="number">122383428</literal></expr>:</case> <comment type="line">// &lt;align=flush&gt;</comment>
                                <expr_stmt><expr><name>m_lineJustification</name> <operator>=</operator> <name><name>TextAlignmentOptions</name><operator>.</operator><name>Flush</name></name></expr>;</expr_stmt>
                                <expr_stmt><expr><call><name><name>m_lineJustificationStack</name><operator>.</operator><name>Add</name></name><argument_list>(<argument><expr><name>m_lineJustification</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                        }</block></switch>
                        <return>return <expr><literal type="boolean">false</literal></expr>;</return>
                    <case>case <expr><literal type="number">1065846</literal></expr>:</case> <comment type="line">// &lt;/align&gt;</comment>
                    <case>case <expr><literal type="number">976214</literal></expr>:</case> <comment type="line">// &lt;/ALIGN&gt;</comment>
                        <expr_stmt><expr><name>m_lineJustification</name> <operator>=</operator> <call><name><name>m_lineJustificationStack</name><operator>.</operator><name>Remove</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                    <case>case <expr><literal type="number">327550</literal></expr>:</case> <comment type="line">// &lt;width=xx&gt;</comment>
                    <case>case <expr><literal type="number">237918</literal></expr>:</case> <comment type="line">// &lt;WIDTH&gt;</comment>
                        <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>ConvertToFloat</name><argument_list>(<argument><expr><name>m_htmlTag</name></expr></argument>, <argument><expr><name><name>m_xmlAttribute</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>valueStartIndex</name></expr></argument>, <argument><expr><name><name>m_xmlAttribute</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>valueLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if>if <condition>(<expr><name>value</name> <operator>==</operator> <operator>-</operator><literal type="number">9999</literal></expr>)</condition><then> <block type="pseudo"><return>return <expr><literal type="boolean">false</literal></expr>;</return></block></then></if>

                        <switch>switch <condition>(<expr><name>tagUnits</name></expr>)</condition>
                        <block>{
                            <case>case <expr><name><name>TagUnits</name><operator>.</operator><name>Pixels</name></name></expr>:</case>
                                <expr_stmt><expr><name>m_width</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
                                <break>break;</break>
                            <case>case <expr><name><name>TagUnits</name><operator>.</operator><name>FontUnits</name></name></expr>:</case>
                                <return>return <expr><literal type="boolean">false</literal></expr>;</return>
                            <comment type="line">//break;</comment>
                            <case>case <expr><name><name>TagUnits</name><operator>.</operator><name>Percentage</name></name></expr>:</case>
                                <expr_stmt><expr><name>m_width</name> <operator>=</operator> <name>m_marginWidth</name> <operator>*</operator> <name>value</name> <operator>/</operator> <literal type="number">100</literal></expr>;</expr_stmt>
                                <break>break;</break>
                        }</block></switch>
                        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                    <case>case <expr><literal type="number">1117479</literal></expr>:</case> <comment type="line">// &lt;/width&gt;</comment>
                    <case>case <expr><literal type="number">1027847</literal></expr>:</case> <comment type="line">// &lt;/WIDTH&gt;</comment>
                        <expr_stmt><expr><name>m_width</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
                        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                    <comment type="line">// STYLE tag is now handled inline and replaced by its definition.</comment>
                    <comment type="line">//case 322689: // &lt;style="name"&gt;</comment>
                    <comment type="line">//case 233057: // &lt;STYLE&gt;</comment>
                    <comment type="line">//    TMP_Style style = TMP_StyleSheet.GetStyle(m_xmlAttribute[0].valueHashCode);</comment>

                    <comment type="line">//    if (style == null) return false;</comment>

                    <comment type="line">//    m_styleStack.Add(style.hashCode);</comment>

                    <comment type="line">//    // Parse Style Macro</comment>
                    <comment type="line">//    for (int i = 0; i &lt; style.styleOpeningTagArray.Length; i++)</comment>
                    <comment type="line">//    {</comment>
                    <comment type="line">//        if (style.styleOpeningTagArray[i] == 60)</comment>
                    <comment type="line">//        {</comment>
                    <comment type="line">//            if (ValidateHtmlTag(style.styleOpeningTagArray, i + 1, out i) == false) return false;</comment>
                    <comment type="line">//        }</comment>
                    <comment type="line">//    }</comment>
                    <comment type="line">//    return true;</comment>
                    <comment type="line">//case 1112618: // &lt;/style&gt;</comment>
                    <comment type="line">//case 1022986: // &lt;/STYLE&gt;</comment>
                    <comment type="line">//    style = TMP_StyleSheet.GetStyle(m_xmlAttribute[0].valueHashCode);</comment>

                    <comment type="line">//    if (style == null)</comment>
                    <comment type="line">//    {</comment>
                    <comment type="line">//        // Get style from the Style Stack</comment>
                    <comment type="line">//        int styleHashCode = m_styleStack.CurrentItem();</comment>
                    <comment type="line">//        style = TMP_StyleSheet.GetStyle(styleHashCode);</comment>

                    <comment type="line">//        m_styleStack.Remove();</comment>
                    <comment type="line">//    }</comment>

                    <comment type="line">//    if (style == null) return false;</comment>
                    <comment type="line">//    //// Parse Style Macro</comment>
                    <comment type="line">//    for (int i = 0; i &lt; style.styleClosingTagArray.Length; i++)</comment>
                    <comment type="line">//    {</comment>
                    <comment type="line">//        if (style.styleClosingTagArray[i] == 60)</comment>
                    <comment type="line">//            ValidateHtmlTag(style.styleClosingTagArray, i + 1, out i);</comment>
                    <comment type="line">//    }</comment>
                    <comment type="line">//    return true;</comment>
                    <case>case <expr><literal type="number">281955</literal></expr>:</case> <comment type="line">// &lt;color&gt; &lt;color=#FF00FF&gt; or &lt;color=#FF00FF00&gt;</comment>
                    <case>case <expr><literal type="number">192323</literal></expr>:</case> <comment type="line">// &lt;COLOR=#FF00FF&gt;</comment>
                        <comment type="line">// &lt;color=#FFF&gt; 3 Hex (short hand)</comment>
                        <if>if <condition>(<expr><name><name>m_htmlTag</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>==</operator> <literal type="number">35</literal> <operator>&amp;&amp;</operator> <name>tagCharCount</name> <operator>==</operator> <literal type="number">10</literal></expr>)</condition><then>
                        <block>{
                            <expr_stmt><expr><name>m_htmlColor</name> <operator>=</operator> <call><name>HexCharsToColor</name><argument_list>(<argument><expr><name>m_htmlTag</name></expr></argument>, <argument><expr><name>tagCharCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name><name>m_colorStack</name><operator>.</operator><name>Add</name></name><argument_list>(<argument><expr><name>m_htmlColor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                        }</block></then>
                        <comment type="line">// &lt;color=#FFF7&gt; 4 Hex (short hand)</comment>
                        <elseif>else <if>if <condition>(<expr><name><name>m_htmlTag</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>==</operator> <literal type="number">35</literal> <operator>&amp;&amp;</operator> <name>tagCharCount</name> <operator>==</operator> <literal type="number">11</literal></expr>)</condition><then>
                        <block>{
                            <expr_stmt><expr><name>m_htmlColor</name> <operator>=</operator> <call><name>HexCharsToColor</name><argument_list>(<argument><expr><name>m_htmlTag</name></expr></argument>, <argument><expr><name>tagCharCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name><name>m_colorStack</name><operator>.</operator><name>Add</name></name><argument_list>(<argument><expr><name>m_htmlColor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                        }</block></then></if></elseif></if>
                        <comment type="line">// &lt;color=#FF00FF&gt; 3 Hex pairs</comment>
                        <if>if <condition>(<expr><name><name>m_htmlTag</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>==</operator> <literal type="number">35</literal> <operator>&amp;&amp;</operator> <name>tagCharCount</name> <operator>==</operator> <literal type="number">13</literal></expr>)</condition><then>
                        <block>{
                            <expr_stmt><expr><name>m_htmlColor</name> <operator>=</operator> <call><name>HexCharsToColor</name><argument_list>(<argument><expr><name>m_htmlTag</name></expr></argument>, <argument><expr><name>tagCharCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name><name>m_colorStack</name><operator>.</operator><name>Add</name></name><argument_list>(<argument><expr><name>m_htmlColor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                        }</block></then>
                        <comment type="line">// &lt;color=#FF00FF00&gt; 4 Hex pairs</comment>
                        <elseif>else <if>if <condition>(<expr><name><name>m_htmlTag</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>==</operator> <literal type="number">35</literal> <operator>&amp;&amp;</operator> <name>tagCharCount</name> <operator>==</operator> <literal type="number">15</literal></expr>)</condition><then>
                        <block>{
                            <expr_stmt><expr><name>m_htmlColor</name> <operator>=</operator> <call><name>HexCharsToColor</name><argument_list>(<argument><expr><name>m_htmlTag</name></expr></argument>, <argument><expr><name>tagCharCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name><name>m_colorStack</name><operator>.</operator><name>Add</name></name><argument_list>(<argument><expr><name>m_htmlColor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                        }</block></then></if></elseif></if>

                        <comment type="line">// &lt;color=name&gt;</comment>
                        <switch>switch <condition>(<expr><name><name>m_xmlAttribute</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>valueHashCode</name></expr>)</condition>
                        <block>{
                            <case>case <expr><literal type="number">125395</literal></expr>:</case> <comment type="line">// &lt;color=red&gt;</comment>
                                <expr_stmt><expr><name>m_htmlColor</name> <operator>=</operator> <name><name>Color</name><operator>.</operator><name>red</name></name></expr>;</expr_stmt>
                                <expr_stmt><expr><call><name><name>m_colorStack</name><operator>.</operator><name>Add</name></name><argument_list>(<argument><expr><name>m_htmlColor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                            <case>case <expr><literal type="number">3573310</literal></expr>:</case> <comment type="line">// &lt;color=blue&gt;</comment>
                                <expr_stmt><expr><name>m_htmlColor</name> <operator>=</operator> <name><name>Color</name><operator>.</operator><name>blue</name></name></expr>;</expr_stmt>
                                <expr_stmt><expr><call><name><name>m_colorStack</name><operator>.</operator><name>Add</name></name><argument_list>(<argument><expr><name>m_htmlColor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                            <case>case <expr><literal type="number">117905991</literal></expr>:</case> <comment type="line">// &lt;color=black&gt;</comment>
                                <expr_stmt><expr><name>m_htmlColor</name> <operator>=</operator> <name><name>Color</name><operator>.</operator><name>black</name></name></expr>;</expr_stmt>
                                <expr_stmt><expr><call><name><name>m_colorStack</name><operator>.</operator><name>Add</name></name><argument_list>(<argument><expr><name>m_htmlColor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                            <case>case <expr><literal type="number">121463835</literal></expr>:</case> <comment type="line">// &lt;color=green&gt;</comment>
                                <expr_stmt><expr><name>m_htmlColor</name> <operator>=</operator> <name><name>Color</name><operator>.</operator><name>green</name></name></expr>;</expr_stmt>
                                <expr_stmt><expr><call><name><name>m_colorStack</name><operator>.</operator><name>Add</name></name><argument_list>(<argument><expr><name>m_htmlColor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                            <case>case <expr><literal type="number">140357351</literal></expr>:</case> <comment type="line">// &lt;color=white&gt;</comment>
                                <expr_stmt><expr><name>m_htmlColor</name> <operator>=</operator> <name><name>Color</name><operator>.</operator><name>white</name></name></expr>;</expr_stmt>
                                <expr_stmt><expr><call><name><name>m_colorStack</name><operator>.</operator><name>Add</name></name><argument_list>(<argument><expr><name>m_htmlColor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                            <case>case <expr><literal type="number">26556144</literal></expr>:</case> <comment type="line">// &lt;color=orange&gt;</comment>
                                <expr_stmt><expr><name>m_htmlColor</name> <operator>=</operator> <operator>new</operator> <call><name>Color32</name><argument_list>(<argument><expr><literal type="number">255</literal></expr></argument>, <argument><expr><literal type="number">128</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">255</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <expr_stmt><expr><call><name><name>m_colorStack</name><operator>.</operator><name>Add</name></name><argument_list>(<argument><expr><name>m_htmlColor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                            <case>case <expr><operator>-</operator><literal type="number">36881330</literal></expr>:</case> <comment type="line">// &lt;color=purple&gt;</comment>
                                <expr_stmt><expr><name>m_htmlColor</name> <operator>=</operator> <operator>new</operator> <call><name>Color32</name><argument_list>(<argument><expr><literal type="number">160</literal></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><literal type="number">240</literal></expr></argument>, <argument><expr><literal type="number">255</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <expr_stmt><expr><call><name><name>m_colorStack</name><operator>.</operator><name>Add</name></name><argument_list>(<argument><expr><name>m_htmlColor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                            <case>case <expr><literal type="number">554054276</literal></expr>:</case> <comment type="line">// &lt;color=yellow&gt;</comment>
                                <expr_stmt><expr><name>m_htmlColor</name> <operator>=</operator> <name><name>Color</name><operator>.</operator><name>yellow</name></name></expr>;</expr_stmt>
                                <expr_stmt><expr><call><name><name>m_colorStack</name><operator>.</operator><name>Add</name></name><argument_list>(<argument><expr><name>m_htmlColor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                        }</block></switch>
                        <return>return <expr><literal type="boolean">false</literal></expr>;</return>

                    <case>case <expr><literal type="number">100149144</literal></expr>:</case> <comment type="line">//&lt;gradient&gt;</comment>
                    <case>case <expr><literal type="number">69403544</literal></expr>:</case>  <comment type="line">// &lt;GRADIENT&gt;</comment>
                        <decl_stmt><decl><type><name>int</name></type> <name>gradientPresetHashCode</name> <init>= <expr><name><name>m_xmlAttribute</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>valueHashCode</name></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>TMP_ColorGradient</name></type> <name>tempColorGradientPreset</name></decl>;</decl_stmt>

                        <comment type="line">// Check if Color Gradient Preset has already been loaded.</comment>
                        <if>if <condition>(<expr><call><name><name>MaterialReferenceManager</name><operator>.</operator><name>TryGetColorGradientPreset</name></name><argument_list>(<argument><expr><name>gradientPresetHashCode</name></expr></argument>, <argument><modifier>out</modifier> <expr><name>tempColorGradientPreset</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                        <block>{
                            <expr_stmt><expr><name>m_colorGradientPreset</name> <operator>=</operator> <name>tempColorGradientPreset</name></expr>;</expr_stmt>
                        }</block></then>
                        <else>else
                        <block>{
                            <comment type="line">// Load Color Gradient Preset</comment>
                            <if>if <condition>(<expr><name>tempColorGradientPreset</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then>
                            <block>{
                                <expr_stmt><expr><name>tempColorGradientPreset</name> <operator>=</operator> <call><name><name>Resources</name><operator>.</operator><name><name>Load</name><argument_list type="generic">&lt;<argument><name>TMP_ColorGradient</name></argument>&gt;</argument_list></name></name><argument_list>(<argument><expr><name><name>TMP_Settings</name><operator>.</operator><name>defaultColorGradientPresetsPath</name></name> <operator>+</operator> <operator>new</operator> <call><name>string</name><argument_list>(<argument><expr><name>m_htmlTag</name></expr></argument>, <argument><expr><name><name>m_xmlAttribute</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>valueStartIndex</name></expr></argument>, <argument><expr><name><name>m_xmlAttribute</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>valueLength</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            }</block></then></if>

                            <if>if <condition>(<expr><name>tempColorGradientPreset</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then>
                                <block type="pseudo"><return>return <expr><literal type="boolean">false</literal></expr>;</return></block></then></if>

                            <expr_stmt><expr><call><name><name>MaterialReferenceManager</name><operator>.</operator><name>AddColorGradientPreset</name></name><argument_list>(<argument><expr><name>gradientPresetHashCode</name></expr></argument>, <argument><expr><name>tempColorGradientPreset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name>m_colorGradientPreset</name> <operator>=</operator> <name>tempColorGradientPreset</name></expr>;</expr_stmt>
                        }</block></else></if>

                        <expr_stmt><expr><call><name><name>m_colorGradientStack</name><operator>.</operator><name>Add</name></name><argument_list>(<argument><expr><name>m_colorGradientPreset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <comment type="line">// TODO : Add support for defining preset in the tag itself</comment>

                        <return>return <expr><literal type="boolean">true</literal></expr>;</return>

                    <case>case <expr><literal type="number">371094791</literal></expr>:</case> <comment type="line">// &lt;/gradient&gt;</comment>
                    <case>case <expr><literal type="number">340349191</literal></expr>:</case> <comment type="line">// &lt;/GRADIENT&gt;</comment>
                        <expr_stmt><expr><name>m_colorGradientPreset</name> <operator>=</operator> <call><name><name>m_colorGradientStack</name><operator>.</operator><name>Remove</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                        <return>return <expr><literal type="boolean">true</literal></expr>;</return>

                    <case>case <expr><literal type="number">1983971</literal></expr>:</case> <comment type="line">// &lt;cspace=xx.x&gt;</comment>
                    <case>case <expr><literal type="number">1356515</literal></expr>:</case> <comment type="line">// &lt;CSPACE&gt;</comment>
                        <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>ConvertToFloat</name><argument_list>(<argument><expr><name>m_htmlTag</name></expr></argument>, <argument><expr><name><name>m_xmlAttribute</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>valueStartIndex</name></expr></argument>, <argument><expr><name><name>m_xmlAttribute</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>valueLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if>if <condition>(<expr><name>value</name> <operator>==</operator> <operator>-</operator><literal type="number">9999</literal></expr>)</condition><then> <block type="pseudo"><return>return <expr><literal type="boolean">false</literal></expr>;</return></block></then></if>

                        <switch>switch <condition>(<expr><name>tagUnits</name></expr>)</condition>
                        <block>{
                            <case>case <expr><name><name>TagUnits</name><operator>.</operator><name>Pixels</name></name></expr>:</case>
                                <expr_stmt><expr><name>m_cSpacing</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
                                <break>break;</break>
                            <case>case <expr><name><name>TagUnits</name><operator>.</operator><name>FontUnits</name></name></expr>:</case>
                                <expr_stmt><expr><name>m_cSpacing</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
                                <expr_stmt><expr><name>m_cSpacing</name> <operator>*=</operator> <name>m_fontScale</name> <operator>*</operator> <name><name>m_fontAsset</name><operator>.</operator><name>fontInfo</name><operator>.</operator><name>TabWidth</name></name> <operator>/</operator> <name><name>m_fontAsset</name><operator>.</operator><name>tabSize</name></name></expr>;</expr_stmt>
                                <break>break;</break>
                            <case>case <expr><name><name>TagUnits</name><operator>.</operator><name>Percentage</name></name></expr>:</case>
                                <return>return <expr><literal type="boolean">false</literal></expr>;</return>
                        }</block></switch>
                        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                    <case>case <expr><literal type="number">7513474</literal></expr>:</case> <comment type="line">// &lt;/cspace&gt;</comment>
                    <case>case <expr><literal type="number">6886018</literal></expr>:</case> <comment type="line">// &lt;/CSPACE&gt;</comment>
                        <if>if <condition>(<expr><operator>!</operator><name>m_isParsingText</name></expr>)</condition><then> <block type="pseudo"><return>return <expr><literal type="boolean">true</literal></expr>;</return></block></then></if>

                        <comment type="line">// Adjust xAdvance to remove extra space from last character.</comment>
                        <if>if <condition>(<expr><name>m_characterCount</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><then>
                        <block>{
                            <expr_stmt><expr><name>m_xAdvance</name> <operator>-=</operator> <name>m_cSpacing</name></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>m_textInfo</name><operator>.</operator><name>characterInfo</name><index>[<expr><name>m_characterCount</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>xAdvance</name> <operator>=</operator> <name>m_xAdvance</name></expr>;</expr_stmt>
                        }</block></then></if>
                        <expr_stmt><expr><name>m_cSpacing</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                    <case>case <expr><literal type="number">2152041</literal></expr>:</case> <comment type="line">// &lt;mspace=xx.x&gt;</comment>
                    <case>case <expr><literal type="number">1524585</literal></expr>:</case> <comment type="line">// &lt;MSPACE&gt;</comment>
                        <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>ConvertToFloat</name><argument_list>(<argument><expr><name>m_htmlTag</name></expr></argument>, <argument><expr><name><name>m_xmlAttribute</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>valueStartIndex</name></expr></argument>, <argument><expr><name><name>m_xmlAttribute</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>valueLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if>if <condition>(<expr><name>value</name> <operator>==</operator> <operator>-</operator><literal type="number">9999</literal></expr>)</condition><then> <block type="pseudo"><return>return <expr><literal type="boolean">false</literal></expr>;</return></block></then></if>

                        <switch>switch <condition>(<expr><name>tagUnits</name></expr>)</condition>
                        <block>{
                            <case>case <expr><name><name>TagUnits</name><operator>.</operator><name>Pixels</name></name></expr>:</case>
                                <expr_stmt><expr><name>m_monoSpacing</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
                                <break>break;</break>
                            <case>case <expr><name><name>TagUnits</name><operator>.</operator><name>FontUnits</name></name></expr>:</case>
                                <expr_stmt><expr><name>m_monoSpacing</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
                                <expr_stmt><expr><name>m_monoSpacing</name> <operator>*=</operator> <name>m_fontScale</name> <operator>*</operator> <name><name>m_fontAsset</name><operator>.</operator><name>fontInfo</name><operator>.</operator><name>TabWidth</name></name> <operator>/</operator> <name><name>m_fontAsset</name><operator>.</operator><name>tabSize</name></name></expr>;</expr_stmt>
                                <break>break;</break>
                            <case>case <expr><name><name>TagUnits</name><operator>.</operator><name>Percentage</name></name></expr>:</case>
                                <return>return <expr><literal type="boolean">false</literal></expr>;</return>
                        }</block></switch>
                        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                    <case>case <expr><literal type="number">7681544</literal></expr>:</case> <comment type="line">// &lt;/mspace&gt;</comment>
                    <case>case <expr><literal type="number">7054088</literal></expr>:</case> <comment type="line">// &lt;/MSPACE&gt;</comment>
                        <expr_stmt><expr><name>m_monoSpacing</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                    <case>case <expr><literal type="number">280416</literal></expr>:</case> <comment type="line">// &lt;class="name"&gt;</comment>
                        <return>return <expr><literal type="boolean">false</literal></expr>;</return>
                    <case>case <expr><literal type="number">1071884</literal></expr>:</case> <comment type="line">// &lt;/color&gt;</comment>
                    <case>case <expr><literal type="number">982252</literal></expr>:</case> <comment type="line">// &lt;/COLOR&gt;</comment>
                        <expr_stmt><expr><name>m_htmlColor</name> <operator>=</operator> <call><name><name>m_colorStack</name><operator>.</operator><name>Remove</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                    <case>case <expr><literal type="number">2068980</literal></expr>:</case> <comment type="line">// &lt;indent=10px&gt; &lt;indent=10em&gt; &lt;indent=50%&gt;</comment>
                    <case>case <expr><literal type="number">1441524</literal></expr>:</case> <comment type="line">// &lt;INDENT&gt;</comment>
                        <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>ConvertToFloat</name><argument_list>(<argument><expr><name>m_htmlTag</name></expr></argument>, <argument><expr><name><name>m_xmlAttribute</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>valueStartIndex</name></expr></argument>, <argument><expr><name><name>m_xmlAttribute</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>valueLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if>if <condition>(<expr><name>value</name> <operator>==</operator> <operator>-</operator><literal type="number">9999</literal></expr>)</condition><then> <block type="pseudo"><return>return <expr><literal type="boolean">false</literal></expr>;</return></block></then></if>

                        <switch>switch <condition>(<expr><name>tagUnits</name></expr>)</condition>
                        <block>{
                            <case>case <expr><name><name>TagUnits</name><operator>.</operator><name>Pixels</name></name></expr>:</case>
                                <expr_stmt><expr><name>tag_Indent</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
                                <break>break;</break>
                            <case>case <expr><name><name>TagUnits</name><operator>.</operator><name>FontUnits</name></name></expr>:</case>
                                <expr_stmt><expr><name>tag_Indent</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
                                <expr_stmt><expr><name>tag_Indent</name> <operator>*=</operator> <name>m_fontScale</name> <operator>*</operator> <name><name>m_fontAsset</name><operator>.</operator><name>fontInfo</name><operator>.</operator><name>TabWidth</name></name> <operator>/</operator> <name><name>m_fontAsset</name><operator>.</operator><name>tabSize</name></name></expr>;</expr_stmt>
                                <break>break;</break>
                            <case>case <expr><name><name>TagUnits</name><operator>.</operator><name>Percentage</name></name></expr>:</case>
                                <expr_stmt><expr><name>tag_Indent</name> <operator>=</operator> <name>m_marginWidth</name> <operator>*</operator> <name>value</name> <operator>/</operator> <literal type="number">100</literal></expr>;</expr_stmt>
                                <break>break;</break>
                        }</block></switch>
                        <expr_stmt><expr><call><name><name>m_indentStack</name><operator>.</operator><name>Add</name></name><argument_list>(<argument><expr><name>tag_Indent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <expr_stmt><expr><name>m_xAdvance</name> <operator>=</operator> <name>tag_Indent</name></expr>;</expr_stmt>
                        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                    <case>case <expr><literal type="number">7598483</literal></expr>:</case> <comment type="line">// &lt;/indent&gt;</comment>
                    <case>case <expr><literal type="number">6971027</literal></expr>:</case> <comment type="line">// &lt;/INDENT&gt;</comment>
                        <expr_stmt><expr><name>tag_Indent</name> <operator>=</operator> <call><name><name>m_indentStack</name><operator>.</operator><name>Remove</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                        <comment type="line">//m_xAdvance = tag_Indent;</comment>
                        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                    <case>case <expr><literal type="number">1109386397</literal></expr>:</case> <comment type="line">// &lt;line-indent&gt;</comment>
                    <case>case <expr><operator>-</operator><literal type="number">842656867</literal></expr>:</case> <comment type="line">// &lt;LINE-INDENT&gt;</comment>
                        <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>ConvertToFloat</name><argument_list>(<argument><expr><name>m_htmlTag</name></expr></argument>, <argument><expr><name><name>m_xmlAttribute</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>valueStartIndex</name></expr></argument>, <argument><expr><name><name>m_xmlAttribute</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>valueLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if>if <condition>(<expr><name>value</name> <operator>==</operator> <operator>-</operator><literal type="number">9999</literal></expr>)</condition><then> <block type="pseudo"><return>return <expr><literal type="boolean">false</literal></expr>;</return></block></then></if>

                        <switch>switch <condition>(<expr><name>tagUnits</name></expr>)</condition>
                        <block>{
                            <case>case <expr><name><name>TagUnits</name><operator>.</operator><name>Pixels</name></name></expr>:</case>
                                <expr_stmt><expr><name>tag_LineIndent</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
                                <break>break;</break>
                            <case>case <expr><name><name>TagUnits</name><operator>.</operator><name>FontUnits</name></name></expr>:</case>
                                <expr_stmt><expr><name>tag_LineIndent</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
                                <expr_stmt><expr><name>tag_LineIndent</name> <operator>*=</operator> <name>m_fontScale</name> <operator>*</operator> <name><name>m_fontAsset</name><operator>.</operator><name>fontInfo</name><operator>.</operator><name>TabWidth</name></name> <operator>/</operator> <name><name>m_fontAsset</name><operator>.</operator><name>tabSize</name></name></expr>;</expr_stmt>
                                <break>break;</break>
                            <case>case <expr><name><name>TagUnits</name><operator>.</operator><name>Percentage</name></name></expr>:</case>
                                <expr_stmt><expr><name>tag_LineIndent</name> <operator>=</operator> <name>m_marginWidth</name> <operator>*</operator> <name>value</name> <operator>/</operator> <literal type="number">100</literal></expr>;</expr_stmt>
                                <break>break;</break>
                        }</block></switch>

                        <expr_stmt><expr><name>m_xAdvance</name> <operator>+=</operator> <name>tag_LineIndent</name></expr>;</expr_stmt>
                        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                    <case>case <expr><operator>-</operator><literal type="number">445537194</literal></expr>:</case> <comment type="line">// &lt;/line-indent&gt;</comment>
                    <case>case <expr><literal type="number">1897386838</literal></expr>:</case> <comment type="line">// &lt;/LINE-INDENT&gt;</comment>
                        <expr_stmt><expr><name>tag_LineIndent</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                    <case>case <expr><literal type="number">2246877</literal></expr>:</case> <comment type="line">// &lt;sprite=x&gt;</comment>
                    <case>case <expr><literal type="number">1619421</literal></expr>:</case> <comment type="line">// &lt;SPRITE&gt;</comment>
                        <decl_stmt><decl><type><name>int</name></type> <name>spriteAssetHashCode</name> <init>= <expr><name><name>m_xmlAttribute</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>valueHashCode</name></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>TMP_SpriteAsset</name></type> <name>tempSpriteAsset</name></decl>;</decl_stmt>
                        <expr_stmt><expr><name>m_spriteIndex</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

                        <comment type="line">// CHECK TAG FORMAT</comment>
                        <if>if <condition>(<expr><name><name>m_xmlAttribute</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>valueType</name> <operator>==</operator> <name><name>TagType</name><operator>.</operator><name>None</name></name> <operator>||</operator> <name><name>m_xmlAttribute</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>valueType</name> <operator>==</operator> <name><name>TagType</name><operator>.</operator><name>NumericalValue</name></name></expr>)</condition><then>
                        <block>{
                            <comment type="line">// No Sprite Asset is assigned to the text object</comment>
                            <if>if <condition>(<expr><name>m_spriteAsset</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><then>
                            <block>{
                                <expr_stmt><expr><name>m_currentSpriteAsset</name> <operator>=</operator> <name>m_spriteAsset</name></expr>;</expr_stmt>
                            }</block></then>
                            <elseif>else <if>if <condition>(<expr><name>m_defaultSpriteAsset</name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><then>
                            <block>{
                                <expr_stmt><expr><name>m_currentSpriteAsset</name> <operator>=</operator> <name>m_defaultSpriteAsset</name></expr>;</expr_stmt>
                            }</block></then></if></elseif>
                            <elseif>else <if>if <condition>(<expr><name>m_defaultSpriteAsset</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then>
                            <block>{
                                <if>if <condition>(<expr><name><name>TMP_Settings</name><operator>.</operator><name>defaultSpriteAsset</name></name> <operator>!=</operator> <literal type="null">null</literal></expr>)</condition><then>
                                    <block type="pseudo"><expr_stmt><expr><name>m_defaultSpriteAsset</name> <operator>=</operator> <name><name>TMP_Settings</name><operator>.</operator><name>defaultSpriteAsset</name></name></expr>;</expr_stmt></block></then>
                                <else>else
                                    <block type="pseudo"><expr_stmt><expr><name>m_defaultSpriteAsset</name> <operator>=</operator> <call><name><name>Resources</name><operator>.</operator><name><name>Load</name><argument_list type="generic">&lt;<argument><name>TMP_SpriteAsset</name></argument>&gt;</argument_list></name></name><argument_list>(<argument><expr><literal type="string">"Sprite Assets/Default Sprite Asset"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block></else></if>

                                <expr_stmt><expr><name>m_currentSpriteAsset</name> <operator>=</operator> <name>m_defaultSpriteAsset</name></expr>;</expr_stmt>
                            }</block></then></if></elseif></if>

                            <comment type="line">// No valid sprite asset available</comment>
                            <if>if <condition>(<expr><name>m_currentSpriteAsset</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then>
                                <block type="pseudo"><return>return <expr><literal type="boolean">false</literal></expr>;</return></block></then></if>
                        }</block></then>
                        <else>else
                        <block>{
                            <comment type="line">// A Sprite Asset has been specified</comment>
                            <if>if <condition>(<expr><call><name><name>MaterialReferenceManager</name><operator>.</operator><name>TryGetSpriteAsset</name></name><argument_list>(<argument><expr><name>spriteAssetHashCode</name></expr></argument>, <argument><modifier>out</modifier> <expr><name>tempSpriteAsset</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                            <block>{
                                <expr_stmt><expr><name>m_currentSpriteAsset</name> <operator>=</operator> <name>tempSpriteAsset</name></expr>;</expr_stmt>
                            }</block></then>
                            <else>else
                            <block>{
                                <comment type="line">// Load Sprite Asset</comment>
                                <if>if <condition>(<expr><name>tempSpriteAsset</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then>
                                <block>{
                                    <expr_stmt><expr><name>tempSpriteAsset</name> <operator>=</operator> <call><name><name>Resources</name><operator>.</operator><name><name>Load</name><argument_list type="generic">&lt;<argument><name>TMP_SpriteAsset</name></argument>&gt;</argument_list></name></name><argument_list>(<argument><expr><name><name>TMP_Settings</name><operator>.</operator><name>defaultSpriteAssetPath</name></name> <operator>+</operator> <operator>new</operator> <call><name>string</name><argument_list>(<argument><expr><name>m_htmlTag</name></expr></argument>, <argument><expr><name><name>m_xmlAttribute</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>valueStartIndex</name></expr></argument>, <argument><expr><name><name>m_xmlAttribute</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>valueLength</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                }</block></then></if>

                                <if>if <condition>(<expr><name>tempSpriteAsset</name> <operator>==</operator> <literal type="null">null</literal></expr>)</condition><then>
                                    <block type="pseudo"><return>return <expr><literal type="boolean">false</literal></expr>;</return></block></then></if>

                                <comment type="line">//Debug.Log("Loading &amp; assigning new Sprite Asset: " + tempSpriteAsset.name);</comment>
                                <expr_stmt><expr><call><name><name>MaterialReferenceManager</name><operator>.</operator><name>AddSpriteAsset</name></name><argument_list>(<argument><expr><name>spriteAssetHashCode</name></expr></argument>, <argument><expr><name>tempSpriteAsset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <expr_stmt><expr><name>m_currentSpriteAsset</name> <operator>=</operator> <name>tempSpriteAsset</name></expr>;</expr_stmt>
                            }</block></else></if>
                        }</block></else></if>

                        <comment type="line">// Handling of &lt;sprite=index&gt; legacy tag format.</comment>
                        <if>if <condition>(<expr><name><name>m_xmlAttribute</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>valueType</name> <operator>==</operator> <name><name>TagType</name><operator>.</operator><name>NumericalValue</name></name></expr>)</condition><then> <comment type="line">// &lt;sprite=index&gt;</comment>
                        <block>{
                            <decl_stmt><decl><type><name>int</name></type> <name>index</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>ConvertToFloat</name><argument_list>(<argument><expr><name>m_htmlTag</name></expr></argument>, <argument><expr><name><name>m_xmlAttribute</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>valueStartIndex</name></expr></argument>, <argument><expr><name><name>m_xmlAttribute</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>valueLength</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                            <if>if <condition>(<expr><name>index</name> <operator>==</operator> <operator>-</operator><literal type="number">9999</literal></expr>)</condition><then> <block type="pseudo"><return>return <expr><literal type="boolean">false</literal></expr>;</return></block></then></if>

                            <comment type="line">// Check to make sure sprite index is valid</comment>
                            <if>if <condition>(<expr><name>index</name> <operator>&gt;</operator> <name><name>m_currentSpriteAsset</name><operator>.</operator><name>spriteInfoList</name><operator>.</operator><name>Count</name></name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><then> <block type="pseudo"><return>return <expr><literal type="boolean">false</literal></expr>;</return></block></then></if>

                            <expr_stmt><expr><name>m_spriteIndex</name> <operator>=</operator> <name>index</name></expr>;</expr_stmt>
                        }</block></then></if>

                        <expr_stmt><expr><name>m_spriteColor</name> <operator>=</operator> <name>s_colorWhite</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>m_tintSprite</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>

                        <comment type="line">// Handle Sprite Tag Attributes</comment>
                        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>m_xmlAttribute</name><operator>.</operator><name>Length</name></name> <operator>&amp;&amp;</operator> <name><name>m_xmlAttribute</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nameHashCode</name> <operator>!=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
                        <block>{
                            <comment type="line">//Debug.Log("Attribute[" + i + "].nameHashCode=" + m_xmlAttribute[i].nameHashCode + "   Value:" + ConvertToFloat(m_htmlTag, m_xmlAttribute[i].valueStartIndex, m_xmlAttribute[i].valueLength));</comment>
                            <decl_stmt><decl><type><name>int</name></type> <name>nameHashCode</name> <init>= <expr><name><name>m_xmlAttribute</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nameHashCode</name></expr></init></decl>;</decl_stmt>
                            <decl_stmt><decl><type><name>int</name></type> <name>index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

                            <switch>switch <condition>(<expr><name>nameHashCode</name></expr>)</condition>
                            <block>{
                                <case>case <expr><literal type="number">43347</literal></expr>:</case> <comment type="line">// &lt;sprite name=""&gt;</comment>
                                <case>case <expr><literal type="number">30547</literal></expr>:</case> <comment type="line">// &lt;SPRITE NAME=""&gt;</comment>
                                    <expr_stmt><expr><name>m_currentSpriteAsset</name> <operator>=</operator> <call><name><name>TMP_SpriteAsset</name><operator>.</operator><name>SearchForSpriteByHashCode</name></name><argument_list>(<argument><expr><name>m_currentSpriteAsset</name></expr></argument>, <argument><expr><name><name>m_xmlAttribute</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>valueHashCode</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><modifier>out</modifier> <expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                    <if>if <condition>(<expr><name>index</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><then> <block type="pseudo"><return>return <expr><literal type="boolean">false</literal></expr>;</return></block></then></if>

                                    <expr_stmt><expr><name>m_spriteIndex</name> <operator>=</operator> <name>index</name></expr>;</expr_stmt>
                                    <break>break;</break>
                                <case>case <expr><literal type="number">295562</literal></expr>:</case> <comment type="line">// &lt;sprite index=&gt;</comment>
                                <case>case <expr><literal type="number">205930</literal></expr>:</case> <comment type="line">// &lt;SPRITE INDEX=&gt;</comment>
                                    <expr_stmt><expr><name>index</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>ConvertToFloat</name><argument_list>(<argument><expr><name>m_htmlTag</name></expr></argument>, <argument><expr><name><name>m_xmlAttribute</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>valueStartIndex</name></expr></argument>, <argument><expr><name><name>m_xmlAttribute</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>valueLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                    <if>if <condition>(<expr><name>index</name> <operator>==</operator> <operator>-</operator><literal type="number">9999</literal></expr>)</condition><then> <block type="pseudo"><return>return <expr><literal type="boolean">false</literal></expr>;</return></block></then></if>

                                    <comment type="line">// Check to make sure sprite index is valid</comment>
                                    <if>if <condition>(<expr><name>index</name> <operator>&gt;</operator> <name><name>m_currentSpriteAsset</name><operator>.</operator><name>spriteInfoList</name><operator>.</operator><name>Count</name></name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><then> <block type="pseudo"><return>return <expr><literal type="boolean">false</literal></expr>;</return></block></then></if>

                                    <expr_stmt><expr><name>m_spriteIndex</name> <operator>=</operator> <name>index</name></expr>;</expr_stmt>
                                    <break>break;</break>
                                <case>case <expr><literal type="number">45819</literal></expr>:</case> <comment type="line">// tint</comment>
                                <case>case <expr><literal type="number">33019</literal></expr>:</case> <comment type="line">// TINT</comment>
                                    <expr_stmt><expr><name>m_tintSprite</name> <operator>=</operator> <call><name>ConvertToFloat</name><argument_list>(<argument><expr><name>m_htmlTag</name></expr></argument>, <argument><expr><name><name>m_xmlAttribute</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>valueStartIndex</name></expr></argument>, <argument><expr><name><name>m_xmlAttribute</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>valueLength</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                                    <break>break;</break>
                                <case>case <expr><literal type="number">281955</literal></expr>:</case> <comment type="line">// color=#FF00FF80</comment>
                                <case>case <expr><literal type="number">192323</literal></expr>:</case> <comment type="line">// COLOR</comment>
                                    <expr_stmt><expr><name>m_spriteColor</name> <operator>=</operator> <call><name>HexCharsToColor</name><argument_list>(<argument><expr><name>m_htmlTag</name></expr></argument>, <argument><expr><name><name>m_xmlAttribute</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>valueStartIndex</name></expr></argument>, <argument><expr><name><name>m_xmlAttribute</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>valueLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                    <break>break;</break>
                                <case>case <expr><literal type="number">39505</literal></expr>:</case> <comment type="line">// anim="0,16,12"  start, end, fps</comment>
                                <case>case <expr><literal type="number">26705</literal></expr>:</case> <comment type="line">// ANIM</comment>
                                    <comment type="line">//Debug.Log("Start: " + m_xmlAttribute[i].valueStartIndex + "  Length: " + m_xmlAttribute[i].valueLength);</comment>
                                    <decl_stmt><decl><type><name>int</name></type> <name>paramCount</name> <init>= <expr><call><name>GetAttributeParameters</name><argument_list>(<argument><expr><name>m_htmlTag</name></expr></argument>, <argument><expr><name><name>m_xmlAttribute</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>valueStartIndex</name></expr></argument>, <argument><expr><name><name>m_xmlAttribute</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>valueLength</name></expr></argument>, <argument><modifier>ref</modifier> <expr><name>m_attributeParameterValues</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                                    <if>if <condition>(<expr><name>paramCount</name> <operator>!=</operator> <literal type="number">3</literal></expr>)</condition><then> <block type="pseudo"><return>return <expr><literal type="boolean">false</literal></expr>;</return></block></then></if>

                                    <expr_stmt><expr><name>m_spriteIndex</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>m_attributeParameterValues</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

                                    <if>if <condition>(<expr><name>m_isParsingText</name></expr>)</condition><then>
                                    <block>{
                                        <comment type="line">// TODO : fix this!</comment>
                                        <comment type="line">//if (m_attributeParameterValues[0] &gt; m_currentSpriteAsset.spriteInfoList.Count - 1 || m_attributeParameterValues[1] &gt; m_currentSpriteAsset.spriteInfoList.Count - 1)</comment>
                                        <comment type="line">//    return false;</comment>

                                        <expr_stmt><expr><call><name><name>spriteAnimator</name><operator>.</operator><name>DoSpriteAnimation</name></name><argument_list>(<argument><expr><name>m_characterCount</name></expr></argument>, <argument><expr><name>m_currentSpriteAsset</name></expr></argument>, <argument><expr><name>m_spriteIndex</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>m_attributeParameterValues</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>m_attributeParameterValues</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                    }</block></then></if>

                                    <break>break;</break>
                                <comment type="line">//case 45545: // size</comment>
                                <comment type="line">//case 32745: // SIZE</comment>

                                <comment type="line">//    break;</comment>
                                <default>default:</default>
                                    <if>if <condition>(<expr><name>nameHashCode</name> <operator>!=</operator> <literal type="number">2246877</literal> <operator>&amp;&amp;</operator> <name>nameHashCode</name> <operator>!=</operator> <literal type="number">1619421</literal></expr>)</condition><then>
                                        <block type="pseudo"><return>return <expr><literal type="boolean">false</literal></expr>;</return></block></then></if>
                                    <break>break;</break>
                            }</block></switch>
                        }</block></for>

                        <if>if <condition>(<expr><name>m_spriteIndex</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><then> <block type="pseudo"><return>return <expr><literal type="boolean">false</literal></expr>;</return></block></then></if>

                        <comment type="line">// Material HashCode for the Sprite Asset is the Sprite Asset Hash Code</comment>
                        <expr_stmt><expr><name>m_currentMaterialIndex</name> <operator>=</operator> <call><name><name>MaterialReference</name><operator>.</operator><name>AddMaterialReference</name></name><argument_list>(<argument><expr><name><name>m_currentSpriteAsset</name><operator>.</operator><name>material</name></name></expr></argument>, <argument><expr><name>m_currentSpriteAsset</name></expr></argument>, <argument><expr><name>m_materialReferences</name></expr></argument>, <argument><expr><name>m_materialReferenceIndexLookup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <expr_stmt><expr><name>m_textElementType</name> <operator>=</operator> <name><name>TMP_TextElementType</name><operator>.</operator><name>Sprite</name></name></expr>;</expr_stmt>
                        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                    <case>case <expr><literal type="number">730022849</literal></expr>:</case> <comment type="line">// &lt;lowercase&gt;</comment>
                    <case>case <expr><literal type="number">514803617</literal></expr>:</case> <comment type="line">// &lt;LOWERCASE&gt;</comment>
                        <expr_stmt><expr><name>m_style</name> <operator>|=</operator> <name><name>FontStyles</name><operator>.</operator><name>LowerCase</name></name></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name><name>m_fontStyleStack</name><operator>.</operator><name>Add</name></name><argument_list>(<argument><expr><name><name>FontStyles</name><operator>.</operator><name>LowerCase</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                    <case>case <expr><operator>-</operator><literal type="number">1668324918</literal></expr>:</case> <comment type="line">// &lt;/lowercase&gt;</comment>
                    <case>case <expr><operator>-</operator><literal type="number">1883544150</literal></expr>:</case> <comment type="line">// &lt;/LOWERCASE&gt;</comment>
                        <if>if <condition>(<expr><call><name><name>m_fontStyleStack</name><operator>.</operator><name>Remove</name></name><argument_list>(<argument><expr><name><name>FontStyles</name><operator>.</operator><name>LowerCase</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then>
                            <block type="pseudo"><expr_stmt><expr><name>m_style</name> <operator>&amp;=</operator> <operator>~</operator><name><name>FontStyles</name><operator>.</operator><name>LowerCase</name></name></expr>;</expr_stmt></block></then></if>
                        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                    <case>case <expr><literal type="number">13526026</literal></expr>:</case> <comment type="line">// &lt;allcaps&gt;</comment>
                    <case>case <expr><literal type="number">9133802</literal></expr>:</case> <comment type="line">// &lt;ALLCAPS&gt;</comment>
                    <case>case <expr><literal type="number">781906058</literal></expr>:</case> <comment type="line">// &lt;uppercase&gt;</comment>
                    <case>case <expr><literal type="number">566686826</literal></expr>:</case> <comment type="line">// &lt;UPPERCASE&gt;</comment>
                        <expr_stmt><expr><name>m_style</name> <operator>|=</operator> <name><name>FontStyles</name><operator>.</operator><name>UpperCase</name></name></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name><name>m_fontStyleStack</name><operator>.</operator><name>Add</name></name><argument_list>(<argument><expr><name><name>FontStyles</name><operator>.</operator><name>UpperCase</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                    <case>case <expr><literal type="number">52232547</literal></expr>:</case> <comment type="line">// &lt;/allcaps&gt;</comment>
                    <case>case <expr><literal type="number">47840323</literal></expr>:</case> <comment type="line">// &lt;/ALLCAPS&gt;</comment>
                    <case>case <expr><operator>-</operator><literal type="number">1616441709</literal></expr>:</case> <comment type="line">// &lt;/uppercase&gt;</comment>
                    <case>case <expr><operator>-</operator><literal type="number">1831660941</literal></expr>:</case> <comment type="line">// &lt;/UPPERCASE&gt;</comment>
                        <if>if <condition>(<expr><call><name><name>m_fontStyleStack</name><operator>.</operator><name>Remove</name></name><argument_list>(<argument><expr><name><name>FontStyles</name><operator>.</operator><name>UpperCase</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then>
                            <block type="pseudo"><expr_stmt><expr><name>m_style</name> <operator>&amp;=</operator> <operator>~</operator><name><name>FontStyles</name><operator>.</operator><name>UpperCase</name></name></expr>;</expr_stmt></block></then></if>
                        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                    <case>case <expr><literal type="number">766244328</literal></expr>:</case> <comment type="line">// &lt;smallcaps&gt;</comment>
                    <case>case <expr><literal type="number">551025096</literal></expr>:</case> <comment type="line">// &lt;SMALLCAPS&gt;</comment>
                        <expr_stmt><expr><name>m_style</name> <operator>|=</operator> <name><name>FontStyles</name><operator>.</operator><name>SmallCaps</name></name></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name><name>m_fontStyleStack</name><operator>.</operator><name>Add</name></name><argument_list>(<argument><expr><name><name>FontStyles</name><operator>.</operator><name>SmallCaps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                    <case>case <expr><operator>-</operator><literal type="number">1632103439</literal></expr>:</case> <comment type="line">// &lt;/smallcaps&gt;</comment>
                    <case>case <expr><operator>-</operator><literal type="number">1847322671</literal></expr>:</case> <comment type="line">// &lt;/SMALLCAPS&gt;</comment>
                        <if>if <condition>(<expr><call><name><name>m_fontStyleStack</name><operator>.</operator><name>Remove</name></name><argument_list>(<argument><expr><name><name>FontStyles</name><operator>.</operator><name>SmallCaps</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then>
                            <block type="pseudo"><expr_stmt><expr><name>m_style</name> <operator>&amp;=</operator> <operator>~</operator><name><name>FontStyles</name><operator>.</operator><name>SmallCaps</name></name></expr>;</expr_stmt></block></then></if>
                        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                    <case>case <expr><literal type="number">2109854</literal></expr>:</case> <comment type="line">// &lt;margin=00.0&gt; &lt;margin=00em&gt; &lt;margin=50%&gt;</comment>
                    <case>case <expr><literal type="number">1482398</literal></expr>:</case> <comment type="line">// &lt;MARGIN&gt;</comment>
                        <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>ConvertToFloat</name><argument_list>(<argument><expr><name>m_htmlTag</name></expr></argument>, <argument><expr><name><name>m_xmlAttribute</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>valueStartIndex</name></expr></argument>, <argument><expr><name><name>m_xmlAttribute</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>valueLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// px</comment>
                        <if>if <condition>(<expr><name>value</name> <operator>==</operator> <operator>-</operator><literal type="number">9999</literal></expr>)</condition><then> <block type="pseudo"><return>return <expr><literal type="boolean">false</literal></expr>;</return></block></then></if>

                        <expr_stmt><expr><name>m_marginLeft</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
                        <switch>switch <condition>(<expr><name>tagUnits</name></expr>)</condition>
                        <block>{
                            <case>case <expr><name><name>TagUnits</name><operator>.</operator><name>Pixels</name></name></expr>:</case>
                                <comment type="line">// Default behavior</comment>
                                <break>break;</break>
                            <case>case <expr><name><name>TagUnits</name><operator>.</operator><name>FontUnits</name></name></expr>:</case>
                                <expr_stmt><expr><name>m_marginLeft</name> <operator>*=</operator> <name>m_fontScale</name> <operator>*</operator> <name><name>m_fontAsset</name><operator>.</operator><name>fontInfo</name><operator>.</operator><name>TabWidth</name></name> <operator>/</operator> <name><name>m_fontAsset</name><operator>.</operator><name>tabSize</name></name></expr>;</expr_stmt>
                                <break>break;</break>
                            <case>case <expr><name><name>TagUnits</name><operator>.</operator><name>Percentage</name></name></expr>:</case>
                                <expr_stmt><expr><name>m_marginLeft</name> <operator>=</operator> <operator>(</operator><name>m_marginWidth</name> <operator>-</operator> <operator>(</operator><ternary><condition><expr><name>m_width</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr> ?</condition><then> <expr><name>m_width</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator><operator>)</operator> <operator>*</operator> <name>m_marginLeft</name> <operator>/</operator> <literal type="number">100</literal></expr>;</expr_stmt>
                                <break>break;</break>
                        }</block></switch>
                        <expr_stmt><expr><name>m_marginLeft</name> <operator>=</operator> <ternary><condition><expr><name>m_marginLeft</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>m_marginLeft</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
                        <expr_stmt><expr><name>m_marginRight</name> <operator>=</operator> <name>m_marginLeft</name></expr>;</expr_stmt>

                        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                    <case>case <expr><literal type="number">7639357</literal></expr>:</case> <comment type="line">// &lt;/margin&gt;</comment>
                    <case>case <expr><literal type="number">7011901</literal></expr>:</case> <comment type="line">// &lt;/MARGIN&gt;</comment>
                        <expr_stmt><expr><name>m_marginLeft</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                        <expr_stmt><expr><name>m_marginRight</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                    <case>case <expr><literal type="number">1100728678</literal></expr>:</case> <comment type="line">// &lt;margin-left=xx.x&gt;</comment>
                    <case>case <expr><operator>-</operator><literal type="number">855002522</literal></expr>:</case> <comment type="line">// &lt;MARGIN-LEFT&gt;</comment>
                        <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>ConvertToFloat</name><argument_list>(<argument><expr><name>m_htmlTag</name></expr></argument>, <argument><expr><name><name>m_xmlAttribute</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>valueStartIndex</name></expr></argument>, <argument><expr><name><name>m_xmlAttribute</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>valueLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// px</comment>
                        <if>if <condition>(<expr><name>value</name> <operator>==</operator> <operator>-</operator><literal type="number">9999</literal></expr>)</condition><then> <block type="pseudo"><return>return <expr><literal type="boolean">false</literal></expr>;</return></block></then></if>

                        <expr_stmt><expr><name>m_marginLeft</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
                        <switch>switch <condition>(<expr><name>tagUnits</name></expr>)</condition>
                        <block>{
                            <case>case <expr><name><name>TagUnits</name><operator>.</operator><name>Pixels</name></name></expr>:</case>
                                <comment type="line">// Default behavior</comment>
                                <break>break;</break>
                            <case>case <expr><name><name>TagUnits</name><operator>.</operator><name>FontUnits</name></name></expr>:</case>
                                <expr_stmt><expr><name>m_marginLeft</name> <operator>*=</operator> <name>m_fontScale</name> <operator>*</operator> <name><name>m_fontAsset</name><operator>.</operator><name>fontInfo</name><operator>.</operator><name>TabWidth</name></name> <operator>/</operator> <name><name>m_fontAsset</name><operator>.</operator><name>tabSize</name></name></expr>;</expr_stmt>
                                <break>break;</break>
                            <case>case <expr><name><name>TagUnits</name><operator>.</operator><name>Percentage</name></name></expr>:</case>
                                <expr_stmt><expr><name>m_marginLeft</name> <operator>=</operator> <operator>(</operator><name>m_marginWidth</name> <operator>-</operator> <operator>(</operator><ternary><condition><expr><name>m_width</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr> ?</condition><then> <expr><name>m_width</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator><operator>)</operator> <operator>*</operator> <name>m_marginLeft</name> <operator>/</operator> <literal type="number">100</literal></expr>;</expr_stmt>
                                <break>break;</break>
                        }</block></switch>
                        <expr_stmt><expr><name>m_marginLeft</name> <operator>=</operator> <ternary><condition><expr><name>m_marginLeft</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>m_marginLeft</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
                        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                    <case>case <expr><operator>-</operator><literal type="number">884817987</literal></expr>:</case> <comment type="line">// &lt;margin-right=xx.x&gt;</comment>
                    <case>case <expr><operator>-</operator><literal type="number">1690034531</literal></expr>:</case> <comment type="line">// &lt;MARGIN-RIGHT&gt;</comment>
                        <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>ConvertToFloat</name><argument_list>(<argument><expr><name>m_htmlTag</name></expr></argument>, <argument><expr><name><name>m_xmlAttribute</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>valueStartIndex</name></expr></argument>, <argument><expr><name><name>m_xmlAttribute</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>valueLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// px</comment>
                        <if>if <condition>(<expr><name>value</name> <operator>==</operator> <operator>-</operator><literal type="number">9999</literal></expr>)</condition><then> <block type="pseudo"><return>return <expr><literal type="boolean">false</literal></expr>;</return></block></then></if>

                        <expr_stmt><expr><name>m_marginRight</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
                        <switch>switch <condition>(<expr><name>tagUnits</name></expr>)</condition>
                        <block>{
                            <case>case <expr><name><name>TagUnits</name><operator>.</operator><name>Pixels</name></name></expr>:</case>
                                <comment type="line">// Default behavior</comment>
                                <break>break;</break>
                            <case>case <expr><name><name>TagUnits</name><operator>.</operator><name>FontUnits</name></name></expr>:</case>
                                <expr_stmt><expr><name>m_marginRight</name> <operator>*=</operator> <name>m_fontScale</name> <operator>*</operator> <name><name>m_fontAsset</name><operator>.</operator><name>fontInfo</name><operator>.</operator><name>TabWidth</name></name> <operator>/</operator> <name><name>m_fontAsset</name><operator>.</operator><name>tabSize</name></name></expr>;</expr_stmt>
                                <break>break;</break>
                            <case>case <expr><name><name>TagUnits</name><operator>.</operator><name>Percentage</name></name></expr>:</case>
                                <expr_stmt><expr><name>m_marginRight</name> <operator>=</operator> <operator>(</operator><name>m_marginWidth</name> <operator>-</operator> <operator>(</operator><ternary><condition><expr><name>m_width</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr> ?</condition><then> <expr><name>m_width</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator><operator>)</operator> <operator>*</operator> <name>m_marginRight</name> <operator>/</operator> <literal type="number">100</literal></expr>;</expr_stmt>
                                <break>break;</break>
                        }</block></switch>
                        <expr_stmt><expr><name>m_marginRight</name> <operator>=</operator> <ternary><condition><expr><name>m_marginRight</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>m_marginRight</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
                        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                    <case>case <expr><literal type="number">1109349752</literal></expr>:</case> <comment type="line">// &lt;line-height=xx.x&gt;</comment>
                    <case>case <expr><operator>-</operator><literal type="number">842693512</literal></expr>:</case> <comment type="line">// &lt;LINE-HEIGHT&gt;</comment>
                        <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>ConvertToFloat</name><argument_list>(<argument><expr><name>m_htmlTag</name></expr></argument>, <argument><expr><name><name>m_xmlAttribute</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>valueStartIndex</name></expr></argument>, <argument><expr><name><name>m_xmlAttribute</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>valueLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if>if <condition>(<expr><name>value</name> <operator>==</operator> <operator>-</operator><literal type="number">9999</literal> <operator>||</operator> <name>value</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><then> <block type="pseudo"><return>return <expr><literal type="boolean">false</literal></expr>;</return></block></then></if>

                        <expr_stmt><expr><name>m_lineHeight</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
                        <switch>switch <condition>(<expr><name>tagUnits</name></expr>)</condition>
                        <block>{
                            <case>case <expr><name><name>TagUnits</name><operator>.</operator><name>Pixels</name></name></expr>:</case>
                                <comment type="line">//m_lineHeight = value; </comment>
                                <break>break;</break>
                            <case>case <expr><name><name>TagUnits</name><operator>.</operator><name>FontUnits</name></name></expr>:</case>
                                <expr_stmt><expr><name>m_lineHeight</name> <operator>*=</operator> <name><name>m_fontAsset</name><operator>.</operator><name>fontInfo</name><operator>.</operator><name>LineHeight</name></name> <operator>*</operator> <name>m_fontScale</name></expr>;</expr_stmt>
                                <break>break;</break>
                            <case>case <expr><name><name>TagUnits</name><operator>.</operator><name>Percentage</name></name></expr>:</case>
                                <expr_stmt><expr><name>m_lineHeight</name> <operator>=</operator> <name><name>m_fontAsset</name><operator>.</operator><name>fontInfo</name><operator>.</operator><name>LineHeight</name></name> <operator>*</operator> <name>m_lineHeight</name> <operator>/</operator> <literal type="number">100</literal> <operator>*</operator> <name>m_fontScale</name></expr>;</expr_stmt>
                                <break>break;</break>
                        }</block></switch>
                        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                    <case>case <expr><operator>-</operator><literal type="number">445573839</literal></expr>:</case> <comment type="line">// &lt;/line-height&gt;</comment>
                    <case>case <expr><literal type="number">1897350193</literal></expr>:</case> <comment type="line">// &lt;/LINE-HEIGHT&gt;</comment>
                        <expr_stmt><expr><name>m_lineHeight</name> <operator>=</operator> <name><name>TMP_Math</name><operator>.</operator><name>FLOAT_UNSET</name></name></expr>;</expr_stmt>
                        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                    <case>case <expr><literal type="number">15115642</literal></expr>:</case> <comment type="line">// &lt;noparse&gt;</comment>
                    <case>case <expr><literal type="number">10723418</literal></expr>:</case> <comment type="line">// &lt;NOPARSE&gt;</comment>
                        <expr_stmt><expr><name>tag_NoParsing</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                    <case>case <expr><literal type="number">1913798</literal></expr>:</case> <comment type="line">// &lt;action&gt;</comment>
                    <case>case <expr><literal type="number">1286342</literal></expr>:</case> <comment type="line">// &lt;ACTION&gt;</comment>
                        <decl_stmt><decl><type><name>int</name></type> <name>actionID</name> <init>= <expr><name><name>m_xmlAttribute</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>valueHashCode</name></expr></init></decl>;</decl_stmt>

                        <if>if <condition>(<expr><name>m_isParsingText</name></expr>)</condition><then>
                        <block>{
                            <expr_stmt><expr><call><name><name>m_actionStack</name><operator>.</operator><name>Add</name></name><argument_list>(<argument><expr><name>actionID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                            <expr_stmt><expr><call><name><name>Debug</name><operator>.</operator><name>Log</name></name><argument_list>(<argument><expr><literal type="string">"Action ID: ["</literal> <operator>+</operator> <name>actionID</name> <operator>+</operator> <literal type="string">"] First character index: "</literal> <operator>+</operator> <name>m_characterCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


                        }</block></then></if>
                        <comment type="line">//if (m_isParsingText)</comment>
                        <comment type="line">//{</comment>
                        <comment type="line">// TMP_Action action = TMP_Action.GetAction(m_xmlAttribute[0].valueHashCode);</comment>
                        <comment type="line">//}</comment>
                        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                    <case>case <expr><literal type="number">7443301</literal></expr>:</case> <comment type="line">// &lt;/action&gt;</comment>
                    <case>case <expr><literal type="number">6815845</literal></expr>:</case> <comment type="line">// &lt;/ACTION&gt;</comment>
                        <if>if <condition>(<expr><name>m_isParsingText</name></expr>)</condition><then>
                        <block>{
                            <expr_stmt><expr><call><name><name>Debug</name><operator>.</operator><name>Log</name></name><argument_list>(<argument><expr><literal type="string">"Action ID: ["</literal> <operator>+</operator> <call><name><name>m_actionStack</name><operator>.</operator><name>CurrentItem</name></name><argument_list>()</argument_list></call> <operator>+</operator> <literal type="string">"] Last character index: "</literal> <operator>+</operator> <operator>(</operator><name>m_characterCount</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        }</block></then></if>

                        <expr_stmt><expr><call><name><name>m_actionStack</name><operator>.</operator><name>Remove</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                    <case>case <expr><literal type="number">315682</literal></expr>:</case> <comment type="line">// &lt;scale=xx.x&gt;</comment>
                    <case>case <expr><literal type="number">226050</literal></expr>:</case> <comment type="line">// &lt;SCALE=xx.x&gt;</comment>
                        <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>ConvertToFloat</name><argument_list>(<argument><expr><name>m_htmlTag</name></expr></argument>, <argument><expr><name><name>m_xmlAttribute</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>valueStartIndex</name></expr></argument>, <argument><expr><name><name>m_xmlAttribute</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>valueLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if>if <condition>(<expr><name>value</name> <operator>==</operator> <operator>-</operator><literal type="number">9999</literal></expr>)</condition><then> <block type="pseudo"><return>return <expr><literal type="boolean">false</literal></expr>;</return></block></then></if>

                        <expr_stmt><expr><name>m_FXMatrix</name> <operator>=</operator> <call><name><name>Matrix4x4</name><operator>.</operator><name>TRS</name></name><argument_list>(<argument><expr><name><name>Vector3</name><operator>.</operator><name>zero</name></name></expr></argument>, <argument><expr><name><name>Quaternion</name><operator>.</operator><name>identity</name></name></expr></argument>, <argument><expr><operator>new</operator> <call><name>Vector3</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>m_isFXMatrixSet</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>

                        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                    <case>case <expr><literal type="number">1105611</literal></expr>:</case> <comment type="line">// &lt;/scale&gt;</comment>
                    <case>case <expr><literal type="number">1015979</literal></expr>:</case> <comment type="line">// &lt;/SCALE&gt;</comment>
                        <expr_stmt><expr><name>m_isFXMatrixSet</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
                        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                    <case>case <expr><literal type="number">2227963</literal></expr>:</case> <comment type="line">// &lt;rotate=xx.x&gt;</comment>
                    <case>case <expr><literal type="number">1600507</literal></expr>:</case> <comment type="line">// &lt;ROTATE=xx.x&gt;</comment>
                        <comment type="line">// TODO: Add ability to use Random Rotation</comment>

                        <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>ConvertToFloat</name><argument_list>(<argument><expr><name>m_htmlTag</name></expr></argument>, <argument><expr><name><name>m_xmlAttribute</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>valueStartIndex</name></expr></argument>, <argument><expr><name><name>m_xmlAttribute</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>valueLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if>if <condition>(<expr><name>value</name> <operator>==</operator> <operator>-</operator><literal type="number">9999</literal></expr>)</condition><then> <block type="pseudo"><return>return <expr><literal type="boolean">false</literal></expr>;</return></block></then></if>

                        <expr_stmt><expr><name>m_FXMatrix</name> <operator>=</operator> <call><name><name>Matrix4x4</name><operator>.</operator><name>TRS</name></name><argument_list>(<argument><expr><name><name>Vector3</name><operator>.</operator><name>zero</name></name></expr></argument>, <argument><expr><call><name><name>Quaternion</name><operator>.</operator><name>Euler</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>Vector3</name><operator>.</operator><name>one</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>m_isFXMatrixSet</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>

                        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                    <case>case <expr><literal type="number">7757466</literal></expr>:</case> <comment type="line">// &lt;/rotate&gt;</comment>
                    <case>case <expr><literal type="number">7130010</literal></expr>:</case> <comment type="line">// &lt;/ROTATE&gt;</comment>
                        <expr_stmt><expr><name>m_isFXMatrixSet</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
                        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                    <case>case <expr><literal type="number">317446</literal></expr>:</case> <comment type="line">// &lt;table&gt;</comment>
                    <case>case <expr><literal type="number">227814</literal></expr>:</case> <comment type="line">// &lt;TABLE&gt;</comment>
                        <switch>switch <condition>(<expr><name><name>m_xmlAttribute</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>nameHashCode</name></expr>)</condition>
                        <block>{
                            <case>case <expr><literal type="number">327550</literal></expr>:</case> <comment type="line">// width</comment>
                                <decl_stmt><decl><type><name>float</name></type> <name>tableWidth</name> <init>= <expr><call><name>ConvertToFloat</name><argument_list>(<argument><expr><name>m_htmlTag</name></expr></argument>, <argument><expr><name><name>m_xmlAttribute</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>valueStartIndex</name></expr></argument>, <argument><expr><name><name>m_xmlAttribute</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>valueLength</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                                <switch>switch <condition>(<expr><name>tagUnits</name></expr>)</condition>
                                <block>{
                                    <case>case <expr><name><name>TagUnits</name><operator>.</operator><name>Pixels</name></name></expr>:</case>
                                        <expr_stmt><expr><call><name><name>Debug</name><operator>.</operator><name>Log</name></name><argument_list>(<argument><expr><literal type="string">"Table width = "</literal> <operator>+</operator> <name>tableWidth</name> <operator>+</operator> <literal type="string">"px."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                        <break>break;</break>
                                    <case>case <expr><name><name>TagUnits</name><operator>.</operator><name>FontUnits</name></name></expr>:</case>
                                        <expr_stmt><expr><call><name><name>Debug</name><operator>.</operator><name>Log</name></name><argument_list>(<argument><expr><literal type="string">"Table width = "</literal> <operator>+</operator> <name>tableWidth</name> <operator>+</operator> <literal type="string">"em."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                        <break>break;</break>
                                    <case>case <expr><name><name>TagUnits</name><operator>.</operator><name>Percentage</name></name></expr>:</case>
                                        <expr_stmt><expr><call><name><name>Debug</name><operator>.</operator><name>Log</name></name><argument_list>(<argument><expr><literal type="string">"Table width = "</literal> <operator>+</operator> <name>tableWidth</name> <operator>+</operator> <literal type="string">"%."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                        <break>break;</break>
                                }</block></switch>
                                <break>break;</break>
                        }</block></switch>
                        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                    <case>case <expr><literal type="number">1107375</literal></expr>:</case> <comment type="line">// &lt;/table&gt;</comment>
                    <case>case <expr><literal type="number">1017743</literal></expr>:</case> <comment type="line">// &lt;/TABLE&gt;</comment>
                        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                    <case>case <expr><literal type="number">926</literal></expr>:</case> <comment type="line">// &lt;tr&gt;</comment>
                    <case>case <expr><literal type="number">670</literal></expr>:</case> <comment type="line">// &lt;TR&gt;</comment>
                        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                    <case>case <expr><literal type="number">3229</literal></expr>:</case> <comment type="line">// &lt;/tr&gt;</comment>
                    <case>case <expr><literal type="number">2973</literal></expr>:</case> <comment type="line">// &lt;/TR&gt;</comment>
                        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                    <case>case <expr><literal type="number">916</literal></expr>:</case> <comment type="line">// &lt;th&gt;</comment>
                    <case>case <expr><literal type="number">660</literal></expr>:</case> <comment type="line">// &lt;TH&gt;</comment>
                        <comment type="line">// Set style to bold and center alignment</comment>
                        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                    <case>case <expr><literal type="number">3219</literal></expr>:</case> <comment type="line">// &lt;/th&gt;</comment>
                    <case>case <expr><literal type="number">2963</literal></expr>:</case> <comment type="line">// &lt;/TH&gt;</comment>
                        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                    <case>case <expr><literal type="number">912</literal></expr>:</case> <comment type="line">// &lt;td&gt;</comment>
                    <case>case <expr><literal type="number">656</literal></expr>:</case> <comment type="line">// &lt;TD&gt;</comment>
                              <comment type="line">// Style options</comment>
                        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>m_xmlAttribute</name><operator>.</operator><name>Length</name></name> <operator>&amp;&amp;</operator> <name><name>m_xmlAttribute</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nameHashCode</name> <operator>!=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
                        <block>{
                            <switch>switch <condition>(<expr><name><name>m_xmlAttribute</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nameHashCode</name></expr>)</condition>
                            <block>{
                                <case>case <expr><literal type="number">327550</literal></expr>:</case> <comment type="line">// width</comment>
                                    <decl_stmt><decl><type><name>float</name></type> <name>tableWidth</name> <init>= <expr><call><name>ConvertToFloat</name><argument_list>(<argument><expr><name>m_htmlTag</name></expr></argument>, <argument><expr><name><name>m_xmlAttribute</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>valueStartIndex</name></expr></argument>, <argument><expr><name><name>m_xmlAttribute</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>valueLength</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                                    <switch>switch <condition>(<expr><name>tagUnits</name></expr>)</condition>
                                    <block>{
                                        <case>case <expr><name><name>TagUnits</name><operator>.</operator><name>Pixels</name></name></expr>:</case>
                                            <expr_stmt><expr><call><name><name>Debug</name><operator>.</operator><name>Log</name></name><argument_list>(<argument><expr><literal type="string">"Table width = "</literal> <operator>+</operator> <name>tableWidth</name> <operator>+</operator> <literal type="string">"px."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                            <break>break;</break>
                                        <case>case <expr><name><name>TagUnits</name><operator>.</operator><name>FontUnits</name></name></expr>:</case>
                                            <expr_stmt><expr><call><name><name>Debug</name><operator>.</operator><name>Log</name></name><argument_list>(<argument><expr><literal type="string">"Table width = "</literal> <operator>+</operator> <name>tableWidth</name> <operator>+</operator> <literal type="string">"em."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                            <break>break;</break>
                                        <case>case <expr><name><name>TagUnits</name><operator>.</operator><name>Percentage</name></name></expr>:</case>
                                            <expr_stmt><expr><call><name><name>Debug</name><operator>.</operator><name>Log</name></name><argument_list>(<argument><expr><literal type="string">"Table width = "</literal> <operator>+</operator> <name>tableWidth</name> <operator>+</operator> <literal type="string">"%."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                            <break>break;</break>
                                    }</block></switch>
                                    <break>break;</break>
                                <case>case <expr><literal type="number">275917</literal></expr>:</case> <comment type="line">// align</comment>
                                    <switch>switch <condition>(<expr><name><name>m_xmlAttribute</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>valueHashCode</name></expr>)</condition>
                                    <block>{
                                        <case>case <expr><literal type="number">3774683</literal></expr>:</case> <comment type="line">// left</comment>
                                            <expr_stmt><expr><call><name><name>Debug</name><operator>.</operator><name>Log</name></name><argument_list>(<argument><expr><literal type="string">"TD align=\"left\"."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                            <break>break;</break>
                                        <case>case <expr><literal type="number">136703040</literal></expr>:</case> <comment type="line">// right</comment>
                                            <expr_stmt><expr><call><name><name>Debug</name><operator>.</operator><name>Log</name></name><argument_list>(<argument><expr><literal type="string">"TD align=\"right\"."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                            <break>break;</break>
                                        <case>case <expr><operator>-</operator><literal type="number">458210101</literal></expr>:</case> <comment type="line">// center</comment>
                                            <expr_stmt><expr><call><name><name>Debug</name><operator>.</operator><name>Log</name></name><argument_list>(<argument><expr><literal type="string">"TD align=\"center\"."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                            <break>break;</break>
                                        <case>case <expr><operator>-</operator><literal type="number">523808257</literal></expr>:</case> <comment type="line">// justified</comment>
                                            <expr_stmt><expr><call><name><name>Debug</name><operator>.</operator><name>Log</name></name><argument_list>(<argument><expr><literal type="string">"TD align=\"justified\"."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                            <break>break;</break>
                                    }</block></switch>
                                    <break>break;</break>
                            }</block></switch>
                        }</block></for>

                        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                    <case>case <expr><literal type="number">3215</literal></expr>:</case> <comment type="line">// &lt;/td&gt;</comment>
                    <case>case <expr><literal type="number">2959</literal></expr>:</case> <comment type="line">// &lt;/TD&gt;</comment>
                        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
                }</block></switch>
            }</block></else></if>
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        }</block></function>
    }</block></class>
}</block></namespace>
</unit>
